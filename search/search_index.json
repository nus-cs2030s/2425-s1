{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"CS2030<sub>s</sub>","text":""},{"location":"index.html#ay-202425-semester-1","title":"AY 2024/25 Semester 1","text":"<p>This website hosts the lecture notes, lecture slides, and other written guides about CS2030S. You can explore the links on the menu on the left, or search for keywords in the search bar above.</p>"},{"location":"index.html#other-web-resources","title":"Other Web Resources","text":"<ul> <li>Canvas</li> <li>Ed</li> <li>CS2030S Ticketing System</li> </ul>"},{"location":"00-overview.html","title":"Unit 0: Overview","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the aims of CS2030/S.</li> <li>understand how the key concepts covered in CS2030/S are related to each other.</li> </ul>"},{"location":"00-overview.html#what-is-this-module-about","title":"What is This Module About?","text":"<p>CS2030/S is designed for students who have gone through a typical basic programming module and have learned about problem-solving with simple programming constructs such as loops, conditions, and functions.  In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small programs (in the order of tens or hundreds of lines of code) to solve a programming homework problem, work alone on their code, and move on to solve the next problem once the homework is done.</p> <p>The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirements change and to write software that will be read and modified by other programmers (including their future selves).</p> <p>Quote</p> <p>\"Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability.\"</p> <p>John Woods.</p> <p>The second aim of CS2030/S is to level up the complexity of programs that the students write, from the order of hundreds of lines to thousands of lines.  CS2030/S bridges the students between writing toy programs to solve specific problems in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering.</p> <p>A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above.  With the appropriate features and tools, one can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve.  The third aim of CS2030/S is thus to expand the students' minds on different ways one can construct software and the principles behind some of the programming language constructs.  In particular, CS2030/S focuses on objects, types, and functions, as three key constructs for building programmer-friendly software.  It covers both object-oriented and functional paradigms as two different approaches to constructing software, with a strong emphasis on type safety.</p> <p>The final aim of CS2030/S is to introduce students to programming language concepts and to bridge them from introductory programming to advanced modules such as programming language design and implementation.  Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules.</p> <p>Priority</p> <p>When writing programs to solve problems, the general priority should be the following:</p> <ol> <li>Correctness: Can your program run and solve the problem correctly.</li> <li>Efficiency: Can your program solve the problem in an efficient way.</li> <li>Maintainability: Can your program be maintained and improved upon by multiple people.</li> </ol> <p>The priority in CS1010 is correctness.  CS2040/S teaches you about how to increase efficiency while CS2030/S focuses more on maintainability.  However, you should never sacrifice on correctness.</p>"},{"location":"00-overview.html#the-choice-of-java","title":"The Choice of Java","text":"<p>We decided to use one programming language throughout the module.  This decision means that we need to pick a language that is strongly typed with static typing and supports both object-oriented and functional programming.  Considering multiple factors, we decided to choose Java for CS2030/S, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum.</p> <p>While Java is not the most elegant programming language when expressing programs in a functional style, we hope that students can still learn the principles of functional programming and apply them in other programming languages.  This choice is a trade-off between having to switch to a different language in the middle of a module.  </p>"},{"location":"00-overview.html#what-this-module-is-not-about","title":"What This Module is not About","text":"<p>This is not a module on Java programming.  We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach.  In fact, we will avoid and even ban students from using certain Java features (such as <code>var</code>) for pedagogical purposes.</p> <p>This is not a module on software engineering either.  Software engineering is a broad discipline on its own and deserves another module.  Rather, this module is about the programming principles and constructs on top of which programmers can design better software.  To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as Liskov Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritance, etc.  But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S, O, I, and D in SOLID).</p> <p>Finally, CS2030/S is not a module that focuses on computational efficiency.  We have CS2040/S for that.  In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters.  CS2030/S is also concerned with the human cost of debugging or maintaining software.  In striving for simpler software that is easier to maintain and extend, we may have to sacrifice computational efficiency.</p>"},{"location":"00-overview.html#taming-complexity-in-software-development","title":"Taming Complexity in Software Development","text":"<p>An underlying theme of CS2030/S is taming complexity in software development.  There are objective metrics with which one can measure the complexity of software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program.</p> <p>Let's start by considering a simplified view of what a software program is.  One can view a software program as a collection of data variables and instructions on how to modify these variables.  A program is generally written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement.  Often, the program stores information in the intermediate variables while performing the computation.</p> <p>As a student who has gone through an introductory programming module such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing a program to solve a given computational problem.  The program you have written for these introductory modules are small \"toy\" programs mostly -- they consist of only a few hundred lines and tens of variables, at most.</p> <p>Software development in the real world, however, is far more complex than what you have experienced.  A software program rarely solves a well-defined computational problem only.  It often requires multiple components, such as user interface, data storage, and business rules, intricately interacting with each other to attain a set of functionalities.  </p> <p>As the requirement of the software becomes more complex, the number of variables that need to be kept track of increases; the logic of the computation the programmer needs to maintain the variables becomes more complicated.  Further, it is often that the variables are interdependent.  For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable.  As the number of variables increases, so is the number of relationships between the variables that the programmer has to keep track of.  Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs.</p> <p>Further, real-world software rarely remains static.  This property is again different from what you have experienced in your introductory programming module, where once the instructors release a programming assignment, they rarely go back and change the requirement.  In the real world, software evolves -- new features are added, business rules change, and better algorithms are deployed.  The code needs to be updated accordingly -- adding new variables and new computation; changing how variables are updated or are dependent on each other.  Updating the code of an already-complex software program to keep up with the requirement, if not managed properly, can lead to bugs.</p> <p>Real-world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming module, where you solve your homework individually.  When multiple programmers work together, the interdependency between the states needs to be communicated and handled properly and consistently across the programmers.  One programmer's modification to the code should not introduce bugs into another programmer's code.  </p> <p>Since software evolves, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time.  Changing one's code should not introduce new bugs to other parts of the code that is written some time ago.  </p>"},{"location":"00-overview.html#strategies-to-tame-complexity","title":"Strategies to Tame Complexity","text":""},{"location":"00-overview.html#good-software-development-practices","title":"Good Software Development Practices","text":"<p>If you are taught properly in your introductory programming modules, you should already be familiar with good programming practices that help to tame the complexity and reduce the chances of bugs.  These practices include</p> <ul> <li> <p>Commenting your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states.  Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes.</p> </li> <li> <p>Using a coding convention: Adhering to a coding convention helps improve code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly.</p> </li> </ul> <p>CS2030/S will continue to enforce these good programming practices.</p>"},{"location":"00-overview.html#functions","title":"Functions","text":"<p>You should also be taught to always break your code down into functions, each one performing a simple, specific, task.  The functions can then be composed to solve larger and more complex tasks.  Functions are an important programming structure in taming code complexity, it allows programmers to</p> <ol> <li>compartmentalize computation and its effects, reducing the number of interactions to a few well-defined ones (through arguments and return values).</li> <li>hide the implementation details so that they can be changed later without affecting other parts of the code.</li> <li>reuse computations and thus write code that is more succinct and easier to understand/change.</li> </ol> <p>In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches.  A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition.</p>"},{"location":"00-overview.html#the-abstraction-principle","title":"The Abstraction Principle","text":"<p>The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle<sup>1</sup>.  The principle states that:</p> <p>Abstraction Principle</p> <p>\"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"</p> <p>Benjamin C. Pierce.</p> <p>This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation on.  We will also apply this principle to</p> <ol> <li>types, abstracting them out as parameterized types or subtypes</li> <li>sub-computation, abstracting them out as first-class functions.</li> </ol> <p>These concepts: generics, subtypes, and first-class functions, underlies most of the content of CS2030/S.</p>"},{"location":"00-overview.html#erecting-an-abstraction-barrier","title":"Erecting an Abstraction Barrier","text":"<p>Another important strategy for taming complexity is the abstraction barrier.  Let's separate the role of a programmer into two, in the context of writing functions: the implementer, who implements the function, and the client, who calls the function.  The implementer should compartmentalize the internal variables and the implementation of the function, hiding them behind the abstraction barrier.  The parameters and the return values are the only communication gateways across the barrier.  </p> <p>The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well.  We will see how we maintain this barrier not only in the context of functions, but also variables and computations on these variables together, by encapsulating them as objects, and hiding details from the client through access modifiers.  These ideas form two of the core principles of object-oriented programming: encapsulation and abstraction.  </p>"},{"location":"00-overview.html#code-for-change","title":"Code for Change","text":"<p>The abstraction barrier, if erected and maintained properly, reduces code complexity.  It, however, also reduces flexibility as the software evolves.  If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer.  In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier.  </p> <p>First, we will introduce the concept of inheritance and polymorphism, the other two core principles of object-oriented programming.  These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code.  </p> <p>Second, we will introduce closure, an abstraction to computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation.  The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in the functional programming paradigm.  A monad is a computational structure that allows objects to be composed and manipulated in a succinct and powerful way.</p>"},{"location":"00-overview.html#types","title":"Types","text":"<p>Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly.  To prevent this, both the programming language system and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code.  Java and many other typed languages have type systems -- a set of rules that governs how variables, expressions, and functions interact with each other.  You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs.</p> <p>A type system is also an important tool to reduce the complexity of software development.  Constraining the interactions among the variables, expressions, and functions, it reduces the possible interdependence between these programming constructs.  Furthermore, any attempt by programmers to break the constraint can be caught automatically by the compiler.  By utilizing the type system properly, we can detect potential bugs before they manifest themselves.</p> <p>A reason CS2030/S chooses to use Java is due to its type system.  CS2030/S will introduce the concept of types, subtypes, compile-time vs. run-time types, variants of types, parameterized types, and type inferences, in the context of Java.  We will see how we can define our own types (using classes and interfaces) and define relationships between them.  We will see how we can define parameterized types and generic functions that take in types as parameters.  These concepts apply to many other programming languages.</p>"},{"location":"00-overview.html#eliminating-side-effects","title":"Eliminating Side Effects","text":"<p>We have discussed how functions can compartmentalize computations and limit their complexity within their body.  For this approach to be effective, the function must not have any side effects -- such as updating a variable that is not within the function.  Such functions, called pure functions, are one of the key principles of the functional programming paradigm and is something that we will explore to kick off the section on functional paradigm in CS2030/S.</p> <p>A related idea in object-oriented programming we will cover in CS2030/S is immutability -- once we create an object, the object cannot be changed.  In order to update an object, we need to create a new one.  With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value.  This certainty can help in understanding and reasoning about the code behavior.</p> <ol> <li> <p>This principle is formulated by Benjamin C. Pierce in his book \"Types and Programming Languages.\"\u00a0\u21a9</p> </li> </ol>"},{"location":"01-compiler.html","title":"Unit 1: Program and Compiler","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>recap some fundamental programming concepts, including the concept of a program, a programming language, a compiler, an interpreter.</li> <li>be aware of two modes of running a Java program (compiled vs. interpreted).</li> <li>be aware that compile-time errors are better than run-time errors, but the compiler cannot always detect errors during compile time.</li> </ul>"},{"location":"01-compiler.html#software-program","title":"Software Program","text":"<p>A software program is a collection of data variables and instructions on how to modify these variables.  To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that are made up of keywords, symbols, and names.  </p> <p>A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer.  </p>"},{"location":"01-compiler.html#compiled-vs-interpreted-programs","title":"Compiled vs. Interpreted Programs","text":"<p>The processing unit of a computer can only accept and understand instructions written in machine code.  A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution.  There are different approaches to how such translations can be done.  The first approach uses a compiler -- a software tool that reads in the entire program written in a higher-level programming language and translates it into machine code.  The machine code is then saved into an executable file, which can be executed later.  <code>clang</code>, a C/C++ compiler, is an example.  The second approach uses an interpreter -- software that reads in the program one statement at a time interprets what the statement means, and executes its directly.   This is how Python and Javascript programs are executed. </p> <p>Modern programming systems for executing programs are, however, more sophisticated.  V8, for instance, is an open-source engine that executes Javascript, and it contains both an interpreter that first interprets a Javascript into bytecode (an intermediate, low-level representation).  A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. </p> <p>Java programs, on the other hand, can be executed in two ways:</p> <ol> <li>The Java program can first be compiled into bytecode.  During execution, the bytecode is interpreted and compiled on-the-fly by the Java Virtual Machine (JVM) into machine code.</li> <li>The Java program can be interpreted by the Java interpreter.</li> </ol> <p>To better understand this distinction, we will introduce a visual aid to describe the relationships between programs, compilers, interpreters, and machines.</p>"},{"location":"01-compiler.html#tombstone-diagrams-t-diagrams","title":"Tombstone Diagrams (T-Diagrams)","text":"<p>Tombstone Diagrams or T-diagrams consist of combinations of the following four components: </p> <ul> <li>Programs which are implemented in a particular language (i.e., <code>Java</code>, <code>python</code>, <code>c/c++</code>)</li> <li>Language A Interpreters implemented in language B</li> <li>Language A to language B Compilers which are implemented in a language C</li> <li>Physical Machines implementing a particular language (i.e., x86-64, ARM-64)</li> </ul> <p>These components are represented in T-diagrams as shown in the figure below:</p> <p></p> <p>We can treat these components like \"puzzle pieces\" and build diagrams to describe various execution, compilation, or interpreted processes.  For example, in the diagram below, a python script <code>Hello.py</code> is being interpreted by the python interpreter running on the x86-64 architecture.</p> <p></p> <p>Note: In order for the diagram to be valid, adjacent connected diagram components need to match. This can be seen in the diagram below (highlighted with blue boxes).</p> <p></p> <p>Since CS2030/S uses Java, we will now look at the two approaches to execute a Java program in more detail (without worrying about how to write a single line of Java first).</p>"},{"location":"01-compiler.html#compiling-and-running-java-programs","title":"Compiling and Running Java Programs","text":"<p>Suppose we have a Java program called <code>Hello.java</code>.  To compile the program, we type<sup>1</sup></p> <pre><code>$ javac Hello.java\n</code></pre> <p>into the command line.  <code>javac</code> is the Java compiler.  This step will either lead to the bytecode called <code>Hello.class</code> being created or spew out some errors.  This process can be seen in the figure below, where the <code>Hello.java</code> program is compiled from Java to the JVM language (bytecode). The Java compiler <code>javac</code> in this diagram is implemented in the x86-64 machine language.</p> <p></p> <p>Assuming that there is no error in compilation, we can now run</p> <pre><code>$ java Hello\n</code></pre> <p>to invoke the JVM <code>java</code> and execute the bytecode contains in <code>Hello.class</code>. This can be seen in the figure below, where the <code>Hello.class</code> program is interpreted from JVM language (bytecode) to the x86-64 machine language.</p> <p></p> <p>Beginners tend to confuse between <code>javac</code> and <code>java</code>, and whether to add the extension <code>.java</code> or <code>.class</code> when compiling and executing a Java program.  Do take note and refer back here if needed<sup>2</sup>.</p> <p>Common Mistakes</p> <p>A common mistake when compiling and running Java program is to use the <code>java</code> command on a <code>.java</code> file instead of the <code>javac</code> command. To make matter worse, you can some time run the <code>.java</code> program using the <code>java</code> command seemingly bypassing the need for compilation using <code>javac</code> command. This feature is called \"Launch Single-File Source-Code Programs\". In general, avoid the following command.</p> <pre><code>$ java Hello.java\n</code></pre>"},{"location":"01-compiler.html#interpreting-a-java-program","title":"Interpreting a Java program","text":"<p>Java (version 8 or later) comes with an interpreter called <code>jshell</code> that can read in Java statements, evaluate them, and print the results<sup>3</sup>. <code>jshell</code> is useful for learning and experimenting about Java.   This can be seen in the figure below, where the <code>Hello.java</code> program is interpreted from Java directly to the x86-64 machine language. </p> <p></p> <p>To run <code>jshell</code> in interactive mode, we type</p> <pre><code>$ jshell\n</code></pre> <p>on the command line, which causes an interactive prompt to appear:</p> <pre><code>$ jshell\n|  Welcome to JShell -- Version 17\n|  For an introduction type: /help intro\n\njshell&gt;\n</code></pre> <p>We can now type in Java code on <code>jshell&gt;</code>. </p> <p>Alternatively, we can also include all the Java statements that we want <code>jshell</code> to run in a file and pass it into jshell</p> <pre><code>$ jshell Hello.jsh\n</code></pre> <p>While <code>jshell</code> is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that <code>jshell</code> combined both compilation and run-time into a single step.  The error spewed out by <code>jshell</code> could be either compile-time error or run-time error, and this could be confusing to beginners who try to distinguish between the two phases of program execution.</p> <p>jsh vs java</p> <p>Files intended to be run on jshell typically uses <code>.jsh</code> extension while files intended to be compiled and run uses <code>.java</code> extension.  However, this difference is merely a convention.  You can still interpret <code>.java</code> program on jshell.</p>"},{"location":"01-compiler.html#compiler","title":"Compiler","text":"<p>Quote</p> <p>\"One man's program is another program's data.\"</p> <p>Olivier Danvy</p> <p>The compiler does more than just translating source code into machine code or bytecode.  The compiler also needs to parse the source code written and check if it follows the precise specification of the programming language (called grammar) used, and produces a syntax error if the grammar is violated.  It therefore can detect any syntax error before the program is run.</p> <p>It is much better for a programmer to detect any error in its code during compilation -- since this is the phase when the program is still being developed and under the control of the programmer.  Runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable.  As such, we try to detect errors as much as possible during compilation.  The compiler is a powerful friend for any programmer if used properly.</p> <p>The power of the compiler, however, is limited.  A compiler can only read and analyze the source code without actually running it.  Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take.</p> <p>To deal with this, the compiler can either be conservative, and report an error as long as there is a possibility that a particular statement is incorrect; or, the compiler can be more permissive, reporting an error only if there is no possiblity that a particular statement is correct.  If there is a possibility that a particular statement is correct, it does not throw an error, but rely on the programmer to do the right thing.  We will further contrast these two behaviors later in this module.</p> <p>Interpreter vs Compiler</p> <p>There is a slight difference between the behavior of Java interpreter and compiler. Java interpreter initialize all variables with the default values. On the other hand, Java compiler will mark the variable as uninitialized. This is different from the default values in a sense that an uninitialized value cannot be used.</p> <p>The compiler will produce an error if an uninitialized value is used. There are two possible reasons for this. The first reason is speed. Initializing the variable to a default value requires an additional operation on the compiled code. The second reason is that an uninitialized variable usually indicates an error and may produce an undefined behavior.</p>"},{"location":"01-compiler.html#workflow","title":"Workflow","text":"<p>A typical workflow in a compiled language is the edit, compile, execute, loop.  To start, we first either create or edit the file containing our Java program (e.g., <code>Hello.java</code>) with our favourite editor.  We recommend the use of <code>vim</code> editor.  This will be our source code.</p> <p>We then compile our source code using a compiler (e.g., <code>javac Hello.java</code>) to produce a <code>.class</code> file.  If the program compiles, then we proceed with the next step. Otherwise, we go back to editing our source code.</p> <p>The next step is to execute the program and test.  If we find incorrect result in our testing, we restart from the first step again.  This step is performed until we are satisfied with our program or until we have to submit our program.  The diagram below summarises the steps.</p> <p></p> <p>Steps</p> EditCompileExecute <ol> <li>Create a new Java program file with the extension <code>.java</code> or edit an existing file.<ul> <li>We would recommend the use of <code>vim</code> as it is available on PE node so you can work almost anywhere with an active internet connection.</li> <li>Using <code>vim</code>, you can type <code>vim Hello.java</code>.</li> </ul> </li> <li>Save the file (e.g., <code>Hello.java</code>).<ul> <li>To save an exit on <code>vim</code>, the command is <code>:wq</code>.</li> </ul> </li> </ol> <ol> <li>Compile your Java program from the \"Edit\" step using <code>javac</code> (e.g., <code>Hello.java</code>).<ul> <li>The command is <code>javac Hello.java</code>.</li> </ul> </li> <li>You will either<ul> <li>produce a bytecode (e.g., <code>Hello.class</code>), then you continue to \"Execute\" step, or</li> <li>fail to compile (i.e., compilation error), then you repeat the \"Edit\" step to repair the program and remove the source of the compilation error according to the given error message.</li> </ul> </li> </ol> <ol> <li>Execute your bytecode (e.g., <code>Hello.class</code>) using <code>java</code>.<ul> <li>The command is <code>java Hello</code>.</li> </ul> </li> <li>You will either<ul> <li>get the correct program output and you are satisfied with your work and finish, or</li> <li>get the incorrect program output, then your repeat the \"Edit\" and \"Compi;e\" step to repair your program until you get the correct program output or you run out of time.</li> </ul> </li> </ol> <ol> <li> <p>The <code>$</code> represents the command prompt in a shell and you do not need to type this.\u00a0\u21a9</p> </li> <li> <p>To add to the confusion, Java 11 introduces a shortcut where we can run <code>java Hello.java</code> directly.  This command causes <code>Hello.java</code> to be compiled and executed in a single step.  We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly.\u00a0\u21a9</p> </li> <li> <p>Such a program is called REPL (Read-Evaluate-Print in a Loop) for short.\u00a0\u21a9</p> </li> </ol>"},{"location":"02-type.html","title":"Unit 2: Variable and Type","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>appreciate the concept of variables as an abstraction</li> <li>understand the concept of types and subtypes</li> <li>contrast between statically typed language vs. dynamically typed language</li> <li>contrast between strongly typed language vs. weakly typed language</li> <li>be familiar with Java variables and primitive types</li> <li>understand widening type conversion in the context of variable assignments and how subtyping dictates whether the type conversion is allowed.</li> </ul>"},{"location":"02-type.html#data-abstraction-variable","title":"Data Abstraction: Variable","text":"<p>One of the important abstractions that are provided by a programming language is the variable.  Data are stored in some location in computer memory.  But we should not be referring to the memory location all the time.  First, referring to something like <code>0xFA49130E</code> is not user-friendly; Second, the location may change.  A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory.  We use the variable name whenever we want to access the value in that location, and pointer to the variable or reference to the variable whenever we want to refer to the address of the location.</p> <p></p>"},{"location":"02-type.html#type","title":"Type","text":"<p>As programs get more complex, the number of variables that the programmer needs to keep track of increases.  These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc.  Not all operations are meaningful over all types of data.</p> <p>To help mitigate the complexity,  we can assign a type to a variable.  The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves.  In lower-level programming languages like C, the type also informs the compiler how the bit representing the variable should be interpreted.</p> <p>As an example of how types can affect how an operation behaves, let's consider Python.  Suppose we have two variables <code>x</code> and <code>y</code>, storing the values <code>4</code> and <code>5</code> respectively and we run <code>print(x + y)</code>.</p> <ul> <li>If <code>x</code> and <code>y</code> are both strings, the output is <code>45</code>.</li> <li>If <code>x</code> and <code>y</code> are both integers, the output is <code>9</code>.</li> <li>If <code>x</code> is an integer and <code>y</code> is a string (or vice versa), you would get an error.</li> </ul> <p>In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation <code>+</code> is not defined over an integer and a string in Python.</p> <p>Java and Javascript, however,  would happily convert <code>4</code> into a string for you, and return <code>45</code>.</p>"},{"location":"02-type.html#dynamic-vs-static-type","title":"Dynamic vs. Static Type","text":"<p>Python and Javascript are examples of dynamically typed programming languages.  The same variable can hold values of different unrelated types, and checking if the right type is used is done during the execution of the program.  Note that, the type is associated with the values, and the type of the variable changes depending on the value it holds.  For example, we can do the following:</p> JavascriptPython <pre><code>let i = 4;   // i is an integer\ni = \"5\";     // ok, i is now a string\n</code></pre> <pre><code>i = 4        // i is an integer\ni = \"5\"      // ok, i is now a string\n</code></pre> <p>Java, on the other hand, is a statically typed language.  We need to declare every variable we use in the program and specify its type.  A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type <code>int</code>.  Once a variable is declared with a particular, the type of the variable cannot be changed.  In other words, the variable can only hold values of that declared type.</p> <pre><code>int i;   // declare a variable of type int\ni = 4;   // ok because 4 is of type int\ni = \"5\"; // error, cannot assign a string to an `int`\n</code></pre> <p>The type that a variable is assigned with when we declare the variable is also known as the compile-time type.  During the compilation, this is the only type that the compiler is aware of.  The compiler will check if the compile-time type matches when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch.  This type-checking step helps to catch errors in the code early.</p> <p>Types on Variable</p> <p>An important distinction between dynamic and static type is where is the type gets attached to.  In static typing, the type is attached to the variable such that the variable can only store values of that particular type (or its subtype as you will see later).  In fact, in Java, the type that is attached to a variable is the declared type (i,e., the type written in the variable declaration also commonly known as compile-time type).</p> <p>On the other hand, in dynamically typed language, the type is attached to the value.  In other words, a variable can store anything but we can know what the type is because the type can be queried from the value.</p>"},{"location":"02-type.html#strong-typing-vs-weak-typing","title":"Strong Typing vs. Weak Typing","text":"<p>A type system of a programming language is a set of rules that governs how the types can interact with each other.  </p> <p>A programming language can be strongly typed or weakly typed.  There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language.  </p> <p>Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety, i.e., to ensure that if there are any problems with the program, it is not due to the type.  For instance, catching attempt at multiplying two strings.  One way to ensure type safety is to catch type errors during compile time rather than leaving it to runtime.</p> <p>On the other hand, a weakly typed (or loosely typed) programming language is more permissive in terms of typing checking.  C is an example of a static, weakly typed language.  In C, the following is possible:</p> <pre><code>int i;        // declare a variable of type int\ni = 4;        // ok because 4 is of type int\ni = (int)\"5\"; // you want to treat a string as an int? ok, as you wish!   \n</code></pre> <p>The last line forces the C compiler to treat the string (to be more precise, the address of the string) as an integer, through typecasting.</p> <p>In contrast, if we try the following in Java:</p> <pre><code>int i;        // declare a variable of type int\ni = 4;        // ok because 4 is of type int\ni = (int)\"5\"; // error\n</code></pre> <p>we will get the following compile-time error message:</p> <pre><code>|  incompatible types: java.lang.String cannot be converted to int\n</code></pre> <p>because the compiler enforces a stricter rule and allows typecasting only if it makes sense.  More specifically, we will get compilation error if the compiler can determine with certainty that such conversion can never happen successfully.</p>"},{"location":"02-type.html#type-checking-with-a-compiler","title":"Type Checking with A Compiler","text":"<p>In addition to checking for syntax errors, the compiler can check for type compilability according to the compile-time type, to catch possible errors as early as possible.  Such type checking is made possible with static typing.  Consider the following Python program:</p> <pre><code>i = 0\nwhile (i &lt; 10):\n  # do something that takes a loooooooooooooooooooooooong time\n  i = i + 1\nprint(\"i is \" + i)\n</code></pre> <p>Since Python does not allow adding a string to an integer, there is a type mismatch error on Line 5.  The type mismatch error is only caught when Line 5 is executed after the program is run for a long time.  Since the type of the variable <code>i</code> can change during run time, Python (and generally, dynamically typed languages) cannot tell if Line 5 will lead to an error until it is evaluated during run time.</p> <p>In contrast, statically typed language like Java can detect type mismatch during compile time since the compile-time type of a variable is fixed.  As you will see later, Java allows \"addition\" or string and integer, and but multiplication of a string and an integer.  If we have the following code, Java can confidently produce compilation errors without even running a program: </p> <pre><code>i = 0\nwhile (i &lt; 2) {\n  // do something that takes a loooooooooooooooooooooooong time\n  i = i + 1;\n}\nprint(\"ba\" + (\"na\" * i)); // \"banana\"?\n</code></pre>"},{"location":"02-type.html#primitive-types-in-java","title":"Primitive Types in Java","text":"<p>We now switch our focus to Java, particularly to the types supported.  There are two categories of types in Java, the primitive types and the reference types.  We will first look at primitive types in this unit.</p> <p>Primitive types are types that holds numeric values (integers, floating-point numbers) as well as boolean values (<code>true</code> and <code>false</code>).  </p> <p>For storing integral values, Java provides four types, <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code>, for storing 8-bit, 16-bit, 32-bit, and 64-bit signed integers respectively.  The type <code>char</code> stores 16-bit unsigned integers representing UTF-16 Unicode characters.</p> <p>For storing floating-point values, Java provides two types, <code>float</code> and <code>double</code>, for 32-bit and 64-bit floating-point numbers.</p> <p>Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: <pre><code>int i = 1000;\nint j = i;\ni = i + 1;\n</code></pre></p> <p><code>i</code> and <code>j</code> each store a copy of the value <code>1000</code> after Line 2.  Changing <code>i</code> on Line 3 does not change the content of <code>j</code>.</p> Kinds Types Sizes Boolean <ul><li><code>boolean</code></li></ul> <ul><li>1-bit</li></ul> Character <ul><li><code>char</code></li></ul> <ul><li>16-bit</li></ul> Integral <ul><li><code>byte</code></li><li><code>short</code></li><li><code>int</code></li><li><code>long</code></li></ul> <ul><li>8-bit</li><li>16-bit</li><li>32-bit</li><li>64-bit</li></ul> Floating-Point <ul><li><code>float</code></li><li><code>double</code></li></ul> <ul><li>32-bit</li><li>64-bit</li></ul> <p>Long and Float Constant</p> <p>To differentiate between a <code>long</code> and an <code>int</code> constant, you can use suffix <code>L</code> to denote that the value is expected to be of <code>long</code> type.  This is important for large values beyond the range of <code>int</code>.  On the other hand, if the constant is a floating-point constant, by default it is treated as type <code>double</code>.  You need to add suffix <code>f</code> to indicate that the value is to be treated as a <code>float</code> type.</p>"},{"location":"02-type.html#subtypes","title":"Subtypes","text":"<p>An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes.</p> <p>Subtype</p> <p>Let \\(S\\) and \\(T\\) be two types.  We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\).  </p> <p>We use the notation \\(T &lt;: S\\) or \\(S :&gt; T\\) to denote that \\(T\\) is subtype of \\(S\\).  Subtyping relationship in general must satisfy two properties:</p> <ol> <li>Reflexive: For any type \\(S\\), we have \\(S &lt;: S\\) (i.e., \\(S\\) is a subtype of itself).</li> <li>Transitive: If \\(S &lt;: T\\) and \\(T &lt;: U\\), then \\(S &lt;: U\\).  In other words, if \\(S\\) is a subtype of \\(T\\) and \\(T\\) is a subtype of \\(U\\), then \\(S\\) is a subtype of \\(U\\).</li> </ol> <p>Additionally, in Java, you will find that subtyping relationship also satisfies anti-symmetry<sup>1</sup>.  However, this is often omitted as it is enforced by design.</p> <ul> <li>Anti-Symmetry: If \\(S &lt;: T\\) and \\(T &lt;: S\\), then \\(S\\) must be the same type as \\(T\\).</li> </ul> <p>We also use the term supertype to denote the reversed relationship: if \\(T\\) is a subtype of \\(S\\), then \\(S\\) is a supertype of \\(T\\).</p>"},{"location":"02-type.html#subtyping-between-java-primitive-types","title":"Subtyping Between Java Primitive Types","text":"<p>Consider the range of values that the primitive types can take, Java defines the following subtyping relationship:</p> <ul> <li><code>byte</code> &lt;: <code>short</code> &lt;: <code>int</code> &lt;: <code>long</code> &lt;: <code>float</code> &lt;: <code>double</code></li> <li><code>char</code> &lt;: <code>int</code></li> </ul> <p>Graphically, we can draw the subtyping relationship as an arrow from subtype to supertype.  In the case of Java primitive types, we can visualise the subtyping relationship as follows:</p> <p></p> <p>Long \\(&lt;:\\) Float?</p> <p>Why is <code>long</code> a subtype of <code>float</code>?  More specifically, <code>long</code> is 64-bit and <code>float</code> is only 32-bit.  Clearly, there are more values in <code>long</code> than in <code>float</code>!</p> <p>The resolution lies in the precision.  While it is indeed true that all (mathematical) integer can be converted into a (mathematical) real number by simply appending <code>.0</code> to the end, some <code>long</code> values cannot be represented precisely as <code>float</code>.  Try the following and see what are printed.</p> <pre><code>long l = 123456789L;\nfloat f = l;\nSystem.out.println(l);\nSystem.out.println(f);\n</code></pre> <p>Given this, let us go back to the definition of subtype above and try to apply the definition to the code below that is written for variables of type <code>double</code>.</p> <ul> <li> <p>Written for Double</p> <pre><code>// type of S is double\ndouble x = 5.0;\n// code below is\n//   written assuming\n//   S = double\ndouble y = x + x;\n</code></pre> </li> <li> <p>Used for Integer</p> <pre><code>// type of S is now int\nint x = 5;\n// code below is\n//   written assuming\n//   S = double\ndouble y = x + x;\n</code></pre> </li> </ul> <p>Common Mistake</p> <p>It is common to mistake which part of the code is \"written for\" and which part is \"used by\". The following code below is written for integer. In particular, Line 3 <code>int y = x + x</code> only works for <code>int</code>. The input given is now a <code>double</code>.</p> <pre><code>double x = 5.0;\n// code below is written assuming S = int\nint y = x + x;     // oh no! it does not work!\n</code></pre> <p>Another common mistake is to simply change all the types from <code>double</code> to <code>int</code>. Since we change all the types to <code>int</code>, the code is \"written for\" <code>int</code> and not \"used by\" <code>int</code>.</p> <pre><code>int x = 5.0;\nint y = x + x;\n</code></pre> <p>Valid subtype relationship is part of what the Java compiler checks for when it compiles.  Consider the following example:</p> CodeWhat Compiler Sees <pre><code>double d = 5.0;\nint i = 5;\nd = i;\ni = d; // error\n</code></pre> <pre><code>double d = 5.0;  // d::double &lt;- 5.0::double\nint i = 5;       // i::int    &lt;- 5::int\nd = i;           // d::double &lt;- i::int (ok because int &lt;: double)\ni = d;           // i::int    &lt;- d::double (error because double &lt;/: int)\n</code></pre> <p>Line 4 above would lead to an error:</p> <pre><code>|  incompatible types: possible lossy conversion from double to int\n</code></pre> <p>but Line 3 is OK.  If you are still wondering why it does not work, you can click on the tab to see what the compiler \"sees\" in terms of compile-time type.</p> <p>As you can see, the compile-time type of the variable <code>d</code> is <code>double</code> because that is what we declared it as.  Similarly, the compile-time type of the variable <code>i</code> is <code>int</code>.  Since <code>double</code> is the supertype of <code>int</code>, it can also store <code>int</code>.  On the other hand, an <code>int</code> cannot store <code>double</code>.</p> <p>This example shows how subtyping applies to type checking.  Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S &lt;: T\\).  This step is called widening type conversion.  Such conversion can happen during assignment or parameter passing.</p> <p>Why is it Called Widening?</p> <p>The term widening is easy to see for primitive types with the exception of <code>long</code> to <code>float</code>.  You can immediately see that the subtype has fewer number of bits than the supertype.  Therefore, the supertype can have more possible values.  Hence, the size (i.e., the number of possible values) is wider.</p> <p>The opposite conversion is called narrowing because the size is narrower.</p>"},{"location":"02-type.html#additional-readings","title":"Additional Readings","text":"<ul> <li>Java Tutorial: Primitive Data Types and other Language Basics</li> </ul> <ol> <li> <p>For those with knowledge of discrete mathematics, this forms a partial order.\u00a0\u21a9</p> </li> </ol>"},{"location":"03-function.html","title":"Unit 3: Functions","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the importance of function as a programming constructor and how it helps to reduce complexity and mitigate bugs.</li> <li>be aware of two different roles a programmer can play: the implementer and the client.</li> <li>understand the concept of abstraction barrier as a wall between the client and the implementer, including in the context of a function.</li> </ul>"},{"location":"03-function.html#function-as-an-abstraction-over-computation","title":"Function as an Abstraction over Computation","text":"<p>Another important abstraction provided by a programming language is the function (or procedure).  This abstraction allows programmers to group a set of instructions and give it a name.  The named set of instructions may take one or more variables as input parameters, and return zero or one values.</p> <p>Like all other abstractions, defining functions allow us to think at a higher conceptual level.  By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity.</p> <p>Functions help us deal with complexity in a few ways as you will see later.  For now, to understand the examples, we will first describe a basic element of a function.  Note that this cannot be compiled but need to be run on Jshell.  Once we have introduced the concept of a class, our code can be compiled.</p> <p>Syntax</p> <p>The basic syntax of a function is as follows:</p> <pre><code>return_type function_name(param_type1 param1, param_type2 param2) {\n    : // function body\n}\n</code></pre> <p>To create a function, we have to specify the return type.  If there is no return type, then we need to use the type called <code>void</code><sup>1</sup>.  This is then followed by the function name.  We may have zero or more parameters for a function.</p> <ul> <li> <p>Functions allow programmers to compartmentalize computation and its effects.  We can isolate the complexity to within its body: the intermediate variables exists only as local variables that has no effect outside of the function.  A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions.  Such compartmentalization reduces the complexity of code.</p> <p>Example</p> <pre><code>int factorial(int n) {\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\ndouble e(int n) { // approximate e^n using Taylor series\n  double x = 1;\n  double res = 0;\n  for (int i = 0; i &lt; 10; i++) {\n    res = res + (x/factorial(i));\n    x = x * n;\n  }\n  return res;\n}\n// The n in factorial is different from the n in e.\n</code></pre> </li> <li> <p>Functions allow programmers to hide how a task is performed.  The caller of the function only needs to worry about what the function does.  By hiding the details of how, we gain two weapons against code complexity.  First, we reduce the amount of information that we need to communicate among programmers.  A fellow programmer only needs to read the documentation to understand what the parameters are for, what the return values are.  There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions.  Second, as the design and requirement evolve, the implementation of a function may change.  But, as long as the parameters and the return value of a function remains the same, the caller of the function does not have to update the code accordingly.  Reducing the need to change as the software evolves reduces the chances of introducing bugs accordingly.</p> <p>Example</p> <pre><code>double sinc(double x) {\n  return Math.sin(x)/x;\n}\n</code></pre> <p>We do not need to know how to implement <code>sin(x)</code>, only whether <code>x</code> is in degree or radian.</p> </li> <li> <p>Functions allows us to reduce repetition in our code through code reuse.  If we have the same computation that we need to perform repeatedly on different values, we can construct these computations as functions, replacing the values with parameters, and pass in the values as arguments to the function.  This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs.  First, it makes the code more succinct, and therefore easier to read and understand.  Second, it reduces the number of places in our code that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs.</p> <p>Example</p> <pre><code>double distance(double x1, double y1, double x2, double y2) {\n    : // implementation omitted\n}\nboolean isEquilateral(double x1, double y1,\n    double x2, double y2, double x3, double y3) {\n  return distance(x1, y1, x2, y2) == distance(x2, y2, x3, y3)\n      &amp;&amp; distance(x1, y1, x2, y2) == distance(x1, y1, x3, y3);\n}\n</code></pre> <p>We define the function <code>distance</code> only once but we use it 4 times. If we made a some mistakes in the definition of <code>distance</code>, we simply have to correct the code in one place instead of 4 different places if we did not use function.</p> </li> </ul> <p>Returning More Than One Return Value?</p> <p>To return more than one values, we need to use a data type that can store multiple values.  At that point, it becomes a question of whether eating rice is eating one meal or hundreds of meals each consisting of a single grain of rice.</p>"},{"location":"03-function.html#abstraction-barrier","title":"Abstraction Barrier","text":"<p>We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body.  Above the barrier, the concern is about using the function to perform a task, while below the barrier, the concern is about how to perform the task.  </p> <p>While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from only a single person.  The abstraction barrier separates the role of the programmer into two: (i) an implementer, who provides the implementation of the function, and (ii) a client, which uses the function to perform the task.  Part of the aim in CS2030/S is to switch your mindset into thinking in terms of these two roles.  In fact, in CS2030/S, you will be both but may be restricted to just be either a client or an implementer on specific functionality.</p> <p>The abstraction barrier thus enforces a separation of concerns between the two roles.  The client do not have to care how the implementer implemented the functionality.  Similarly, the implementer does not have to care how the client is using the functionality as long as the client is following the specification of the functionality.</p> <p>The concept of abstraction barrier applies not only to a function, but it can be applied to different levels of abstraction as well.  We will see how it is used for a higher-level of abstraction in the next unit.</p> <ol> <li> <p><code>void</code> in Java is like a true nothingness (unlike Python <code>None</code> or JavaScript <code>undefined</code>).  If a function is declared as returning a type <code>void</code>, it cannot even be used in assignment!\u00a0\u21a9</p> </li> </ol>"},{"location":"04-encapsulation.html","title":"Unit 4: Encapsulation","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand composite data type as a even-higher level abstraction over variables.</li> <li>understand encapsulation as an object-oriented (OO) principle.</li> <li>understand the meaning of class, object, fields, methods, in the context of OO programming.</li> <li>be able to define a class and instantiate one as an object in Java.</li> <li>appreciate OO as a natural way to model the real world in programs.</li> <li>understand reference types in Java and its difference from the primitive types.</li> </ul>"},{"location":"04-encapsulation.html#abstraction-composite-data-type","title":"Abstraction: Composite Data Type","text":"<p>Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name to become a new type, and refer to it later.  This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details.   Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc.</p> <p>Defining composite data type allows programmers to abstract away and be separated from the concern of how a complex data type is represented.</p> <p>For instance, a circle on a 2D plane can be represented by the center (i.e., <code>x</code>, <code>y</code>) and its radius <code>r</code>, or it can be represented by the top left corner (i.e., <code>x</code>,<code>y</code>) and the width <code>w</code> of the bounding square.</p> <p>In C, we build a composite data type with <code>struct</code>.  For example,</p> <pre><code>typedef struct {\n  double x, y; // (x,y) coordinate of the center.\n  double r;    // radius\n} circle;\n</code></pre> <p>Once we have the <code>struct</code> defined, we have a new data type called <code>circle</code>.  However, we are not completely shielded from its representation, until we write a set of functions that operates on the <code>circle</code> composite type.  For instance,</p> <pre><code>double circle_area(circle c) { ... };\nbool   circle_contains_point(circle c, double x, double y) { ... };\nbool   circle_overlaps(circle c1, circle c2) { ... };\n  :\n</code></pre> <p>Implementing these functions requires knowledge of how a circle is represented.  The implementation will be different if we have a different representation of <code>circle</code> (e.g., <code>x</code> and <code>y</code> may represent the center of the circle or the top left corner of the bounding square).  But once the set of functions that operates on and manipulates circles is available, we can use the circle type without worrying about the internal representation.  Of course this assumes that we will only use the functions specifically written to work on circle type.</p> <p>Additionally, the example on <code>circle_overlap</code> highlights another advantage of having composite data type.  To see the advantage, imagine that you do not have the data type <code>circle</code>.  Then the function to check if two circles overlap would require 6 parameters.</p> <pre><code>bool circle_overlaps(double x1, double y1, double r1,\n    double x2, double y2, double r2) { ... };\n  :\n</code></pre> <p>We have used a nice numbering to clearly indicate how the parameters are related.  Those with the same suffix belong to the same circle.  But another programmer may instead write it in a different order.</p> <pre><code>bool circle_overlaps(double x1, double x2,\n    double y1, double y2, double r1, double r2) { ... };\n  :\n</code></pre> <p>Even worse, lazy programmer may even omit the suffix and make the entire code unreadable.  So the use of composite data type is like a \"glue\" that binds relevant data together.  That way, we know that all the elements that make up a circle will always be together.</p> <p>If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things.  In other words, the representation of the circle and the set of functions that operate on and manipulate circles, fall on the same side of the abstraction barrier.</p> <p>If you are the programmer who writes the code for the implementation of circle as well as the functions that operate on and manipulate circle then you are the implementer.  On the other hand, if you are the programmer who uses the function that manipulate circle, then you are the client.</p>"},{"location":"04-encapsulation.html#limitation-of-struct","title":"Limitation of <code>struct</code>","text":"<p>In the code above, we have a function to compute the area of a circle called <code>circle_area</code>.  This is a good practice of adding prefix to the function name to indicate what should the function work on.  However, it is merely a convention and another developer may simply name the function <code>getArea</code> as follows.</p> <pre><code>double getArea(circle c) { ... };\n</code></pre> <p>If there is only ever a circle in our code, then this is fine.  However, if we ever add another shape (e.g., <code>square</code>), then we cannot use the name <code>getArea</code> to compute the area of a square.</p> <pre><code>double getArea(square s) { ... };\n</code></pre> <p>This can be problematic once the code becomes more complex with many different <code>struct</code>s.  Without a proper naming convention -- which can be easily broken -- the code can be easily unmaintainable.</p> <p>The solution to this is to also \"glue\" the functions together with the data.  This is exactly what is done in Java.</p>"},{"location":"04-encapsulation.html#abstraction-class-and-object-or-encapsulation","title":"Abstraction: Class and Object (or, Encapsulation)","text":"<p>We can further bundle the composite data type and its associated functions on the same side of the abstraction barrier together.  This bundle is another abstraction called a class.</p> <p>Class</p> <p>A class is a data type with a group of functions associated with it.</p> <p>We call the data in the class as fields (or members, or states, or attributes, or properties<sup>1</sup>).  As for the associated functions, they are called methods.  A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use.</p> <p>The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation.</p> <p>Let's see how we can encapsulate the fields and methods associated together, using <code>Circle</code> as an example, in Java.</p> Circle v0.1<pre><code>class Circle {\n  double x;\n  double y;\n  double r;\n\n  double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <p>The code above defines a new class using the keyword <code>class</code>, give it a name <code>Circle</code><sup>2</sup>, followed by a block listing the member variables (with types) and the function definitions.</p> <p>Just like we can create variables of a given type, we can create objects of a given class.  Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values.</p> <p>In Java, the keyword <code>new</code> creates an object of a given class.  For instance, to create a <code>Circle</code> object, we can use</p> <pre><code>Circle c = new Circle();\nc.r = 10;    // set the radius to 10\nc.getArea(); // return 314.1592653589793\n</code></pre> <p>To access the fields and the methods, we use the <code>.</code> notation.  For example, <code>object.field</code> or <code>object.method(..)</code>.  This can be seen in Line 2 and Line 3 of the example above.</p>"},{"location":"04-encapsulation.html#a-bad-example","title":"A Bad Example","text":"<p>Let us take a moment to appreciate the example Circle v0.1 above.  This is a reasonable example as the method <code>getArea</code> is computing the area of the circle with the radius as specified in the field <code>r</code>.  So, we can clearly see that the method is associated with the data.  Consider adding another method but this time it takes in a pen and a paper and writes <code>\"CS2030S is easy\"</code> on the paper.</p> <pre><code>// Bad Circle\nclass Circle {\n  double x;\n  double y;\n  double r;\n\n  double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n  void write(Pen pen, Paper paper) {  // irrelevant method\n    pen.write(paper, \"CS2030S is easy\");\n  }\n}\n</code></pre> <p>Without even knowing the implementation of <code>pen.write(..)</code>, we can already see that this method is not associated with any circle at all.  In fact, it is not even using any of the fields of the circle.</p>"},{"location":"04-encapsulation.html#object-oriented-programming","title":"Object-Oriented Programming","text":"<p>A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point.  One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods.</p> <p>One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely.  If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behavior, and they allow certain actions.  We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used every day (unless we try to repair them)<sup>3</sup>.  </p> <p>To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods.</p> <p>Take, for example, the following partial problem description about online airline reservation system.</p> <p>Users need to be able to make bookings from an origin to a destination airport which may comprise multiple connecting flights. We record the booking date.</p> <p>We can identify the following from the problem description.</p> Nouns Properties Associated Verbs User <ul><li>Bookings made</li></ul> <ul><li>Make booking</li></ul> Booking <ul><li>Bookings date</li><li>Origin airport</li><li>Destination airport</li></ul> currently unknown Airport currently unknown currently unknown <p>From here, we can try to model the problem in OOP using three classes: <code>User</code>, <code>Booking</code>, and <code>Airport</code>.  However, since not much information is known about <code>Airport</code> and assuming the only identifiable information about airport is the airport code, then maybe we do not need to create an <code>Airport</code> class.  Instead, we use a <code>String</code>.</p> <p>However, for <code>User</code> and <code>Booking</code>, we clearly need to encapsulate the information into a class.  In the case of booking, it is simply because there are 3 different properties that need to be combined.  In the case of user, we have an associated verb that needs to be modelled as method.</p> <p>When to Stop?</p> <p>In the discussion above, we put forward the possibility that <code>Airport</code> need not be a class.  So the question is, when should we stop modelling a noun as a class?  We may be too eager to model everything as a class, including the date to be stored as booking date.  There is also the opposite problem of too lazy to model.  For instance, we may lazily group user and booking together to form a class with 4 fields.</p> <p>There is no clear answer to this but as a general guide, you may want to ask the following questions.</p> <ul> <li>Is there multiple properties to be stored?<ul> <li>If so, then creating a class is good.</li> <li>In the case of airport, if there is only a single data, then we need not make a class.</li> </ul> </li> <li>Is there an action associated with the entity?<ul> <li>If so, then creating a class is good.</li> <li>In the case of user, although it only has a single property, it has an association action.</li> </ul> </li> <li>Is there a real world counterpart?<ul> <li>If so, model it based on the real world.</li> <li>In the case of user and booking, we have real world counterpart so we model them as separate classes.</li> </ul> </li> <li>Is there potential changes to the entity?<ul> <li>If so, then creating a class is good.</li> <li>For instance, if in the future we plan to store more information about an airport (e.g., the country it is located, etc), then having it as a class will minimize potential changes to other parts of the code (e.g., if we used <code>String</code> before, we now have to change all these <code>String</code> into <code>Airport</code>).</li> </ul> </li> </ul> <p>The guide above are not exhaustive.  But they are still a good starting point if this is your first attempt at modelling in OOP.</p>"},{"location":"04-encapsulation.html#reference-types-in-java","title":"Reference Types in Java","text":"<p>We mentioned in Unit 2 that there are two kinds of types in Java.  You have been introduced to the primitive types.  Everything else in Java is a reference type.</p> <p>The <code>Circle</code> class is an example of a reference type.  Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value.  For instance,</p> <pre><code>Circle c1 = new Circle();\nCircle c2 = c1;\nSystem.out.println(c2.r); // print 0\nc1.r = 10.0;\nSystem.out.println(c2.r); // print 10.0\n</code></pre> <p>The behavior above is due to the variables <code>c1</code> and <code>c2</code> referencing to the same <code>Circle</code> object in the memory.  Therefore, changing the field <code>r</code> of <code>c1</code> causes the field <code>r</code> of <code>c2</code> to change as well.</p>"},{"location":"04-encapsulation.html#special-reference-value-null","title":"Special Reference Value: <code>null</code>","text":"<p>Any reference variable that is not initialized will have the special reference value <code>null</code> when executed on Java interpreter.  Note that when compiled, the Java compiler will produce an error when an uninitialized value is used.  A common error for beginners is to declare a reference variable and try to use it without instantiating an object:</p> <pre><code>Circle c1;\nc1.r = 10.0;  // error\n</code></pre> <p>Line 2 would lead to a compile-time error message</p> <pre><code>_.java:_: error: variable c1 might not have been initialized\n        c1.r = 10.0;  // error\n        ^\n1 error\n</code></pre> <p>If we try to run this in jshell, we will get a different error because jshell is a Java interpreter and will initialize all variables to the default values.  The default value of any reference type is <code>null</code>.  So the same code above will give us the following run-time error message.</p> <pre><code>|  Exception java.lang.NullPointerException\n</code></pre> <p>Remember to always instantiate a reference variable before using it.</p> <p>Class Diagram (Part 1)</p> <p>A useful diagram to have when trying to visualize a class is called the class diagram.  A class diagram consists of 3 segments:</p> <ol> <li>The class name.</li> <li>The fields.</li> <li>The methods.</li> </ol> <p>In between each segment we draw a line to clearly delimit each segment.  For best result, the order in which the fields and methods appear should be identical to how they appear in the code.</p> <p>Additionally, we omit the implementation of the method and record only the minimal information needed.  Otherwise, there is no difference between class diagram and code.  What we want is to have a diagram that captures the essence of a class so that we can reason about our design without actually writing the code.</p> <p>For instance, consider the class <code>Circle</code> v0.1 above (reproduced below).</p> Circle v0.1<pre><code>class Circle {\n  double x;\n  double y;\n  double r;\n\n  double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <p>The corresponding class diagram is shown below.</p> <p></p> <p>We will improve upon this class diagram with additional details while keeping the amount of information minimal to avoid information overload.</p> <p>We encourage you to practice drawing class diagram from code and writing code from class diagram.  This will be a useful design tools when dealing with larger programs, especially those involving multiple files.  It will take more time to debug your code so a good design will save time.</p> <p>Quote</p> <p>\"There has never been an unexpectedly short debugging period in the history of computers.\"</p> <p>Steven Levy</p>"},{"location":"04-encapsulation.html#further-readings","title":"Further Readings","text":"<ul> <li>Oracle's Java Tutorial on Classes and Objects.</li> <li>Class Diagram.  The version that we will introduce in CS2030/S is a simpler version that is sufficient for the purpose of this course.</li> </ul> <ol> <li> <p>Computer scientists just could not decide what to call this :(\u00a0\u21a9</p> </li> <li> <p>As a convention, we use PascalCase for class name and camelCase for variable and method names in Java.\u00a0\u21a9</p> </li> <li> <p>This is a standard analogy in an OOP textbook.  In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes.\u00a0\u21a9</p> </li> </ol>"},{"location":"05-infohiding.html","title":"Unit 5: Information Hiding","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the drawback of breaking the abstraction barrier.</li> <li>understand the concept of information hiding to enforce the abstraction barrier.</li> <li>understand how Java uses access modifiers to enforce information hiding.</li> <li>understand what is a constructor and how to write one in Java.</li> </ul>"},{"location":"05-infohiding.html#breaking-the-abstraction-barrier","title":"Breaking the Abstraction Barrier","text":"<p>In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type.  There may, however, be cases where a programmer intentionally or accidentally break the abstraction barrier.  </p> <p>Consider the case of <code>Circle</code> from before, where we modify the radius <code>r</code> directly with <code>c.r = 10</code>.  In doing so, we, as the client to <code>Circle</code>, make an explicit assumption of how <code>Circle</code> implements a circle.  The implementation details have been leaked outside the abstraction barrier.   Now, if the implementer wishes to change the representation of the <code>Circle</code>, to say, store the diameter, instead.</p> <p>Example</p> <p>Imagine that we -- as a client -- wrote the following code:</p> <pre><code>Circle c = new Circle();\nc.r = 10;\n</code></pre> <p>There is an implicit assumption here that the field <code>r</code> is meant to be radius.  In fact, only one of the implementation of <code>Circle</code> below can work with the code above.  In other words, if the implementer changes the implementation details, the client code above will no longer work.  The changes can be: (i) changing the name of the field (e.g., Implementation #2) or (ii) changing the meaning of the field (e.g., Implementation #3).</p> Implementation #1Implementation #2Implementation #3 <pre><code>class Circle {\n  double x;\n  double y;\n  double r; // r for radius\n\n  double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <pre><code>class Circle {\n  double x;\n  double y;\n  double d; // d for diameter\n\n  double getArea() {\n    return 3.141592653589793 * d * d / 4.0;\n  }\n}\n</code></pre> <pre><code>class Circle {\n  double x;\n  double y;\n  double r; // r but for radiameter? anyway, it's just a name so please use meaningful name!\n\n  double getArea() {\n    return 3.141592653589793 * r * r / 4;\n  }\n}\n</code></pre> <p>This small implementation change would invalidate the code that the client has written!  The line <code>c.r = 10;</code> will cause compilation error.  The client will have to carefully change all the code that makes the assumption, and modify accordingly, increasing the chances of introducing a bug.</p> <p>From the perspective of the implementer, we want to expose as few fields/methods as possible.  This can be achieved via data hiding.  From the client's perspective, you should only follow the behavior as stated in the actual specification such as Java API.  Whenever possible, do not rely too much on observable behavior or any changes to the implementation of the API will break your program.</p> Hyrum's Law <p>\"With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.\"</p> <p>As an anecdote, the story goes that Windows operating system skips Windows 9 and went straight from Windows 8.1 to Windows 9 because some developers perform the following compatibility check:</p> <pre><code>if (version.startsWith(\"Windows 9\") {\n  // Windows 95 and 98\n} else { /* .. */ }\n</code></pre>"},{"location":"05-infohiding.html#data-hiding","title":"Data Hiding","text":"<p>Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier.  Java, for instance, supports <code>private</code> and <code>public</code> access modifiers.  A field or a method that is declared as <code>private</code> cannot be accessed from outside the class, and can only be accessed within the class.  On the other hand, as you can guess, a <code>public</code> field or method can be accessed, modified, or invoked from outside the class.</p> <p>Such a mechanism to protect the abstraction barrier from being broken is called data hiding or information hiding.  This protection is enforced by the compiler at compile time.</p> <p>In our original <code>Circle</code> class (v0.1) in Unit 4, we did not specify any access modifier -- this amounts to using the default modifier, the meaning of which is not our concern right now<sup>1</sup>.  For a start, we will explicitly indicate <code>private</code> or <code>public</code> for all our methods and fields.  We will treat anything that is not declared as <code>private</code> to be <code>public</code>.</p> <p>Access Modifiers</p> Private FieldPublic Field <pre><code>// Circle v0.2\nclass Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <p>Testing <pre><code>Circle c = new Circle();\nc.r = 10; // error\n</code></pre></p> <pre><code>// Bad Circle\nclass Circle {\n  public double x;\n  public double y;\n  public double r;\n\n  public double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <p>Testing <pre><code>Circle c = new Circle();\nc.r = 10; // ok\n</code></pre></p> <p>As a good practice, we should start by marking all fields as <code>private</code>.  Only if we really need certain fields to be <code>public</code> will we mark them as such.</p> Circle v0.2<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <p>Now the fields <code>x</code>, <code>y</code>, and <code>r</code> are hidden behind the abstraction barrier of the class <code>Circle</code>.  Note that these fields are not accessible and modifiable outside of the class <code>Circle</code>, but they can be accessed and modified within <code>Circle</code> (inside the abstraction barrier), such as in the methods <code>getArea</code>.</p> <p>Within the Class or Within the Object?</p> <p>Note the wording that we used.  Fields and methods with <code>private</code> access modifier can only be accessed from within the class.  This means that we can access a field belonging to a different object as long as the other object has the same class!</p> <p>Why is this the case?  In abstraction barrier, the difference between implementer and client is about who is writing the class.  So the implementer write the code for <code>Circle</code> and she is responsible for the behavior of <code>Circle</code>, even when relating to other circles.  As such, the following code is allowed and does not break the abstraction barrier because the implementer only works with <code>Circle</code>, even if the circle is from a different object.</p> <pre><code>// Circle v0.2.5\nclass Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n\n  public boolean isLarger(Circle c) {\n    return this.r &gt; c.r;  // ok even if c.r is private because c is Circle and we are inside the Circle class!\n  }\n}\n</code></pre> Breaking Python's Abstraction Barrier <p>Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with <code>_</code> (one underscore) or <code>__</code> (two underscores).   This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later.</p> <p>So, as a quick summary, the two access modifiers are shown below.</p> Acessed from <code>private</code> <code>public</code> inside the class outside the class"},{"location":"05-infohiding.html#constructors","title":"Constructors","text":"<p>With data hiding, we completely isolate the internal representation of a class using an abstraction barrier.  But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class?  To get around this, it is common for a class to provide methods to initialize these internal fields.</p> <p>A method that initializes an object is called a constructor.</p> <p>A constructor method is a special method within the class.  It cannot be called directly but is invoked automatically when an object is instantiated (i.e., when the keyword <code>new</code> is used).  In Java, a constructor method has the same name as the class and has no return type.  A constructor can take in arguments just like other functions.  Let's add a constructor to our <code>Circle</code> class:</p> Circle v0.3<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  // Constructor\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre> <p>Let us see the constructor in more details.  Notice what we have in the constructor.  Besides the parameters and function body, We only have access modifiers and the function name.  Additionally, the function name is exactly the same as the class name (i.e., <code>Circle</code>).</p> <pre><code>// access modifiers   function name   parameters\n   public             Circle          (double x, double y, double r) {\n       : // omitted\n   }\n</code></pre> <p>As we have seen from Unit 4, the access modifiers can actually be omitted.  So minimally, the constructor can simply be the following:</p> <pre><code>// function name   parameters\n   Circle          (double x, double y, double r) {\n       : // omitted\n   }\n</code></pre> <p>Now, to create a <code>Circle</code> object, we need to pass in three arguments:</p> <pre><code>Circle c = new Circle(0.0, 0.5, 10.0);\n</code></pre> Constructor in Python and JavaScript <p>In Python, the constructor is the <code>__init__</code> method.   In JavaScript, the constructor is simply called <code>constructor</code>.</p> <p>What is Needed for a Constructor</p> <p>Minimally, the constructor needs to</p> <ul> <li>have the same name as the class</li> <li>not have any return type.</li> </ul> <p>So we can see that the access modifiers is not a requirement. We will learn in the second half of the semester the possibility of having a private constructor.</p>"},{"location":"05-infohiding.html#default-constructor","title":"Default Constructor","text":"<p>Our original <code>Circle v0.1</code> does not have constructor.  But as you will see below, the use of <code>new</code> keyword actually invokes a constructor.  So how does it work if there is no constructor written?  Java has a rule that adds default constructor if no constructor is given at all.</p> <p>Default Constructor</p> <p>If there is no constructor given, then a default constructor is added automatically.  The default constructor takes no parameter and has no code written for the body.  In the case of circle v0.1, the default constructor would be the following.</p> <pre><code>Circle() {\n}\n</code></pre> <p>Notice the condition \"if no constructor is given at all\".  Therefore, if there is at least one constructor written, then the default constructor will not be added automatically.</p>"},{"location":"05-infohiding.html#the-this-keyword","title":"The <code>this</code> Keyword","text":"<p>The code above also introduces the <code>this</code> keyword.  <code>this</code> is a reference variable that refers back to self, and is used to distinguish between two variables of the same name.  In the example above, <code>this.x = x</code> means we want to set the field <code>x</code> of this object to the parameter <code>x</code> passed into the constructor.</p> <p>Without the use of <code>this</code> keyword, our constructor looks like the following.</p> <pre><code>// Constructor\npublic Circle(double x, double y, double r) {\n  x = x;\n  y = y;\n  r = r;\n}\n</code></pre> <p>Think about that for a moment.  What is the expected behavior of <code>x = x</code>?  In this case, because <code>x</code> is a parameter, we are actually assigning the value of the parameter <code>x</code> back to the parameter <code>x</code>.  In other words, it is doing nothing!  The field has not been updated with the value of parameter <code>x</code>.</p> <p>Now that you have been introduced to <code>this</code>, we have also updated the method body of <code>getArea</code> and replaced <code>r</code> with <code>this.r</code>.  Although there is nothing syntactically incorrect about using <code>r</code>, sticking to the idiom of referring to members through the <code>this</code> reference makes the code easier to understand to readers.  We are making it explicit that we are referring to a field in the class, rather than a local variable or a parameter.</p>"},{"location":"05-infohiding.html#checking","title":"Checking","text":"<p>Violations to access modifiers are checked by the compiler.  In particular, trying to access, update, or invoke fields or methods with <code>private</code> modifier will give a compilation error.</p> <p>Example of Violation</p> <p>Class <code>C1</code> in a class <code>C1.java</code>.</p> <pre><code>class C1 {\n  private int x;\n\n  public C1(int x) {\n    this.x = x;\n  }\n}\n</code></pre> <p>Class <code>C2</code> in a class <code>C2.java</code>.</p> <pre><code>class C2 {\n  private int y;\n\n  public C2(int y) {\n    this.y = y;\n  }\n\n  public boolean isEqual(C1 c) {\n    return this.y == c.x;\n  }\n}\n</code></pre> <p>Try compiling them using <code>javac C1.java C2.java</code> and you will see the following error message.</p> <pre><code>C1.java:9: error: x has private access in C1\n        return this.y == c.x;\n                          ^\n</code></pre>"},{"location":"05-infohiding.html#when-is-constructor-called","title":"When is Constructor Called?","text":"<p>You may be wondering why there is no return type or why there is not even a <code>return</code> statement on constructor.  If a constructor does not return anything, how can we even assign <code>new Circle(..)</code> into a variable <code>Circle c</code> in the code snippet above?  The answer lies in the keyword <code>new</code>.  This keyword does the heavy-lifting.  We can explain the behavior of a constructor in 3 steps:</p> <ol> <li>Allocate sufficient memory location to store all the fields of the class and assign this reference to the keyword <code>this</code>.</li> <li>Invoke the constructor function and passing the keyword <code>this</code> implicitly.</li> <li>Once the constructor is done, return the reference pointed to by <code>this</code> back.</li> </ol> <p>Firstly, this is why constructor does not have a <code>return</code> statement or the return type.  It does not even use the keyword <code>void</code>.  Secondly, this is why <code>new Circle(..)</code> can be assigned to <code>Circle c</code> because the <code>new</code> keyword returns the reference to the newly created object in step 3.</p> <p>Class Diagram (Part 2)</p> <p>Now that we have access modifiers, we can add a visualisation for these access modifiers in our class diagram.</p> Modifier Symbol <code>private</code> <code>-</code> <code>public</code> <code>+</code> <p>And so the class <code>Circle</code> (reproduced below)</p> <pre><code>// Circle v0.3\nclass Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  // Constructor\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre> <p>has the following class diagram.</p> <p></p> <p>Here we can also see that the constructor is represented as a method <code>+Circle(double x, double y, double r)</code>.  Note how this method does not have return type.  Assuming some common sense, we can guess that the code for the constructor is likely to simply be 3 assignments where the parameters are assigned to the fields with the same name.</p> <p>Additionally, we can see that the fields <code>x</code>, <code>y</code>, and <code>r</code> are all <code>private</code>.  Coupled with the only public method <code>+double getArea()</code> and assuming common sense that the method <code>getArea</code> does not change any of the fields, we can also guess that properties of a circle cannot be modified once it is created.</p> <p>Of course our guesses might be wrong.  But we can already see the usefulness of class diagram in narrowing down some possibilities.  In fact, if you are the implementer of the class <code>Circle</code>, the class diagram can guide you on what your code would look like without actually coding.</p> <ol> <li> <p>The other access modifier is <code>protected</code>.  Again, we do not want to worry about this modifier for now.\u00a0\u21a9</p> </li> </ol>"},{"location":"06-tell-dont-ask.html","title":"Unit 6: Tell, Don't Ask","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand what accessor and mutator are used for, and why not to use them.</li> <li>understand the principle of \"Tell, Don't Ask\".</li> </ul>"},{"location":"06-tell-dont-ask.html#accessors-and-mutators","title":"Accessors and Mutators","text":"<p>Similar to providing constructors, a class should also provide methods to retrieve or modify the properties of the object.</p> <ul> <li>Accessors: Methods that retrieve the properties of an object (i.e., retrieve the value of a field).  Also known as getter.</li> <li>Mutators: Methods that modify the properties of an object (i.e., update the value of a field).  Also known as setter.</li> </ul> <p>The use of both accessor and mutator methods is a bit controversial.   Suppose that we provide an accessor method and a mutator method for every private field, then we are exposing the internal representation, therefore breaking the encapsulation.  For instance:</p> Circle v0.4<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public double getX() {\n    return this.x;\n  }\n\n  public void setX(double x) {\n    this.x = x;\n  }\n\n  public double getY() {\n    return this.y;\n  }\n\n  public void setY(double y) {\n    this.y = y;\n  }\n\n  public double getR() {\n    return this.r;\n  }\n\n  public void setR(double r) {\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre> <p>In the code above, we can categorise the accessor and mutator of each field as follows.</p> Fields Accessors Mutators <code>x</code> <code>getX</code> <code>setX</code> <code>y</code> <code>getY</code> <code>setY</code> <code>r</code> <code>getR</code> <code>setR</code> <p>Do note that the name <code>getProp</code> or <code>setProp</code> for a field <code>prop</code> is optional.  But it is a good practice.  For instance, we may actually name the accessor for <code>r</code> as <code>getRadius</code> and the mutator as <code>setRadius</code> shown below.</p> <pre><code>  public double getRadius() {       // originally getR\n    return this.r;\n  }\n\n  public void setRadius(double r) { // originally setR\n    this.r = r;\n  }\n</code></pre> <p>Why Provide Both Accessor and Mutator Instead of <code>public</code>?</p> <p>As we have said above, having both accessor and mutator for a private field is controversial.  But it is still better than setting the field itself public.  By having accessor and mutator, we are still adding some layer of abstraction because we can change the name of the field without affecting the client.</p> <p>Another advantage is that we may be able to perform some checks on the mutator and prevents certain invalid values from ever being assigned to the field.  Consider the method <code>setR</code> in our <code>Circle v0.4</code> above.  A slightly better approach is to implement it with a check to prevent setting the radius to a non-positive value.</p> <pre><code>public void setR(double r) {\n  if (r &gt; 0) {\n    this.r = r;\n  } else {\n    // handle error\n  }\n}\n</code></pre> <p>Regardless, we should think carefully if an accessor or a mutator is really needed for a field.</p>"},{"location":"06-tell-dont-ask.html#the-tell-dont-ask-principle","title":"The \"Tell, Don't Ask\" Principle","text":"<p>The mutators and accessors above are pretty pointless.  If we need to know the internal and do something with it, then we are breaking the abstraction barrier.  However, this is still slightly better than accessing the field directly.  Using accessors and mutators at least allow the implementer to change the name of the fields.  Unfortunately, the implementer cannot change the name of the accessors or mutators.</p> <p>Possible Change #1</p> <pre><code>class Circle {\n  private double x;\n  private double y;\n  private double radius;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.radius = r;\n  }\n\n  // no change to getX, setX, getY, and setY\n\n  public double getR() {\n    return this.radius;\n  }\n\n  public void setR(double r) {\n    this.radius = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre> <p>So in a way, the changes are more localized.  Here, the localization is only within the class <code>Circle</code>.  The client of <code>Circle</code> need not change their code.  However, this is still not the best approach.  The better approach is to implement a method within the class that does whatever we want the class to do.</p> <p>For instance, suppose that we want to check if a given point (x,y) falls within the circle, one approach would be:</p> <pre><code>double cX = c.getX();\ndouble cY = c.getY();\ndouble r = c.getR();\nboolean isInCircle = ((x - cX) * (x - cX) + (y - cY) * (y - cY)) &lt;= r * r;\n</code></pre> <p>where <code>c</code> is a <code>Circle</code> object.</p> <p>A better approach would be to add a new <code>boolean</code> method in the <code>Circle</code> class, and call it instead:</p> <pre><code>boolean isInCircle = c.contains(x, y);\n</code></pre> <p>This better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact.  If one fine day, the implementer of <code>Circle</code> decided to change the representation of the circle and remove the direct accessors to the fields, then only the implementer needs to change the implementation of <code>contains</code>.  The client does not have to change anything.</p> <p>Possible Change #2</p> <pre><code>class Circle {\n  private double t; // store the top-left corner of\n  private double l; // the bounding square instead\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.t = y + r; // compute the top bound\n    this.l = x - r; // compute the left bound\n    this.r = r;\n  }\n\n  // no more accessors/mutators\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n\n  public boolean contains(double x, double y) {\n      : // implementation omitted but changed!\n  }\n}\n</code></pre> <p>The principle around which we can think about this is the \"Tell, Don't Ask\" principle.  The client should tell a <code>Circle</code> object what to do (compute the circumference), instead of asking \"What is your radius?\" to get the value of a field then perform the computation on the object's behalf.</p> <p>Note that in both possible changes above, the client are unaffected.  Further note that in the second possible change -- assuming the client does not use any accessors or mutators -- the code written by the client has more resistance to changes.  We not only change the name of the field but also the method implementation by redefining what it means to be contained.  The client may not even realized that internally, the implementation of <code>Circle</code> has been modified!</p> <p>While there are situations where we cannot avoid using an accessor or a mutator in a class, for beginner OO programmers like yourself, it is better to not define classes with any accessor and modifier to the private fields and force yourselves to think in the OO way \u2014 to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer.</p> <p>Tips and Tricks</p> <p>The first tips is related to information hiding.  Although there are cases where we really have to make certain fields <code>public</code>, we would like to -- as much as possible -- first set all the fields as <code>private</code>.  Afterwards, we will need to think about the methods that are necessary for the class.  This is where the next tips will be useful.</p> <p>While there are situations where we can't avoid using accessor or modifier in a class, for beginner OO programmers like yourself, it is better to not define classes with any accessor and modifier to the private fields, and forces yourselves to think in the OO way -- to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer.</p> <p>One way to think about this is to try to think about the responsibility of the class.  Recap that the class names are typically noun.  So think about the actual object and imagine what is their responsibility.</p> <p>Take for instance a class called <code>Ball</code> and a class called <code>Player</code> (i.e., soccer player).  We can imagine that the player can kick a ball.  This is captured by the method <code>void kick(Ball b, double speed)</code> in the class <code>Player</code>.  However, it is the responsibility of the <code>Ball</code> to keep track of its own position.  This might be done by the method <code>void move(double speed)</code>.</p> <p>More closely related to the circle example, we may look at some alternative choices.  Say, for instance, we want to compute the square of the distance from the center point of the circle to any other (x, y) coordinates.  We may implement the following method</p> <pre><code>public double distanceSquared(double x, double y) {\n  double dx = this.x - x;\n  double dy = this.y - y;\n  return dx * dx + dy * dy;\n}\n</code></pre> <p>Given this method, we may not even need to provide the method <code>contains</code>.  Instead, we may choose to provide both <code>distanceSquared</code> and <code>getRadius</code>.  The latter is needed because we can check if a point (x, y) is contained within a circle if the square of the distance to the center point is less than or equal to the square of the radius.</p> <p>So which design to choose?  Typically we want to minimize the number of accessors and mutators that we have.  So the design using <code>contains</code> is preferred.  If you cannot come up with such design then having both <code>distanceSquared</code> and <code>getRadius</code> is still preferable to having accessors for all three fields.</p>"},{"location":"06-tell-dont-ask.html#further-reading","title":"Further Reading","text":"<ul> <li>Tell Don't Ask by Martin Fowler</li> <li>Why getters and setters are evil, by Allen Holub, JavaWorld</li> <li>Getters and setters are evil. Period, by Yegor Bygayenko.</li> </ul>"},{"location":"07-static-field.html","title":"Unit 7: Class Fields","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the difference between instance fields and class fields.</li> <li>understand the meaning of keywords <code>final</code> and <code>static</code> in the context of a field.</li> <li>be able to define and use a class field.</li> <li>be able to use <code>import</code> to access classes from the Java standard libraries.</li> </ul>"},{"location":"07-static-field.html#static-fields","title":"Static Fields","text":"<p>Let's revisit the implementation of <code>Circle</code> and add a method to compute the circumference of the circle.</p> Circle v0.3<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n\n  public double circumference() {\n    return 3.141592653589793 * this.r * 2;\n  }\n}\n</code></pre> <p>In the code above, we use the constant \\(\\pi\\) but hardcoded it as 3.141592653589793.  Hardcoding such a magic number is a no-no in terms of coding style.  This constant appears in at least two places.  If we hardcode such a number and want to change its precision later, we would need to track down and change every occurrence.  Every time we need to use \\(\\pi\\), we have to remember or look up what is the precision that we use.  Not only does this practice introduce more work, it is also likely to introduce bugs.  </p> <p>In C, we define \\(\\pi\\) as a macro constant <code>M_PI</code>.  But how should we do this in Java?  This is where the ideal that a program consists of only objects with internal states that communicate with each other can feel a bit constraining.  The constant \\(\\pi\\) is universal and does not really belong to any instance of circle (i.e., the value of \\(\\pi\\) is the same for every circle!).</p> <p>Another example is the method <code>sqrt()</code> that computes the square root of a given number.  <code>sqrt</code> is a general function that is not associated with any object as well.</p> <p>A solution to this is to associate these global values and functions with a class instead of with an object.  For instance. Java predefines a <code>java.lang.Math</code> class<sup>1</sup> that is populated with constants <code>PI</code> and <code>E</code> (i.e., Euler's number \\(e\\)), along with a long list of mathematical functions.  To associate a method or a field with a class in Java, we declare them with the <code>static</code> keyword.  We can additionally add a keyword <code>final</code> to indicate that the value of the field will not change and <code>public</code> to indicate that the field is accessible from outside the class.  In short, the combination of <code>public static final</code> modifiers is used for constant values in Java.</p> <pre><code>class Math {\n    :\n  public static final double PI = 3.141592653589793;\n    :\n}\n</code></pre> <p>We call these <code>static</code> fields that are associated with a class as class fields and fields that are associated with an object as instance fields.  Note that, a <code>static</code> class field needs not be <code>final</code> and it needs not be <code>public</code>.  Class fields are useful for storing pre-computed values or configuration parameters associated with a class rather than individual objects.</p> <p>Because it is associated with the class rather than instance, we can think about <code>static</code> fields as having exactly one instance during the entire execution of the program.  So there is only exactly one instance of <code>PI</code> above regardless of how many instances of <code>Math</code> we have created.  In fact, we need not create any instance of <code>Math</code> at all to be able to use <code>PI</code>.</p>"},{"location":"07-static-field.html#accessing-class-fields","title":"Accessing Class Fields","text":"<p>A class field behaves just like a global variable and can be accessed in the code, anywhere the class can be accessed.  Since a class field is associated with a class rather than an object, we access it through its  class name.  To use the static class field <code>PI</code>, for instance, we have to say <code>java.lang.Math.PI</code>.</p> <pre><code>public double getArea() {\n  return java.lang.Math.PI * this.r * this.r;\n}\n</code></pre> <p>A more common way, however, is to use <code>import</code> statements at the top of the program.  If we have this line:</p> <pre><code>import java.lang.Math;\n</code></pre> <p>Then, we can save some typing and write:</p> <pre><code>public double getArea() {\n  return Math.PI * this.r * this.r;\n}\n</code></pre> <p>So the expression <code>Math.PI</code> refers to the class field called <code>PI</code> from the class called <code>Math</code><sup>2</sup>.  Knowing that <code>Math</code> is a class and we use the field name directly from the class name indicates that we do not need to instantiate <code>Math</code>.</p> <p>Class Fields and Methods in Python</p> <p>Note that, in Python, any variable declared within a <code>class</code> block is a class field:</p> <pre><code>class Circle:\n  x = 0\n  y = 0\n</code></pre> <p>In the above example, <code>x</code> and <code>y</code> are class fields, not instance fields.</p>"},{"location":"07-static-field.html#example-the-circle-class","title":"Example: The Circle class","text":"<p>Now, let revise our <code>Circle</code> class to improve the code and make it a little more complete.  We now add in comments for each method and variable as well, as we always should.</p> Circle v0.4<pre><code>import java.lang.Math;\n\n/**\n * A Circle object encapsulates a circle on a 2D plane.  \n */\nclass Circle {\n  private double x;  // x-coordinate of the center\n  private double y;  // y-coordinate of the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on (x, y) with given radius\n   */\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return the circumference of the circle.\n   */\n  public double circumference() {\n    return Math.PI * this.r * 2;\n  }\n\n  /**\n   * Return true if the given point (x, y) is within the circle.\n   */\n  public boolean contains(double x, double y) {\n    return false; \n    // TODO: Left as an exercise\n  }\n}\n</code></pre> <p>For simplicity, we will omit the method <code>circumference</code> in the future.</p> <ol> <li> <p>The class <code>Math</code> is provided by the package <code>java.lang</code> in Java.  A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet).  To use this class, we may add the line <code>import java.lang.Math</code> at the beginning of our program.  But <code>java.lang.Math</code> is special because it contains the implementation of classes that are fundamental to the Java programming language.  So, it is actually imported automatically the Java compiler on every program!\u00a0\u21a9</p> </li> <li> <p>Of course this relies on the fact that we have no variable called <code>Math</code>.  But if you are following the practice of CS2030/S, then if a name begins with uppercase, it should be a class name.  Variable name should begin with lowercase.\u00a0\u21a9</p> </li> </ol>"},{"location":"08-static-method.html","title":"Unit 8: Class Methods","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the differences between instance methods and class methods.</li> <li>be able to define and use a class method.</li> <li>know that the <code>main</code> method is the entry point to a Java program.</li> <li>the modifies and parameters required for a <code>main</code> method.</li> </ul>"},{"location":"08-static-method.html#static-methods","title":"Static Methods","text":"<p>Let's suppose that, in our program, we wish to assign a unique integer identifier to every <code>Circle</code> object ever created.  Without using class fields, we might attempt the following.</p> <pre><code>class Circle {\n  private double x;  // x-coordinate of the center\n  private double y;  // y-coordinate of the center\n  private double r;  // the length of the radius\n  private final int id; // identifier\n\n  public Circle(double x, double y, double r, int id) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n    this.id = id;\n  }\n\n    : // code omitted\n}\n</code></pre> <p>Then, on every instantiation of circle, we will have to explicitly supply the latest value for <code>id</code>.</p> <pre><code>Circle c = new Circle(x, y, lastId);\n</code></pre> <p>Of course this can be tedious and prone to error especially if we may instantiate <code>Circle</code> in multiple places.  Then we will have to ensure that the latest value of <code>id</code> is communicated on these places correctly.</p> <p>As an improvement, we may actually just let the value of the latest <code>id</code> be stored in the class <code>Circle</code> itself as a class field.</p> <pre><code>class Circle {\n  private double x;  // x-coordinate of the center\n  private double y;  // y-coordinate of the center\n  private double r;  // the length of the radius\n  private final int id; // identifier\n  public static int lastId = 0; // the id of the latest circle instance\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n    this.id = id;\n  }\n\n    : // code omitted\n}\n</code></pre> <p>Then, each time we instantiate a circle, we have to: (i) retrieve the value of <code>lastId</code> and (ii) update the value of <code>lastId</code>.</p> <pre><code>Circle c = new Circle(x, y, Circle.lastId);\nCircle.lastId++;\n</code></pre> <p>While better, this is still prone to error as it relies on the fact that the client should not forget to use and update.  Furthermore, it requires the client to update it correctly and not just set the value of <code>lastId</code> to some random value.  But this can be done better if this is the responsibility of the implementer instead.  This can be done with the use of class method.</p> Circle v0.4.1<pre><code>class Circle {\n  private double x;  // x-coordinate of the center\n  private double y;  // y-coordinate of the center\n  private double r;  // the length of the radius\n  private final int id; // identifier\n  private static int lastId = 0; // the id of the latest circle instance\n\n  /**\n   * Create a circle centered on (x, y) with a given radius\n   */\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n    this.id = Circle.lastId;\n    Circle.lastId += 1;\n  }\n\n  /**\n   * Return how many circles have ever existed.\n   */\n  public static int getNumOfCircles() {\n    return Circle.lastId;\n  }\n\n    :\n}\n</code></pre> <ul> <li>On Line 5, we added a new instance field <code>id</code> to store the identifier of the circle.  Note that, since the identifier of a circle should not change once it is created, we use the keyword <code>final</code> here.</li> <li>On Line 6, we added a new class field <code>lastId</code> to remember that the <code>lastId</code> of the latest circle instance.  This field is maintained as part of the class <code>Circle</code> and is initialized to 0.  Now this class field is <code>private</code> instead of <code>public</code> because it is only accessed and updated within the constructor.</li> <li>On Line 15 and 16, as part of the constructor, we initialize <code>id</code> to <code>lastId</code> and increment <code>lastId</code>.   We explicitly access <code>lastId</code> through <code>Circle</code> to make it clear that <code>lastId</code> is a class field.</li> </ul> <p>Note that all of the above are done privately beneath the abstraction barrier.  In other words, the class field that we have added is actually set to <code>private</code>.  Additionally, now it does not matter what the client does, the value of <code>lastId</code> will correctly reflect the number of circle that has been created.  The client need not even know about the existence of this class field.</p> <p>Since <code>lastId</code> is incremented by one every time a circle is created, we can also interpret <code>lastId</code> as the number of circles created so far.  On Line 22-24, we added a method <code>getNumOfCircles</code> to return its value.</p> <p>The interesting thing here is that we declare <code>getNumOfCircles</code> with a <code>static</code> keyword.  Similar to a <code>static</code> field, a <code>static</code> method is associated with a class, not to an instance of the class.  Such method is called a class method.  A class method is always invoked without being attached to an instance, and so it cannot access its instance fields or call other of its instance methods.  The reference <code>this</code> has no meaning within a class method.  Furthermore, just like a class field, a class method should be accessed through the class.  For example, <code>Circle.getNumOfCircles()</code>.</p> <p>Other examples of class methods include the methods provided in <code>java.lang.Math</code>: <code>sqrt</code>, <code>min</code>, etc.  These methods can be invoked through the <code>Math</code> class: e.g., <code>Math.sqrt(x)</code>.</p>"},{"location":"08-static-method.html#non-static-from-static","title":"Non-Static from Static","text":"<p>Recap that for static fields (i.e., class fields), we only have exactly one instance of it throughout the lifetime of the program.  More generally, a field or method with modifier <code>static</code> belongs to the class rather than the specific instance.  In other words, they can be accessed/updated (for fields, assuming proper access modifier) or invoked (for methods, assuming proper access modifier) without even instantiating the class.</p> <p>Think for a moment about the consequence of this.  If we have not instantiate the class, it means that there is no instance.  The keyword <code>this</code> captures the current instance.  If there is no instance, the keyword <code>this</code> cannot be referring to any instance.  Therefore, it is not reasonable to assign a specific value to <code>this</code> keyword.</p> <p>Since we have no reasonable value for <code>this</code> within the context of <code>static</code> method, Java actually prevents the use of <code>this</code> from any method with <code>static</code> modifier.</p> <pre><code>  public static int getLastId() {\n    return this.id;  // what is \"this\" if no Circle has been created?  what if there are 100 circles?\n  }\n</code></pre> <p>Try it out, you will get the following error.</p> <pre><code>_.java:_: error: non-static variable this cannot be referenced from a static context\n    return this.id;\n               ^\n</code></pre> <p>The opposite is not true.  We can access class fields from non-static methods.</p>"},{"location":"08-static-method.html#the-main-method","title":"The <code>main</code> method","text":"<p>The most common class method you will use is probably the <code>main</code> method.</p> <p>Every Java program has a class method called <code>main</code>, which serves as the entry point to the program.  To run a Java program, we need to tell the JVM the class whose <code>main</code> method should be invoked first.  In the example that we have seen, <pre><code>java Hello\n</code></pre></p> <p>will invoke the <code>main</code> method defined within the class <code>Hello</code> to kick start the execution of the program.</p> <p>The <code>main</code> method can be defined in the following way: <pre><code>public static final void main(String[] args) {\n}\n</code></pre></p> <p>You have learned what <code>public</code> and <code>static</code> means.  The return type <code>void</code> indicates that <code>main</code> must not return a value.  We have discussed what <code>final</code> means on a field, but are not ready to explain what <code>final</code> means on a method yet.  In fact, this is an optional modifier for the <code>main</code> method.</p> <p>The <code>main</code> method takes in an array (<code>[]</code>) of strings as parameters.  These are the command-line arguments that we can pass in when invoking <code>java</code>.  <code>String</code> (or <code>java.lang.String</code>) is another class provided by the Java library that encapsulates a sequence of characters.</p> <p>What is Needed for the Main Method</p> <p>Minimally, the main method should</p> <ul> <li>have the <code>public</code> access modifier</li> <li>be a class method with <code>static</code> modifier</li> <li>not return anything (i.e., the return type is <code>void</code>)</li> <li>be named <code>main</code></li> <li>takes only an array of <code>String</code> (i.e., <code>String[]</code>) as its parameter.</li> </ul> <p>From here, we can see that the <code>final</code> keyword is not necessary.  Additionally, the order of the modifiers can be different although for good practice, you should follow our Coding Style.  Finally, the name of the parameter can be different but we usually use <code>args</code> for simplicity.</p> <p>Class Diagram (Part 3)</p> <p>Static fields and/or methods are represented by underline in class diagram.  The current version of <code>Circle</code> has the following class diagram.</p> <p></p> <p>If the number of constructs for class diagram is getting too much, do not worry, we will have a unit added to the Java Guide specifically to revise class diagram with application on designing solutions to problems.</p>"},{"location":"09-composition.html","title":"Unit 9: Composition","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>how to compose a new class from existing classes using composition.</li> <li>how composition models the HAS-A relationship.</li> <li>how sharing reference values in composed objects could lead to surprising results.</li> </ul>"},{"location":"09-composition.html#adding-more-abstractions","title":"Adding more Abstractions","text":"<p>Our previous implementation of <code>Circle</code> stores the center using its Cartesian coordinate \\((x,y)\\).  We have a method <code>contains</code> that takes in the Cartesian coordinate of a point.  As such, our implementation of <code>Circle</code> assumes that a 2D point is best represented using its Cartesian coordinate.  </p> <p>Recall that we wish to hide the implementation details as much as possible, protecting them with an abstraction barrier, so that the client does not have to bother about the details and it is easy for the implementer to change the details.  In this example, what happens if the application finds that it is more convenient to use polar coordinates to represent a 2D point?  We will have to change the code of the constructor to <code>Circle</code> and the method <code>contains</code>.  If our code contains other shapes or other methods in <code>Circle</code> that similarly assume a point is represented with its Cartesian coordinate, we will have to change them as well.  It is easy for bugs to creep in.  For instance, we might pass in the polar coordinate \\((r, \\theta)\\) to a method, but the method treats the two parameters as the Cartesian \\((x,y)\\).  After all, both \\((r, \\theta)\\) and \\((x, y)\\) can be abstracted as a pair of <code>double</code> (i.e., (<code>double</code>, <code>double</code>)).</p> <p>We can apply the principle of abstraction and encapsulation here, and create a new class <code>Point</code>.  The details of which are omitted and left as an exercise.  Instead, try to practice converting class diagram into a code.</p> <p></p> <p>With the <code>Point</code> class, our <code>Circle</code> class looks like the following:</p> Circle v0.5<pre><code>import java.lang.Math;\n\n/**\n * A Circle object encapsulates a circle on a 2D plane.  \n */\nclass Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    // TODO: Left as an exercise\n    return false;\n  }\n}\n</code></pre> <p>This example also illustrates the concept of composition.  Our class <code>Circle</code> has been upgraded from being a bundle of primitive types and its methods, to a bundle that includes a reference type <code>Point</code> as well.  In OOP, composition is a basic technique to build up layers of abstractions and construct sophisticated classes.</p> <p>We have mentioned that classes model real-world entities in OOP.  The composition models that HAS-A relationship between two entities.  For instance, a circle has a point as the center.</p> <p>Cylinder</p> <p>Now let's build up another layer of abstraction and construct a 3D object -- a cylinder.  A cylinder has a circle as its base and has a height value.  Using composition, we can construct a <code>Cylinder</code> class:</p> <pre><code>class Cylinder {\n  private Circle base;\n  private double height;\n\n  public Cylinder(Circle base, double height) {\n    this.base = base;\n    this.height = height;\n  }\n    : // other methods omitted\n}\n</code></pre> <p>This process of composition can be extended further.  For instance, if we think of a tire as a cylinder, then we can construct a class called <code>Car</code> as consisting of 4 cylinders corresponding to each tire.</p> <pre><code>class Car {\n  private Cylinder tire1;\n  private Cylinder tire2;\n  private Cylinder tire3;\n  private Cylinder tire4;\n    : // other parts omitted\n}\n</code></pre> <p>This way, we can create more and more complicated models!</p>"},{"location":"09-composition.html#sharing-references-aka-aliasing","title":"Sharing References (aka Aliasing)","text":"<p>Recall that unlike primitive types, reference types may share the same reference values.  This is called aliasing.  Let's look at the subtleties of how this could affect our code and catch us by surprise.</p> <p>Consider the following, where we create two circles <code>c1</code> and <code>c2</code> centered at the origin (0, 0).</p> <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\n</code></pre> <p>Let's say that we want to allow a Circle to move its center.  For the sake of this example, let's assume that the method <code>moveTo</code> is a mutator on the class <code>Point</code> that mutates both field <code>x</code> and <code>y</code>.  Suppose we want to move <code>c1</code> and only <code>c1</code> to be centered at (1, 1).  In particular, we do not want to move <code>c2</code> at all.</p> <pre><code>p.moveTo(1, 1);\n</code></pre> <p>You will find that by moving <code>p</code>, we are actually moving the center of both <code>c1</code> and <code>c2</code>!  This result is due to both circles <code>c1</code> and <code>c2</code> sharing the same point.  When we pass the center into the constructor, we are passing the reference instead of passing a cloned copy of the center.  </p> <p>This is a common source of bugs and we will see how we can reduce the possibilities of such bugs later in this module, but let's first consider the following \"fix\" (that is still not ideal).</p> <p>Let's suppose that instead of moving <code>p</code>, we add a <code>moveTo</code> method to the <code>Circle</code> instead.  In other words, assume that there is no <code>moveTo</code> method in <code>Point</code> but there is a <code>moveTo</code> method in <code>Circle</code>.</p> <pre><code>class Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n    :\n\n  /**\n   * move the center of this circle to the given point\n   */\n  void moveTo(Point c) {\n    this.c = c;\n  }\n\n   :\n}\n</code></pre> <p>Now, to move <code>c1</code>,</p> <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\nc1.moveTo(new Point(1, 1));\n</code></pre> <p>You will find that <code>c1</code> will now have a new center, but <code>c2</code>'s center remains at (0, 0).  Why doesn't this solve our problem then?  There is no way we can mutate <code>p</code> because invoking <code>p.moveTo(1, 1)</code> will no longer work.  We have removed the method <code>moveTo</code> on class <code>Circle</code>.  Unfortunately, recall that we can further composed circles into other objects.  Let's say that we have two cylinders: <pre><code>Cylinder cylinder1 = new Cylinder(c1, 1);\nCylinder cylinder2 = new Cylinder(c1, 1);\n</code></pre></p> <p>that share the same base, then the same problem repeats itself!  One solution is to avoid sharing references as much as possible.  For instance,</p> <pre><code>Point p1 = new Point(0, 0);\nCircle c1 = new Circle(p1, 1);\n\nPoint p2 = new Point(0, 0);\nCircle c2 = new Circle(p2, 4);\n\np1.moveTo(1, 1);\n</code></pre> <p>Without sharing references, moving <code>p1</code> only affects <code>c1</code>, so we are safe.   </p> <p>The drawback of not sharing objects with the same content is that we will have a proliferation of objects and the computational resource usage is not optimized.  This is an example of the trade offs we mentioned in the introduction to this module: we are sacrificing the computational cost to save programmers from potential suffering!</p> <p>Another approach to address this issue is immutability.  We will cover this later in the module.</p>"},{"location":"10-heap-stack.html","title":"Unit 10: Heap and Stack","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand when memory are allocated/deallocated from the heap vs. from the stack.</li> <li>understand the concept of call stack in JVM.</li> </ul>"},{"location":"10-heap-stack.html#heap-and-stack","title":"Heap and Stack","text":"<p>The Java Virtual Machine (JVM) manages the memory of Java programs while its bytecode instructions are interpreted and executed.  Different JVM implementations may implement these differently, but typically a JVM implementation partitions the memory into several regions, including:</p> <ul> <li>method area for storing the code for the methods;</li> <li>metaspace for storing meta information about classes;</li> <li>heap for storing dynamically allocated objects;</li> <li>stack for local variables and call frames.</li> </ul> <p>Since the concepts of heap and stack are common to all execution environments (either based on bytecode or machine code), we will focus on them here.</p> <p>The heap is the region in memory where all objects are allocated in and stored, while the stack is the region where all variables (including primitive types and object references) are allocated in and stored.</p>"},{"location":"10-heap-stack.html#stack","title":"Stack","text":"<p>The stack contains variables.  Please note that instance and class fields are not variables.  As such, fields are not in the stack.</p> <p>Also recap that the same variable names can exist in the program as long as they are in different methods.  This means that the variables are contained within the call frames.  Call frames are created when we invoke a method and removed when the method finished.</p> <p>Like a \"stack of books\" where we can only take the book at the top and can only put more books at the top, the call frames in the stack can only be added or removed from the top.  This behavior is also called Last-In First-Out (LIFO).  In other words, the last element that is inserted (i.e., Last-In) is the first element to be removed (i.e., First-Out).</p> <p></p>"},{"location":"10-heap-stack.html#heap","title":"Heap","text":"<p>The heap stored dynamically allocated objects.  To put it simply, whenever you use the keyword <code>new</code>, a new object is created in the heap.</p> <p>Unlike stack, there is no concept of LIFO.  So, an object can persists across multiple method invocation.  This also means that an object can be shared between multiple method invocation.</p> <p>An object in the heap contains the following information:</p> <ul> <li>Class name.</li> <li>Instance fields and the respective values.</li> <li>Captured variables (more on this in later units).</li> </ul> <p></p>"},{"location":"10-heap-stack.html#examples","title":"Examples","text":""},{"location":"10-heap-stack.html#constructor","title":"Constructor","text":"<p>Considers the following two lines of code.</p> <pre><code>Point p;\np = new Point(1, 2);\n</code></pre> <p>Line 1 declares a variable <code>p</code>.  When the JVM executes this line of code, it allocates some memory space for an object reference for <code>p</code>, the content is currently uninitialized.  We show uninitialized variables with the content having the symbol \u2205.  Since <code>p</code> is a variable, it resides in the stack.</p> <p>Line 2 creates a new <code>Point</code> object.  When the JVM executes this line of code, it (i) allocates some memory space for a <code>Point</code> object on the heap, (ii) invokes the constructor, and (iii) returns the reference to the newly allocated memory space back.  The returned memory address of this memory space becomes the reference of the object and is assigned to the variable <code>p</code>.</p> <p>This is shown in the figures below in three steps.  Note that we assume that the code snippet above is in the static method called <code>main</code>.  Although technically there should be a parameter in the call frame of <code>main</code> usually called <code>args</code> due to the typical main method <code>public static void main(String[] args)</code>, we will often omit this because the name and values are unknown.</p> <p>Notice the crucial difference between the static method <code>main</code> and the constructor.  Static method does not have the keyword <code>this</code>.  On the other hand, non-static methods including constructor has the keyword <code>this</code>.</p> <p>Although we mentioned that <code>this</code> is a keyword, it behaves mostly like a variable<sup>1</sup>.  As such, we have its representation in the stack.  Further note that the parameters are ordered with the leftmost parameter appears at the bottom of the call frame after the keyword <code>this</code> (if any).</p> After Line 1Allocate MemoryInvoke ConstructorEnd of ConstructorReturn from Constructor <p></p> <p></p> <p></p> <p></p> <p></p> <p>Note that we use the symbol \u2205 to indicate that the variable is not yet initialized.  Java differentiate between uninitialized variables and variables initialized to <code>null</code>.  Uninitialized variables cannot be used.  Further note that uninitialized fields have default values but not uninitialized variables.</p> <p>Also, we will often simplify the presentation.  First, we will omit the memory address (e.g., 9048ab50).  The arrow from the variable <code>p</code> containing the value 9048ab50 to an object located at 9048ab50 is already an abstraction of this.  Furthermore, we do not know where the actual address will be and it will be different on different run.  So, we can omit both memory addresses stored in the variable and of the object.</p> <p>Secondly, we are often interested only in the snapshot of the stack and heap diagram at a particular moment.  As such, the intermediate call frames (e.g., Point constructor) that are inserted and then removed can be omitted.  Only the final effect matters.</p> <p>Let us illustrate this further with the following code snippet.</p> <pre><code>Circle c;\nc = new Circle(new Point(1, 2), 3);\n</code></pre> <p>In this case, the <code>new Point(1, 2)</code> is evaluated first to create an object in the heap.  Then, we evaluate <code>new Circle(.., 3)</code>.  The reference to this object is then assigned to the variable <code>c</code>.  The final effect is shown below.  Note that the field <code>c</code> in the class <code>Circle</code> is an arrow to the point object in the heap.</p> <p></p>"},{"location":"10-heap-stack.html#aliasing","title":"Aliasing","text":"<p>Now, let's look at an example of aliasing in the stack and heap diagram with the following example.</p> <pre><code>Circle c;\nPoint center;\ndouble radius;\nradius = 8;\ncenter = new Point(1, 1);\nc = new Circle(center, radius);\ncenter.moveto(2, 2);\n</code></pre> <p>In this example, we have three variables, <code>c</code>, <code>center</code>, and <code>radius</code>.  Lines 1-3 declare the variables, and as a result, we have three variables allocated on the stack.  Again, we assume that the code is in the static method <code>main</code>.  Do note the order of these variables in the stack.  Since we declared <code>c</code> first, it is located at the bottom of the stack.</p> <p>Recall that for object references, they are initialized to <code>null</code>.  Primitive type variables (e.g., <code>radius</code>) are initialized to 0.0 because it is of type <code>double</code>.  If it is an <code>int</code>, then it will be initialized to 0 instead,</p> After Lines 1-3After Lines 4-6After Line 7 <p></p> <p></p> <p></p> <p>There is a clear example of aliasing here.  Note that the field <code>c</code> of variable <code>c</code> is referencing the same object as the variable <code>center</code>.  Hence, we can say that the expression <code>c.c</code> is an alias of <code>center</code>.  In the stack and heap diagram, this is illustrated by having two different arrows pointing to the same location.</p> <p>In this case, the expression <code>c.c</code> consists of two arrows.  The first is from variable <code>c</code> to the object <code>Circle</code>.  The second is from the field <code>c</code> to the object <code>Point</code>.  On the other hand, the variable <code>center</code> is pointing directly to the object <code>Point</code>.</p> <p>We can also see that after Line 7, although the changes are done via <code>center.moveTo(..)</code>, the same object referenced by the expression <code>c.c</code> can see this change.</p>"},{"location":"10-heap-stack.html#call-stack","title":"Call Stack","text":"<p>Now, let's look at what happens when we invoke a method.  We have seen what happened when the constructor is invoked.  This is similar.  Take the <code>distanceTo</code> method in <code>Point</code> as an example:</p> <pre><code>class Point {\n  private double x;\n  private double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public double distanceTo(Point q) {\n    return Math.sqrt((q.x - this.x)*(q.x - this.x)+(q.y - this.y)*(q.y - this.y));\n  }\n}\n</code></pre> <p>and the invocation:</p> <pre><code>Point p1 = new Point(0, 0);\nPoint p2 = new Point(1, 1);\np1.distanceTo(p2);\n</code></pre> <p>After declaring <code>p1</code> and <code>p2</code> and creating both objects, we have:</p> <p></p> <p>When <code>distanceTo</code> is called, the JVM creates a stack frame for this instance method call.  This stack frame is a region of memory that tentatively contains (i) the <code>this</code> reference, (ii) the method arguments, and (iii) local variables within the method, among other things<sup>2</sup><sup>3</sup>.  When a class method is called, the stack frame does not contain the <code>this</code> reference.</p> <p></p> <p>You can see that the references to the objects <code>p1</code> and <code>p2</code> are copied onto the stack frame. <code>p1</code> and <code>this</code> point to the same object, and <code>p2</code> and <code>q</code> point to the same object. Within the method, any modification done to <code>this</code> would change the object referenced to by <code>p1</code>, and any change made to <code>q</code> would change the object referenced to by <code>p2</code> as well. After the method returns, the stack frame for that method is destroyed.</p> <p>Let's consider a new <code>move</code> method for the class <code>Point</code> that has two parameters <code>(double x, double y)</code> and moves the <code>x</code> and <code>y</code> cordinates of the <code>Point</code>.</p> <pre><code>class Point {\n  private double x;\n  private double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public void move(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre> <pre><code>Point p1 = new Point(0, 0);\nPoint p2 = new Point(1, 1);\ndouble x = 5;\ndouble y = 5;\np1.move(x, y);\n</code></pre> <p>Again, we create a stack frame, copy the reference to object <code>p1</code> into <code>this</code>, copy <code>x</code> from the calling method to <code>x</code> the argument within the method, copy <code>y</code> from the calling method to <code>y</code> the argument within the method.</p> After Lines 1-2After Lines 3-4Method Invocation at Line 5After Line 5 <p></p> <p></p> <p></p> <p></p> <p>What is important here is that, as <code>x</code> and <code>y</code> are primitive types instead of references, we copy the values onto the stack.  If we change <code>x</code> or <code>y</code> within <code>move</code>, the <code>x</code> and <code>y</code> of the calling function will not change.  This behavior is the same as you would expect in C.  However, unlike in C where you can pass in a pointer to a variable, you cannot pass in a reference to a primitive type in any way in Java.  If you want to pass in a variable of primitive type into a method and have its value changed, you will have to use a wrapper class.  The details of how to do this are left as an exercise.</p>"},{"location":"10-heap-stack.html#summary","title":"Summary","text":"<p>To summarize, Java uses call by value for primitive types, and call by reference for objects<sup>4</sup>.</p> <p>If we made multiple nested method calls, as we usually do, the stack frames get stacked on top of each other. </p> <p>One final note: the memory allocated on the stack is deallocated when a method returns.  The memory allocated on the heap, however, stays there as long as there is a reference to it (either from another object or from a variable in the stack).  Unlike C or C++, in Java, you do not have to free the memory allocated to objects.  The JVM runs a garbage collector  that checks for unreferenced objects on the heap and cleans up the memory automatically.</p> <ol> <li> <p>It can also behaves like a function/method in a sense that it can be invoked (e..g, <code>this(..)</code>).  In this case, the keyword <code>this</code> represents the constructor of the current class.  We will illustrate more of this on the topic of overloading.\u00a0\u21a9</p> </li> <li> <p>This is not that different from how an OS handles function call in a machine code, as you will see in CS2100/CS2106.\u00a0\u21a9</p> </li> <li> <p>The other things are JVM implementation independent and not relevant to our discussion here.\u00a0\u21a9</p> </li> <li> <p>Alternatively, you can think of Java as always using call by value.  It's just that the value of a reference is, in fact, just a reference.\u00a0\u21a9</p> </li> </ol>"},{"location":"11-inheritance.html","title":"Unit 11: Inheritance","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand inheritance as a mechanism to extend existing code.</li> <li>understand how inheritance models the IS-A relationship.</li> <li>know how to use the <code>extends</code> keyword for inheritance.</li> <li>understand inheritance as a subtype.</li> <li>be able to determine the run-time type and compile-time type of a variable.</li> </ul>"},{"location":"11-inheritance.html#extension-with-composition","title":"Extension with Composition","text":"<p>We have seen how composition allows us to compose a new more complex class out of existing classes, without breaking the abstraction barrier of existing classes.  Sometimes, however, composition is not the right approach.  Let's consider the following example.  Let's suppose that we, as a client, want to add color as a property to our <code>Circle</code>.   </p> <p>Without penetrating the abstraction barrier of <code>Circle</code>, we can do the following:</p> ColoredCircle v0.1 (with Composition)<pre><code>class ColoredCircle {\n  private Circle circle;\n  private Color color;\n\n  public ColoredCircle(Circle circle, Color color) {\n    this.circle = circle;\n    this.color = color;\n  }\n}\n</code></pre> <p>where <code>Color</code> is another abstraction representing the color of shapes.</p> <p>What should we do if we want to calculate the area of our colored circle?  Suppose we already have a <code>ColoredCircle</code> instance called <code>coloredCircle</code>. We could make <code>circle</code> public and call <code>coloredCircle.circle.getArea()</code>, or we could add an accessor and call <code>coloredCircle.getCircle().getArea()</code>.  Both of these are not ideal, since it breaks the abstraction barrier and reveals that the <code>ColoredCircle</code> class stores a <code>circle</code> (the latter being slightly better than the first).</p> <p>A better alternative is to let <code>ColoredCircle</code> provide its own <code>getArea()</code> method, and forward its call to <code>Circle</code>.</p> ColoredCircle v0.2 (with Composition)<pre><code>class ColoredCircle {\n  private Circle circle;\n  private Color color;\n\n  public ColoredCircle(Circle circle, Color color) {\n    this.circle = circle;\n    this.color = color;\n  }\n\n  public double getArea() {\n    return circle.getArea();\n  }\n}\n</code></pre> <p>Then, the client to <code>ColoredCircle</code> can just call <code>coloredCircle.getArea()</code> without knowing or needing to know how a colored circle is represented internally.  The drawback of this approach is that we might end up with many such boilerplate forwarding methods.  In fact, we need one boilerplate forwarding method for each method from <code>Circle</code> we want to access from <code>ColouredCircle</code>.  This is where language support is crucial as it will simplify our code.</p>"},{"location":"11-inheritance.html#extension-with-inheritance","title":"Extension with Inheritance","text":"<p>Recall the concept of subtyping.  We say that \\(S &lt;: T\\) if any piece of code written for type \\(T\\) also works for type \\(S\\).  There is a quote that you can use to remember this.</p> <p>Inheritance</p> <p>\"Whenever a superclass is needed, a subclass can be given.\"</p> <p>The reason the quote above works is because due to inheritance, the subclass inherits all the (public) methods from the superclass.  Put it another way, given \\(S &lt;: T\\), if we know that \\(T\\) has a (public) method called <code>foo</code>, we are sure that \\(S\\) also has a (public) method called <code>foo</code> because the method is inherited by \\(S\\).</p> <p>Now, think about <code>ColoredCircle</code> and <code>Circle</code>.  If someone has written a piece of code that operates on <code>Circle</code> objects.  Do we expect the same code to work on <code>ColoredCircle</code>?  In this example, yes!  A <code>ColoredCircle</code> object should behave just like a circle -- we can calculate its area, circumference, check if two circles intersect, check if a point falls within the circle, etc.  The only difference, or more precisely, extension, is that it has a color, and perhaps has some methods related to this additional field.  So, <code>ColoredCircle</code> is a subtype of <code>Circle</code>.</p> <p>We now show you how we can introduce this subtype relationship in Java, using the <code>extends</code> keyword.  We can reimplement our <code>ColoredCircle</code> class this way:</p> ColoredCircle v0.3 (with Inheritance)<pre><code>class ColoredCircle extends Circle {\n  private Color color;\n\n  public ColoredCircle(Point center, double radius, Color color) {\n    super(center, radius);  // call the parent's constructor\n    this.color = color;\n  }\n}\n</code></pre> <p>We have just created a new type called <code>ColoredCircle</code> as a class that extends from <code>Circle</code>.  We call <code>Circle</code> the parent class or superclass of <code>ColoredCircle</code>; and <code>ColoredCircle</code> a subclass of <code>Circle</code>.  </p> <p>We also say that <code>ColoredCircle</code> inherits from <code>Circle</code>, since all the public fields of <code>Circle</code> (center and radius) and public methods (like <code>getArea()</code>) are now accessible to <code>ColoredCircle</code>.  Just like a parent-child relationship in real-life, however, anything private to the parent remains inaccessible to the child.  This privacy veil maintains the abstraction barrier of the parent from the child, and creates a bit of a tricky situation -- technically a child <code>ColoredCircle</code> object has a center and a radius, but it has no access to it!</p> <p>Line 6 of the code above introduces another keyword in Java: <code>super</code>.  Here, we use <code>super</code> to call the constructor of the superclass, to initialize its center and radius (since the child has no direct access to these fields that it inherited).</p> <p>The concept we have shown you is called inheritance and is one of the four pillars of OOP.  We can think of inheritance as a model for the \"is a\" relationship between two entities.</p> <p>With inheritance, we can call <code>coloredCircle.getArea()</code> without knowing or needing to know how a colored circle is represented internally and without forwarding methods.</p>"},{"location":"11-inheritance.html#super-limitation","title":"<code>super</code> Limitation","text":"<p>In Java, if the call to <code>super</code> appears in a constructor, it has to appear as the first line in the constructor.  The reasoning is that the call to super instantiate (i.e., allocate memory and invoke the constructor of superclass instance) the superclass object.  Technically the current instance cannot exist without the existence of the superclass.  More importantly, if the constructor invokes the method or access the fields of the superclass, they will be successful<sup>1</sup>.</p> <p>You will see later that if a given class does not explicitly inherit another class, it will implicitly inherit from the <code>Object</code> class.  So, the constructor we have written so far does not -- as its first line -- invoke the <code>super</code> keyword.  How can it still work if we have the rule above?  The answer is that similar to default constructor, if there is no call to <code>super</code><sup>2</sup>, Java will automatically add the default <code>super()</code>.</p> <p>In combination with default constructor (or lack thereof), this may lead to potential problem that can be difficult to debug.  Furthermore, the error messages may not be easy to understand as they do not give hint at a possibility of missing <code>super(..)</code>.</p> <p>Example Error</p> No ConstructorNo <code>super</code>Non-First <code>super</code> <p>In this example, we omit the constructor for <code>ColoredCircle</code>.  As such, the default constructor is added automatically.  Since default constructor has no method body, the default <code>super()</code> is also automatically added.</p> <pre><code>class ColoredCircle extends Circle {\n  private Color color;\n\n  // no constructor\n}\n</code></pre> <p>Error message</p> <pre><code>_.java:_: error: constructor Circle in class Circle cannot be applied to given types;\nclass ColoredCircle extends Circle {\n^\n  required: Point,double\n  found: no arguments\n  reason: actual and formal argument lists differ in length\n1 error\n</code></pre> <p>In this example, we will omit the call to <code>super(..)</code>.  Therefore, the default <code>super()</code> is added.  But this would have invoked the constructor of <code>Circle</code> that accepts no parameter.  Unfortunately, no such constructor is available.  Hence, the error message seen.</p> <pre><code>class ColoredCircle extends Circle {\n  private Color color;\n\n  public ColoredCircle(Point center, double radius, Color color) {\n    // missing super(center, radius)\n    this.color = color;\n  }\n}\n</code></pre> <p>Error message</p> <pre><code>_.java:_: error: constructor Circle in class Circle cannot be applied to given types;\n    public ColoredCircle(Point c, double r, String color) {\n                                                          ^\n  required: Point,double\n  found: no arguments\n  reason: actual and formal argument lists differ in length\n1 error\n</code></pre> <p>Finally, if we did not call <code>super(..)</code> as the first statement in the constructor but call it after the first statement, we will have an additional error message shown on top of other error messages.</p> <pre><code>class ColoredCircle extends Circle {\n  private Color color;\n\n  public ColoredCircle(Point center, double radius, Color color) {\n    this.color = color;\n    super(center, radius)\n  }\n}\n</code></pre> <p>Error message</p> <pre><code>_.java:_: error: call to super must be first statement in constructor\nsuper(center, radius);\n     ^\n2 errors\n</code></pre> <p>Exception to the Rule</p> <p>There is an exception to this rule.  We do not require a call to <code>super(..)</code> and a default <code>super()</code> will not be added if the first statement in the constructor is a call to <code>this(..)</code>.  But since this is related to method overloading, we will revisit this concept again in the unit for overloading.</p>"},{"location":"11-inheritance.html#when-not-to-use-inheritance","title":"When NOT to Use Inheritance","text":"<p>Inheritance tends to get overused.  In practice, we seldom use inheritance.  Let's look at some examples of how not to use inheritance, and why.</p> <p>Consider the following example:</p> <pre><code>class Point {\n  private double x;\n  private double y;\n    :\n}\n\nclass Circle extends Point {\n  private double radius;\n    :\n}\n\nclass Cylinder extends Circle {\n  private double height;\n    :\n}\n</code></pre> <p>The difference between these implementations and the one you have seen in Unit 9 is that it uses inheritance rather than composition.  </p> <p><code>Circle</code> implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius); <code>Cylinder</code> would have the fields corresponding to a circle, which is its base and height.  In terms of modeling the properties of circle and cylinder, we have all the right properties in the right class.</p> <p>When we start to consider methods encapsulated with each object, things start to break down. Consider a piece of code written as follows: <pre><code>void foo(Circle c, Point p) {\n  if (c.contains(p)) {\n    // do something\n  }\n}\n</code></pre></p> <p>Since <code>Cylinder</code> is a subtype of <code>Point</code> according to the implementation above, the code above should still work also if we replace <code>Point</code> with a <code>Cylinder</code> (according to the semantic of subtyping).   But it gets weird -- what is the meaning of a <code>Circle</code> (in 2D) containing a Cylinder (in 3D)?  We could come up with a convoluted meaning that explains this, but it is likely not what the original implementer of <code>foo</code> expects.</p> <p>The message here is this: Use composition to model a has-a relationship; inheritance for a is-a relationship.  Make sure inheritance preserves the meaning of subtyping.  </p>"},{"location":"11-inheritance.html#type-checking","title":"Type Checking","text":""},{"location":"11-inheritance.html#run-time-type","title":"Run-Time Type","text":"<p>Recall that Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S &lt;: T\\).  Since <code>ColoredCircle</code> &lt;: <code>Circle</code>, the following is not allowed in Java:</p> <pre><code>ColoredCircle c = new Circle(p, 0); // error\n</code></pre> <p>but this is OK:</p> <pre><code>Circle c = new ColoredCircle(p, 0, blue); // OK\n</code></pre> <p>where <code>p</code> is a <code>Point</code> object and <code>blue</code> is a <code>Color</code> object.  But wait, how do we know are they really ok or not?</p> <p>Consider the first case.  Notice how <code>ColoredCircle</code> potentially has more methods than <code>Circle</code>.  First, <code>ColoredCircle</code> inherits all the methods from <code>Circle</code> and we may also add new methods related to the <code>Color</code>.  So if we instantiate a <code>ColoredCircle</code> as a <code>Circle</code>, how do we fill in the missing functionality?  Since we cannot, Java simply says that this is an error.</p> <p>On the other hand, the second case is really ok because <code>Circle</code> has fewer methods than <code>ColoredCircle</code>.  In fact, because of inheritance, whatever a <code>Circle</code> can do, a <code>ColoredCircle</code> can also do.  After all, the methods in <code>Circle</code> can be used automatically in <code>ColoredCircle</code> without boilerplate forwarding.</p> <p>Also, recall that <code>Circle</code> is called the compile-time type of <code>c</code>.  Here, we see that <code>c</code> is now referencing an object of subtype <code>ColoredCircle</code>.  Since this assignment happens during run-time, we say that the run-time type of <code>c</code> is <code>ColoredCircle</code>.  The distinction between these two types will be important later.</p> <p>In short, assuming \\(S &lt;: T\\) and the following assignment</p> <pre><code>T x = new S();\n</code></pre> <ul> <li>Compile-time type of <code>x</code> is <code>T</code>.</li> <li>Run-time type of <code>x</code> is <code>S</code>.</li> </ul> <p>To put it in a broader picture, we can look at what happened on assignment <code>lhs = rhs</code>.  We can deduce the compile-time type of <code>lhs</code> and <code>rhs</code> independently.  Then, the allowed assignment happen if the type of <code>rhs</code> is the subtype of <code>lhs</code>.  So, assuming \\(S &lt;: T\\), we have the following table.</p> Assignment Allowed? <code>T x = new T()</code> <code>T x = new S()</code> <code>S x = new T()</code> <code>S x = new S()</code>"},{"location":"11-inheritance.html#compile-time-type","title":"Compile-Time Type","text":"<p>A common confusion made by programmers who are more familiar with dynamic typing like Python and JavaScript is to confuse compile-time type and run-time type.  The compile-time type is the type during the declaration while run-time type is the type actually created using the <code>new</code> keyword.</p> <p>We will use the following class declarations for our example.</p> <pre><code>class T {\n  public int foo() {\n    return 0;\n  }\n}\nclass S1 extends T {\n  public int bar() {\n    return 1;\n  }\n}\nclass S2 extends T {\n  public int baz() {\n    return 2;\n  }\n}\n</code></pre> <p>Now consider the following code snippet:</p> <pre><code>T x = new S1();\nx = new S2();  // re-assignment\n</code></pre> <p>Such a re-assignment is allowed because the compile-time type of <code>x</code> is <code>T</code>.  The assignment at Line 1 is allowed because <code>S1</code> &lt;: <code>T</code>.  Similarly, the assignment at Line 2 is allowed because <code>S2</code> &lt;: <code>T</code>.  The common mistake is to think mentally that the compile-time type of <code>x</code> is <code>S1</code> because that's actually the run-time type.</p> <p>Java cannot use the information from run-time type because the analysis involving run-time type can be extremely complicated.  As such, Java will only use compile-time type information for its type checking.  To illustrate the potential complexity, consider the following method where we have <code>S1</code> &lt;: <code>T</code> and <code>S2</code> &lt;: <code>T</code>.</p> <pre><code>T makeT(boolean check) {\n  if (riemannHypothesis() == check) {\n    return new S1();\n  } else {\n    return new S2();\n  }\n}\n</code></pre> <p>Here, we to know the actual run-time type, Java compiler will have to actually proof that the Riemann hypothesis is true.  Unfortunately, it is currently still an open problem in Mathematics<sup>3</sup>.</p> <p>So the only thing known about <code>x</code> from the perspective of the compiler is that it is of compile-time type <code>T</code>.  We can extend this reasoning further to the following code snippet.</p> <pre><code>T x = new S1();\nx.bar();\n</code></pre> <p>The code snippet above will give the following compilation error:</p> <pre><code>_.java:_: error: cannot find symbol\n    x.bar();\n     ^\n  symbol:   method bar()\n  location: variable x of type T\n1 error\n</code></pre> <p>To reiterate, the reason is because from the point of view of the compiler, <code>x</code> is of compile-time type <code>T</code>.  Since the type <code>T</code> has no method called <code>bar</code>, we have a (potential) error.  Note how the run-time type information is not used at all for the analysis.</p> <p>The run-time type is actually <code>S1</code> which actually has the method <code>bar</code>.  But this information is irrelevant for compile-time type checking.  The reason is the same as above, imagine that we replace Line 1 with <code>T x = makeT()</code>, then the compiler will have to proof Riemann hypothesis.  Our poor compiler has to be smarter than all the Mathematicians.</p>"},{"location":"11-inheritance.html#nominal-subtyping","title":"Nominal Subtyping","text":"<p>Java subtyping relationship is known as nominal subtyping.  This means that the subtyping relationship has to be explicitly declared.  The keyword to declare this is <code>extends</code>.  So, we may have two classes that somehow incidentally have the same public methods and they are still treated as two incompatible types.  Consider the two badly named implementation below.</p> Point 3DColor RGB <pre><code>class Point3D {\n  private double data1; // x-coordinate\n  private double data2; // y-coordinate\n  private double data3; // z-coordinate\n\n  public Point3D(double data1, double data2, double data3) {\n    this.data1 = data1;\n    this.data2 = data2;\n    this.data3 = data3;\n  }\n\n  public double getData1() {\n    return this.data1;\n  }\n\n  public double getData2() {\n    return this.data2;\n  }\n\n  public double getData3() {\n    return this.data3;\n  }\n}\n</code></pre> <pre><code>class ColorRGB {\n  private double data1; // red color (r)\n  private double data2; // green color (g)\n  private double data3; // blue color (b)\n\n  public ColorRGB(double data1, double data2, double data3) {\n    this.data1 = data1;\n    this.data2 = data2;\n    this.data3 = data3;\n  }\n\n  public double getData1() {\n    return this.data1;\n  }\n\n  public double getData2() {\n    return this.data2;\n  }\n\n  public double getData3() {\n    return this.data3;\n  }\n}\n</code></pre> <p>Looking only at the accessible public methods, we may think that a function written to work with <code>Point3D</code> should work with <code>ColorRGB</code> and vice versa.  All the methods that are available in <code>Point3D</code> are also available in <code>ColorRGB</code>.  In fact, the codes are identical except for the class name.</p> <pre><code>public void display(Point3D point) {\n  System.out.println(\"(\" + point.getData1() + \", \" + point.getData2() + \", \" + point.getData3() + \")\");\n}\n</code></pre> <p>Unfortunately, unless we explicitly add a subtyping relationship between <code>Point3D</code> and <code>ColorRGB</code>, they remain incompatible classes.  So the method <code>display</code> above cannot be used for <code>ColorRGB</code>.  We have to write a different method that accepts <code>ColorRGB</code> as parameter.</p> <p>This also relates to the anti-symmetry property of subtyping relationship in Java.  Java prevents a cyclic subtyping relationship.  Try the example below and see the error message from the compiler.</p> <p>Cyclic Inheritance</p> <pre><code>class A extends B {\n}\n\nclass B extends A {\n}\n</code></pre> <p>Compilation Error <pre><code>_.java:_: error: cyclic inheritance involving A\nclass A extends B {}\n^\n1 error\n</code></pre></p> <p>Class Diagram (Part 4)</p> <p>So far, we have learnt how to draw a class diagram for a single class.  With inheritance, we will need to connect two or more classes.  We have seen this idea in subtyping between primitive types where we use a solid arrow to connect two types.  The same idea applies here but instead of connecting two primitive types, we connect reference types.</p> <p>Consider the following classes:</p> <pre><code>class Point2D {\n  private double x;\n  private double y;\n\n  public Point2D(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public double getX() {\n    return this.x;\n  }\n\n  public double getY() {\n    return this.y;\n  }\n}\n\nclass Point3D extends Point2D {\n  private double z;\n\n  public Point3D(double x, double y, double z) {\n    super(x, y);\n    this.z = z;\n  }\n\n  public double getZ() {\n    return this.z;\n  }\n}\n</code></pre> <p>As a good practice, we will draw the supertype on top of the subtypes.</p> <p></p> <p>Analysis of Class Diagram</p> <p>The advantage of using class diagram for our design is that we can analyze class diagram without the actual implementation.  Take for instance, the class diagram below.</p> <p></p> <p>Without even looking at the code, we can see that a <code>Vehicle</code> can go vroom vroom.  Additionally, we can also see that a <code>RaceCar</code> can also go vroom vroom.  Although <code>RaceCar</code> has no method called <code>vroom()</code> to go vroom vroom, it inherits the method from the class <code>Vehicle</code>.  We can also see that <code>RaceCar</code> has an additional method called <code>boost</code>.</p> <ol> <li> <p>Truthfully, this reasoning is faulty because (i) it is too restrictive and (ii) it does not solve the problem stated.  Java allows the call to super to invoke another function (e.g., <code>super(f(x))</code>).  Then, <code>f(x)</code> can actually invoke methods from superclass.  In any case, that's the typical reasoning given by Java, but just take it with a grain of salt.\u00a0\u21a9</p> </li> <li> <p>There should also be no call to <code>this</code> in the constructor, but that will only be discussed when we talk about method overloading.  In particular, we may overload the constructor.\u00a0\u21a9</p> </li> <li> <p>If you do solve it, there is a $1 million prize for it.  Please kindly remember who introduced you to this problem and share the prize.\u00a0\u21a9</p> </li> </ol>"},{"location":"12-overriding.html","title":"Unit 12: Overriding","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be aware that every class inherits from <code>Object</code>.</li> <li>be familiar with the <code>equals</code> and <code>toString</code> methods.</li> <li>understand what constitutes a method signature.</li> <li>understand method overriding.</li> <li>appreciate the power of method overriding.</li> <li>understand what Java annotations are for, and know when to use <code>@Override</code>.</li> <li>be exposed to the <code>String</code> class and its associated methods, especially the <code>+</code> operator.</li> </ul>"},{"location":"12-overriding.html#object-and-string","title":"<code>Object</code> and <code>String</code>","text":"<p>In Java, every class that does not extend another class inherits from the class <code>Object</code> implicitly.  <code>Object</code> is, therefore, the \"ancestor\" of all classes in Java and is at the root of the class hierarchy.</p> <p>The <code>Object</code> class does not encapsulate anything in particular.  It is a very general class that provides useful methods common to all objects.  The two useful ones that we are going to spend time with are:</p> <ul> <li><code>equals(Object obj)</code>, which checks if two objects are equal to each other, and</li> <li><code>toString()</code>, which returns a string representation of the object as a <code>String</code> object.</li> </ul> <p>Now that we have related classes as well as methods that may be inherited, we will introduce a notation that captures the essence of a method as well as where the method is implemented.  Consider the method <code>equals(Object obj)</code> in the class <code>Object</code>.  First note that the parameter name <code>obj</code> can actually be renamed so the name does not matter.  As such, we can actually omit them.  Secondly, we need to indicate that the implementation we are interested is the implementation in the class <code>Object</code>.  So, we can write it simply as <code>Object::equals(Object)</code>.</p> <p>Method Summary</p> <p>There are two ways we can summarize a method. Consider the following class with a single method <code>foo</code>.</p> <pre><code>class C {\n    : // fields omitted\n  A foo(B1 b1, B2 b2) {\n      : // body omitted\n  }\n}\n</code></pre> <ul> <li>Method Signature<ul> <li>Only the name of the method and the type of parameters.  Optionally, we may include the class name.</li> <li>In other words, the information captured are:<ul> <li>Method name.</li> <li>Number of parameters.</li> <li>Types of parameters.</li> <li>Order of parameters.</li> </ul> </li> </ul> </li> <li>Method Descriptor<ul> <li>Only the name of the method, the type of parameters, and the return type.  Optionally, we may include the class name.</li> <li>In other words, the information captured are:<ul> <li>Method name.</li> <li>Number of parameters.</li> <li>Types of parameters.</li> <li>Order of parameters.</li> <li>Return type.</li> </ul> </li> </ul> </li> </ul> Summary Without Class Name With Class Name Method Signature <code>foo(B1, B2)</code> <code>C::foo(B1, B2)</code> Method Descriptor <code>A foo(B1, B2)</code> <code>A C::foo(B1, B2)</code> <p>Class names are included if we want to mention a specific implementation.  On the other hand, we typically excldue the class names when we want to talk about the method regardless of where it is implemented.  Lastly, we may omit the parameters if we want to talk about all the methods with the given name (e.g., <code>C::foo</code> or simply <code>foo</code>).</p>"},{"location":"12-overriding.html#the-tostring-method","title":"The <code>toString</code> Method","text":"<p>The <code>toString</code> method is very special, as this is invoked implicitly by Java, by default, to convert a reference object to a <code>String</code> object during string concatenation using the operator <code>+</code>.  It is also invoked implicitly when we print using <code>System.out.println(..)</code>.  Note that an assignment to a string variable does not automatically invoke the <code>toString</code> method.</p> <p>We showed you that in Python, <code>4 + \"Hello\"</code> would result in a type mismatch error.  In Java, however, <code>4 + \"Hello\"</code> will result in the string <code>\"4Hello\"</code>.  In this example, the primitive value 4 is converted to a string before concatenation.</p> <p>A more interesting scenario is what happens if we try to concatenate, say, a <code>Circle</code> object with a string.  Let's say we have:</p> <pre><code>Circle c = new Circle(new Point(0, 0), 4.0);\nString s = \"Circle c is \" + c;\n</code></pre> <p>You will see that <code>s</code> now contains the string \"Circle c is Circle@1ce92674 \" (the seemingly gibberish text after @ is the reference to the object and so your result will be different).</p> <p>What happened here is that the <code>+</code> operator sees that one of the operands is a string but the other is not, so it converts the one that is not a string to a string by calling its <code>toString()</code> method automatically for us.  This is equivalent to<sup>1</sup> <pre><code>Circle c = new Circle(new Point(0, 0), 4.0);\nString s = \"Circle c is \" + c.toString();\n</code></pre></p> <p>Recall that in our <code>Circle</code> class (up to version 0.5) we do not have any <code>Circle::toString()</code> method.  The <code>toString</code> method that we invoked here is the <code>toString</code> method inherited from its parent <code>Object</code> (i.e., <code>Object::toString()</code>).</p> <p><code>jshell</code> and <code>toString</code></p> <p>Recall that <code>jshell</code> is a REPL tool.  After evaluating an expression, <code>jshell</code> prints the resulting value out.  If the resulting value is a reference type, <code>jshell</code> will invoke <code>toString</code> to convert the reference type to a string first, before printing the string.</p>"},{"location":"12-overriding.html#customizing-tostring-for-circle","title":"Customizing <code>toString</code> for <code>Circle</code>","text":"<p>The <code>Object::toString()</code> method is not very user friendly.  Ideally, when we print a <code>Circle</code> object, say, for debugging, we want to see its center and its radius.  To do so, we can define our own <code>toString</code> method in <code>Circle</code> (i.e., <code>Circle::toString()</code>).  Let's upgrade our <code>Circle</code> class to do this:</p> Circle v0.6<pre><code>import java.lang.Math;\n\n/**\n * A Circle object encapsulates a circle on a 2D plane.  \n */\nclass Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  /**\n   * Return the string representation of this circle.\n   */\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n}\n</code></pre> <p>The body of the method <code>Circle::toString()</code> simply constructs a string representation for this circle object and returns it.  With this <code>toString</code> implemented, the output will look something like this:</p> <pre><code>Circle c is { center: (0.0, 0.0), radius: 4.0 }\n</code></pre> <p>Note that when the center <code>this.c</code> is converted to a string, the <code>toString</code> method of <code>Point</code> class is invoked (i.e., <code>Point::toString()</code>).  We leave the implementation of <code>Point::toString()</code> as an exercise.</p>"},{"location":"12-overriding.html#method-overriding","title":"Method Overriding","text":"<p>What we just did is called method overriding in OOP.  Inheritance is not only good for extending the behavior of an existing class but through method overriding, we can alter the behavior of an existing class as well.</p> <p>Recap that the method signature of a method as the method name and the number, type, and order of its parameters, and the method descriptor as the method signature plus the return type.  When a subclass defines an instance method with the same method descriptor as an instance method in the parent class, we say that the instance method in the subclass overrides the instance method in the parent class<sup>2</sup>.  In the example above, <code>Circle::toString()</code> has overridden <code>Object::toString()</code>.</p> <p>Put it another way, when a subclass defines an instance method with the same method signature as an instance method in the parent class, then we need to check the return type.  If the return type is not compatible (i.e., the return type on the subclass is not a subtype of the return type on the superclass), then we are trying to override a method with incompatible return type.  This may lead to major problems on our subtyping principle.</p> <p>Subtyping</p> <p>\"Whenever a supertype is needed, a subtype can be given.\"</p> <p>Consider the following two classes.</p> <pre><code>class T {\n  public int f() {\n    return 1;\n  }\n}\n\nclass S extends T {\n  public T f() {\n    return null;\n  }\n}\n</code></pre> <p>Now a code written for type <code>T</code> does not work for type <code>S</code> even though <code>S</code> &lt;: <code>T</code> as you can see below.</p> Code for <code>T</code>Does Not Work with <code>S</code> <pre><code>T t = new T();\nint x = t.f(); // ok because T::f() returns int\n</code></pre> <pre><code>S t = new S();\nint x = t.f(); // error because S::f() returns T\n</code></pre> <p>We will emphasize the use of method signature (and maybe method descriptor) to check for method overriding.  Once you have distilled the information down to the method signature or descriptor, you can focus only on the required information to determine if overriding actually happen or not.  You can test your understanding by determining which of the followings are overridden and which are not.  Assume that <code>S</code> &lt;: <code>T</code> and there are no subtyping relationships on other types.</p> QuestionAnswer Descriptor in <code>T</code> Descriptor in <code>S</code> Is Overriding? <code>double T::foo(int)</code> <code>double S::foo(int)</code> <code>double T::foo(double)</code> <code>int S::foo(int)</code> <code>A T::foo()</code> <code>A S::foo()</code> <code>A1 T::foo(B, C, D)</code> <code>A2 S::foo(B, C, D)</code> Descriptor in <code>T</code> Descriptor in <code>S</code> Is Overriding? <code>double T::foo(int)</code> <code>double S::foo(int)</code> <code>double T::foo(double)</code> <code>int S::foo(int)</code>  (<code>double</code> \u2260 <code>int</code>) <code>A T::foo()</code> <code>A S::foo()</code> <code>A1 T::foo(B, C, D)</code> <code>A2 S::foo(B, C, D)</code>  (unless <code>A2</code> &lt;: <code>A1</code>, more on this later)"},{"location":"12-overriding.html#the-override-annotation","title":"The <code>@Override</code> Annotation","text":"<p>Line 37 in the example on <code>Circle</code> class contains the symbol <code>@Override</code>.  This symbol is an example of annotation in Java.  An annotation is not part of the program and does not affect the bytecode generated.  Instead, it is a hint to the compiler.  Remember that the compiler is our friend who will do its best to help detect errors early, during compilation.  We must do our part to help the compiler help us.  Here, <code>@Override</code> is a hint to the compiler that the following method, <code>toString</code> (more specifically <code>Circle::toString()</code>), is intended to override the method in the parent class.  In case that there is a typo and overriding is not possible, the compiler will let us know.  In other words, if all the superclass <code>S</code> has no method <code>S::toString()</code> with compatible return type, then overriding is not possible.</p> <p>It is therefore recommended and expected that all overriding methods in your code are annotated with <code>@Override</code>.</p> <p>Using <code>super</code> To Access Overridden Methods</p> <p>After a subclass overrides a method in the superclass, the methods that have been overridden can still be called, with the <code>super</code> keyword. For instance, the following <code>Circle::toString</code> calls <code>Object::toString</code> to prefix the string representation of the circle with <code>Circle@1ce92674</code>. <pre><code>@Override\npublic String toString() {\n  return super.toString() + \" { center: \" + this.c + \", radius: \" + this.r + \" }\";\n}\n</code></pre></p> <ol> <li> <p>Calling <code>toString</code> explicitly is not wrong, but we usually omit the call to keep the code readable and succinct.\u00a0\u21a9</p> </li> <li> <p>It is possible to override a method in some cases when the return type is different.  We will discuss this during recitations.\u00a0\u21a9</p> </li> </ol>"},{"location":"13-overloading.html","title":"Unit 13: Overloading","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand what is overloading.</li> <li>understand how to create overloaded methods.</li> </ul>"},{"location":"13-overloading.html#method-overloading","title":"Method overloading","text":"<p>In the previous unit, we introduced method overriding. That is, when a subclass defines an instance method with the same method descriptor as an instance method in the parent class.</p> <p>In contrast, method overloading is when we have two or more methods in the same class (or inherited from superclass) with the same name but a differing method signature<sup>1</sup>. In other words, we create an overloaded method by changing the type, order, and number of parameters of the method but keeping the method name identical. </p> <p>Lets consider an <code>add</code> method which allows us to add two numbers, and returns the result. What if we would like to create an <code>add</code> method to sum up three numbers?</p> <pre><code>public int add(int x, int y) {\n  return x + y;\n}\n\npublic int add(int x, int y, int z) {\n  return x + y + z;\n}\n</code></pre> <p>In the example above, the methods <code>add(int, int)</code> and <code>add(int, int, int)</code> are overloaded. They have the same name but a different number of parameters. We can see that this allows us to write methods to handle differing inputs. </p> <p>Now lets consider our <code>Circle</code> class again. Our <code>Circle::contains(Point)</code> method allows us to check if a <code>Point</code> is within the radius of the current instance of the <code>Circle</code>. We would like to create a new method <code>Circle::contains(double, double)</code> which will allow us to check if an <code>x</code> and <code>y</code> coordinate (another valid representation of a point) is within our circle.</p> Circle v0.6.1<pre><code>class Circle {\n  private Point c;   \n  private double r;  \n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  public boolean contains(Point p) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  public boolean contains(double x, double y) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n}\n</code></pre> <p>In the above example, <code>Circle::contains(Point)</code> and <code>Circle::contains(double, double)</code> are overloaded methods. </p> <p>Recall that overloading requires changing the order, number, and/or type of parameters and says nothing about the names of the parameters. Consider the example below, where we have two <code>contains</code> methods in which we swap parameter names. </p> <pre><code>  public boolean contains(double x, double y) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  public boolean contains(double y, double x) {\n    return true;\n    // TODO: Left as an exercise\n  }\n</code></pre> <p>These two methods have the same method signature, and therefore <code>contains(double, double)</code> and <code>contains(double, double)</code> are not distinct methods. They are not overloaded, and therefore this above example will not compile.</p> <pre><code>_.java:_: error: method contains(double,double) is already defined in class Circle\n  public boolean contains(double y, double x) {\n                 ^\n1 error\n</code></pre> <p>As it is also a method, it is possible to overload the class constructor as well. As in the example below, we can see an overloaded constructor which gives us a handy way to instantiate a <code>Circle</code> object that is the unit circle centred at origin.</p> Circle v0.6.2<pre><code>class Circle {\n  private Point c; \n  private double r;\n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  // Overloaded constructor\n  public Circle() {\n    this.c = new Point(0, 0);\n    this.r = 1;\n  }\n    :\n}\n</code></pre> <pre><code>// c1 points to a new Circle object with a centre (1, 1) and a radius of 2\nCircle c1 = new Circle(new Point(1, 1), 2); \n// c2 points to a new Circle object with a centre (0, 0) and a radius of 1\nCircle c2 = new Circle();\n</code></pre> <p>It is also possible to overload <code>static</code> class methods in the same way as instance methods. In the next unit, we will see how Java chooses which method implementation to execute when a method is invoked.</p> Chaining Constructor <p>If we look at the call to overloaded constructor <code>new Circle()</code>, it is equivalent to <code>new Circle(new Point(0, 0), 1)</code>.  Recap the spirit of abstraction shown below.</p> <p>Abstraction Principle</p> <p>\"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"</p> <p>Benjamin C. Pierce</p> <p>In the spirit of abstraction, we may want our overloaded constructor <code>Circle::Circle()</code> to invoke our original constructor <code>Circle::Circle(Point, double)</code>.  That way, any changes will have to be made in only one place.  This can be achieved by invoking <code>this(..)</code> as the first line on the constructor.  So, our <code>Circle</code> class can be written as follows.</p> Circle v0.6.3<pre><code>class Circle {\n  private Point c;\n  private double r;\n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  // Overloaded constructor with a call to this(..)\n  public Circle() {\n    this(new Point(0, 0), 1);\n  }\n    :\n}\n</code></pre> <p>If there are more constructors, we can have more chaining.  We may want to chain from the \"simpler\" constructor to the more \"complex\" constructor.  Consider adding another overloaded constructor that allows specifying a radius but will always be centred at origin.</p> Circle v0.6.4<pre><code>class Circle {\n  private Point c;\n  private double r;\n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  // Overloaded constructor 1\n  public Circle(double r) {\n    this(new Point(0, 0), r); // chained to Circle::Circle(Point, double)\n  }\n\n  // Overloaded constructor 2\n  public Circle() {\n    this(1); // chained to Circle::Circle(double)\n  }\n    :\n}\n</code></pre> <p>Remember how we mentioned that the call to <code>super(..)</code> (if any) in the constructor must be the first line in the constructor?  The call to <code>this(..)</code> (if any) must also be the first line in the constructor.  Therefore, you cannot have both call to <code>super(..)</code> and call to <code>this(..)</code>.  Which also means that if there is a call to <code>this(..)</code> default constructor is also not automatically added.</p> <ol> <li> <p>Note that this is not the same as the method descriptor. You can not overload a method by changing the return type.\u00a0\u21a9</p> </li> </ol>"},{"location":"14-polymorphism.html","title":"Unit 14: Polymorphism","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand polymorphism.</li> <li>be aware of dynamic binding.</li> <li>be aware of the <code>equals</code> method and the need to override it to customize the equality test.</li> <li>understand when narrowing type conversion and type casting are allowed.</li> </ul>"},{"location":"14-polymorphism.html#taking-on-many-forms","title":"Taking on Many Forms","text":"<p>Method overriding enables polymorphism, the fourth and the last pillar of OOP.  Arguably this is the most powerful pillar.  It allows us to change how existing code behaves, without changing a single line of the existing code (or even having access to the code).</p> <p>Consider the function <code>say(Object)</code> below: <pre><code>void say(Object obj) {\n  System.out.println(\"Hi, I am \" + obj.toString());\n}\n</code></pre></p> <p>Note that this method receives an <code>Object</code> instance.  Since both <code>Point</code> &lt;: <code>Object</code> and <code>Circle</code> &lt;: <code>Object</code>, we can do the following (recap: \"whenever a superclass is needed, a subclass can be given\"): <pre><code>Point p = new Point(0, 0);\nsay(p);\nCircle c = new Circle(p, 4);\nsay(c);\n</code></pre></p> <p>When executed, <code>say</code> will first print <code>Hi, I am (0.0, 0.0)</code>, followed by <code>Hi, I am { center: (0.0, 0.0), radius: 4.0 }</code>.  We are invoking the overriding <code>Point::toString()</code> in the first call, and <code>Circle::toString()</code> in the second call.  The same method invocation <code>obj.toString()</code> causes two different methods to be called in two separate invocations!</p> <p>In biology, polymorphism means that an organism can have many different forms.  Here, the variable <code>obj</code> can have many forms as well.  Which method is invoked is decided during run-time, depending on the run-time type of the <code>obj</code>.  This is called dynamic binding or late binding or dynamic dispatch.</p> <p>Before we get into this in more detail, let's consider overriding <code>Object::equals(Object)</code>.</p>"},{"location":"14-polymorphism.html#the-equals-method","title":"The <code>equals</code> method","text":"<p><code>Object::equals(Object)</code> compares if two object references refer to the same object.  That is also the standard behavior of the <code>==</code> operator.  In the case of <code>==</code> operator, we can say that it compares the value.  So what is the value of a reference type?  Well, it must be the reference (i.e., the address).</p> <code>equals</code> Method <p>While it is not necessary to know this, <code>equals</code> method should satisfy an equivalence relation on non-null object references:</p> <ul> <li>It is reflexive: for any non-null reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.</li> <li>It is symmetric: for any non-null reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.</li> <li>It is transitive: for any non-null reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.</li> <li>It is consistent: for any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in equals comparisons on the objects is modified.</li> <li>For any non-null reference value <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.</li> </ul> <p>One thing to be careful of when using <code>equals</code> method is that you must ensure in the method invocation <code>obj.equals(arg)</code>, the value of <code>obj</code> is not <code>null</code>.</p> <p>Suppose we have:</p> <pre><code>Circle c0 = new Circle(new Point(0, 0), 10);\nCircle c1 = new Circle(new Point(0, 0), 10);\nCircle c2 = c1;\n</code></pre> <p><code>c2.equals(c1)</code> returns <code>true</code>, but <code>c0.equals(c1)</code> returns <code>false</code>.  Even though <code>c0</code> and <code>c1</code> are semantically the same, they refer to the two different objects.</p> <p>To compare if two circles are semantically the same, we need to override this method<sup>1</sup>.  After all, Java does not know what you meant by having two circle being equal.  There are other possibilities including (but not limited to)</p> <ul> <li>having equal radius</li> <li>having equal center point</li> <li>having both equal radius and center point</li> </ul> Circle v0.7.1<pre><code>/**\n * A Circle object encapsulates a circle on a 2D plane.  \n */\nclass Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  /**\n   * Return the string representation of this circle.\n   */\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n\n  /**\n   * Return true the object is the same circle (i.e., same center, same radius).\n   */\n  @Override\n  public boolean equals(Object obj) {\n    if (obj instanceof Circle) {\n      Circle circle = (Circle) obj;\n      return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n    }\n    return false;\n  }\n}\n</code></pre> <p>This is more complicated than <code>toString</code>.  There are a few new concepts involved here so let's go through them slowly.  Click on the tabs below to find out more.</p> <code>instanceof</code> OperatorFields AccessExplicit Type Casting <pre><code>public boolean equals(Object obj) {\n  if (obj instanceof Circle) {\n    Circle circle = (Circle) obj;\n    return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n  }\n  return false;\n}\n</code></pre> <p><code>equals</code> takes in a parameter of compile-time type <code>Object</code> (Line 1).  It only makes sense if we compare (during run-time) a circle with another circle.  So, we first check if the run-time type of <code>obj</code> is a subtype of <code>Circle</code>.  This is done using the <code>instanceof</code> operator.  The operator returns <code>true</code> if <code>obj</code> has a run-time type that is a subtype of <code>Circle</code>.</p> <pre><code>public boolean equals(Object obj) {\n  if (obj instanceof Circle) {\n    Circle circle = (Circle) obj;\n    return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n  }\n  return false;\n}\n</code></pre> <p>To compare <code>this</code> circle with the given circle, we have to access the center <code>c</code> and radius <code>r</code>.  But if we access <code>obj.c</code> or <code>obj.r</code>, the compiler will complain.  As far as the compiler is concerned, <code>obj</code> has the compile-time type <code>Object</code>, and there is no such fields <code>c</code> and <code>r</code> in the class <code>Object</code>!  This is why, after assuring that the run-time type of <code>obj</code> is a subtype of <code>Circle</code>, we assign <code>obj</code> to another variable <code>circle</code> that has the compile-time type <code>Circle</code>.  We finally check if the two centers are equal (again, <code>Point::equals</code> is left as an exercise) and the two radii are equal<sup>2</sup>.</p> <p>Another important point is that <code>circle.c</code> and <code>circle.r</code> are allowed even when the fields <code>c</code> and <code>r</code> are declared <code>private</code> because we are inside the class <code>Circle</code>.  So even if the fields belong to another object, as long as it is in the same class, it is allowed.</p> <pre><code>public boolean equals(Object obj) {\n  if (obj instanceof Circle) {\n    Circle circle = (Circle) obj;\n    return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n  }\n  return false;\n}\n</code></pre> <p>The statement that assigns <code>obj</code> to <code>circle</code> involves type casting.  We mentioned before that Java is strongly typed and so it is very strict about type conversion.  Here, Java allows type casting from type \\(T\\) to \\(S\\) if \\(S &lt;: T\\)<sup>3</sup>.  By allow, we meant that Java compiler will not give compilation error.</p> <p>This is called narrowing type conversion.  Unlike widening type conversion, which is always allowed and always correct, a narrowing type conversion requires explicit typecasting and validation during run-time.  If we do not ensure that <code>obj</code> has the correct run-time type, casting can lead to a run-time error (which if you recall, is bad).</p> <p>The syntax for explicit type conversion is <code>(Type) expr</code>.  Java will attempt to convert the result of the expression <code>expr</code> into the type <code>Type</code>.  While you may also add explicit type casting for widening type conversion, such explicit type casting is not necessary and can be omitted.</p> <p>Pattern Matching</p> <p> Since Java 16 -- JEP 394 -- Java has added pattern matching in the <code>instanceof</code> operator. Here, instead of performing <code>instanceof</code> check followed by a type cast inside the block, we can combine the two into a single line during the check. </p> <ul> <li> <p>Previous</p> <pre><code>if (obj instanceof Circle) {\n  Circle circle = (Circle) obj;\n  // ...\n}\n</code></pre> </li> <li> <p>After Java 16</p> <pre><code>if (obj instanceof Circle circle) {\n  // No need type cast\n  // ...\n}\n</code></pre> </li> </ul> <p>All these complications would go away, however, if we define <code>Circle::equals</code> to take in a <code>Circle</code> as a parameter, like this:</p> Circle v0.7.2<pre><code>class Circle {\n    :\n  /**\n   * Return true the object is the same circle (i.e., same center, same radius).\n   */\n  @Override\n  public boolean equals(Circle circle) {\n    return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n  }\n}\n</code></pre> <p>This version of <code>equals</code> however, does not override <code>Object::equals(Object)</code>.  Since we hinted to the compiler that we meant this to be an overriding method, using <code>@Override</code>, the compiler will give us an error.  This is not treated as method overriding, since the signature for <code>Circle::equals(Circle)</code> is different from <code>Object::equals(Object)</code>.</p> <p>Why then is overriding important?  Why not just leave out the line <code>@Override</code> and live with the non-overriding, one-line, <code>equals</code> method above?  Keep this question in mind as this will be answered when we discuss dynamic binding.</p> <p>Why is it called Narrowing?</p> <p>Because the subclass inherits from superclass, it may seem like the subclass has \"more\" properties.  So it seems counter-intuitive why such conversion is called narrowing.  Take, for instance, <code>Circle</code> and <code>ColoredCircle</code>.  <code>ColoredCircle</code> has an additional property called <code>color</code>.  So why converting from <code>Circle</code> to <code>ColoredCircle</code> is called narrowing?</p> <p>The reason here is that a <code>ColoredCircle</code> is a <code>Circle</code> but the opposite is not true (i.e., <code>Circle</code> is not <code>ColoredCircle</code>).  Consider adding another class <code>SpinningCircle</code> such that <code>SpinningCircle</code> &lt;: <code>Circle</code>.  Then, <code>Circle</code> contains all possible <code>Circle</code> + all possible <code>ColoredCircle</code> + all possible <code>SpinningCircle</code>.  On the other hand, <code>SpinningCircle</code> only contains all possible <code>SpinningCircle</code>.</p> <p>We can see that the possible values for <code>Circle</code> is larger than the possible values for <code>SpinningCircler</code>.  So converting from <code>Circle</code> to <code>SpinningCircle</code> will indeed narrow down our possible value.</p>"},{"location":"14-polymorphism.html#the-power-of-polymorphism","title":"The Power of Polymorphism","text":"<p>Let's consider the following example.  Suppose we have a general <code>contains</code> method that takes in an array of objects.  The array can store any type of objects: <code>Circle</code>, <code>Square</code>, <code>Rectangle</code>, <code>Point</code>, <code>String</code>, etc.  The method <code>contains</code> also takes in a target <code>obj</code> to search for, and returns true if there is an object in <code>array</code> that equals to <code>obj</code>.</p> contains v0.1<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>With overriding and polymorphism, the magic happens in Line 4 -- depending on the run-time type of <code>curr</code>, the corresponding, customized version of <code>equals</code> is called to compare against <code>obj</code>.  So if the run-time type of <code>curr</code> is <code>Circle</code>, then we will invoke <code>Circle::equals(Object)</code> and if the run-time type of <code>curr</code> is <code>Point</code>, then we will invoke <code>Point::equals(Object)</code>.  This, of course, assumes that <code>Object::equals(Object)</code> is overridden in both classes.</p> <p>However, if <code>Circle::equals</code> takes in a <code>Circle</code> as the parameter (i.e., <code>Circle::equals(Circle)</code>), the call to <code>equals</code> inside the method <code>contains</code> would not invoke <code>Circle::equals(Circle)</code>.  It would invoke <code>Object::equals(Object)</code> instead due to the matching method signature, and we can't search for <code>Circle</code> based on semantic equality.</p> <p>But why are we searching for <code>equals(Object)</code> in the first place?  Look closely at how the method is invoked: <code>curr.equals(obj)</code>.  Here, we can see that the parameter we are passing is <code>obj</code>.  The compile-time type of <code>obj</code> is <code>Object</code> as seen from the parameter declaration at Line 2.  So at compile-time, we only know that its type is <code>Object</code>.</p> <p>To have a generic <code>contains</code> method without polymorphism and overriding, we will have to do something like this:</p> contains v0.2<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (obj instanceof Circle) {\n      if (curr.equals((Circle)obj)) {\n        return true;\n      }\n    } else if (obj instanceof Square) {\n      if (curr.equals((Square)obj)) {\n        return true;\n      }\n    } else if (obj instanceof Point) {\n      if (curr.equals((Point)obj)) {\n        return true;\n      }\n    }\n     :\n  }\n  return false;\n}\n</code></pre> <p>which is not scalable since every time we add a new class, we have to come back to this method and add a new branch to the <code>if-else</code> statement!</p> <p>As this example has shown, polymorphism allows us to write succinct code that is future-proof.  By dynamically deciding which method implementation to execute during run-time, the implementer can write short yet very general code that works for existing classes as well as new classes that might be added in the future by the client, without even the need to re-compile!</p> <p>Java Array</p> <p>Note that there are two ways to declare an array in Java:</p> <ol> <li><code>Type[] var</code></li> <li><code>Type var[]</code> (i.e., C-style array)</li> </ol> <p>Please follow the first style as it will be less confusing.  That is also the preferred style based on our style guide.</p> <p>The next point will be important later when we talk about variance of types.  When we declare a class in Java like the class <code>A</code> below:</p> <pre><code>class A { .. }\n</code></pre> <p>Another class is also created corresponding to the type of array of type <code>A</code>.  The name given by Java internally is <code>[LA;</code>.  Notice how the name is not a valid name in Java, so you cannot create such a class by yourself.  This class has a field called <code>length</code> which is the number of element the array instance may contain.  This should hopefully explains why to get the number of elements in an array, we use <code>arr.length</code> and not <code>arr.length()</code> because it is a field and not a method.</p> <pre><code>class [LA; { .. } // but not a legal name\n</code></pre> <p>The more interesting thing is when you declare a subtype of class <code>A</code> such as the class <code>B</code> below:</p> <pre><code>class B extends A { .. }\n</code></pre> <p>The type of array of type <code>B</code> (i.e., <code>[LB;</code>) is automatically created such that <code>[LB;</code> is a subtype of <code>[LA;</code>.  In other words,</p> <pre><code>class [LB; extends [LA; { .. } // still not a legal name\n</code></pre> <p> Implications: </p> <ul> <li> Since array type is just a class, it is a subtype of <code>Object</code>. </li> <li> It is created in the bytecode using the bytecode instruction <code>anewarray</code> in JVM.  The details are irrelevant, but it behaves as if such a class <code>[LA;</code> has been created before following covariant rule. </li> <li> Multi-dimensional array are created differently as no such class are created.  Instead, a class is constructed when the bytecode instruction <code>multinewarray</code> is executed by JVM.  Covariant rule is still followed. </li> </ul> <p> What is important is to note that an array is an instance of a special class following covariant rule.  Additionally, it is still following the basic rule of being a subtype of <code>Object</code>. </p>"},{"location":"14-polymorphism.html#adding-class","title":"Adding Class","text":"<p>So to recap, one of the main benefit of polymorphism is the ability to extend your current program with new classes without without modifying what you have written before.  To make the example more explicit, imagine that the following classes are already written.</p> <pre><code>class Animal {\n  public String name() {\n    return \"Animal\";\n  }\n\n  public String sound() {\n    return \"Grrrr\";\n  }\n}\n\nclass Cow extends Animal {\n  @Override\n  public String name() {\n    return \"Cow\";\n  }\n\n  @Override\n  public String sound() {\n    return \"Moo\";\n  }\n}\n\nclass Duck extends Animal {\n  @Override\n  public String name() {\n    return \"Duck\";\n  }\n\n  @Override\n  public String sound() {\n    return \"Quack\";\n  }\n}\n</code></pre> <p>Consider the following method to sing Old MacDonald.</p> <pre><code>void sing(Animal[] animals) {\n  for(Animal animal : animals) {\n    System.out.println(\"Old MacDonald had a farm E-I-E-I-O\");\n    System.out.println(\"And on that farm he had a \" + animal.name() + \" E-I-E-I-O\");\n    System.out.println(\"With a \" + animal.sound() + \" \" + animal.sound() + \" here\");\n    System.out.println(\"and a \" + animal.sound() + \" \" + animal.sound() + \" there\");\n    System.out.println(\"Here a \" + animal.sound() + \" there a \" + animal.sound());\n    System.out.println(\"Everywhere a \" + animal.sound() + \" \" + animal.sound());\n    System.out.println(\"Old MacDonald had a farm E-I-E-I-O\");\n  }\n}\n</code></pre> <p>Now if we want to add a new animal, we simply have to create a new class that extends the <code>Animal</code> class and implements the two methods <code>name</code> and <code>sound</code>.  We do not have to modify the all the codes we have written before.</p> <pre><code>class Dog extends Animal {\n  @Override\n  public String name() {\n    return \"Dog\";\n  }\n\n  @Override\n  public String sound() {\n    return \"Woof\";\n  }\n}\n</code></pre> <p>Notice how the method <code>sing(Animal[])</code> works without modification.  Additionally, we do not have to modify all the other classes as well.  That is the power of polymorphism.</p>"},{"location":"14-polymorphism.html#adding-functionality","title":"Adding Functionality","text":"<p>There is a \"dual\" problem to adding a class and that's adding functionality.  This problem is difficult in Java.  Consider the animals above including <code>Animal</code>, <code>Cow</code>, <code>Duck</code>, and <code>Dog</code>.  Now since all animals can move but they move differently, let's add a method called <code>move()</code>.  Where should we add this method to?</p> <p>Firstly, since all animals can move, we have to add this method to the <code>Animal</code> class.  Secondly, since all animals move differently, we also have to override this method in <code>Cow</code>, <code>Duck</code>, <code>Dog</code>.  Therefore, the act of adding a single functionality requires us to modify all the relevant classes!</p> <p>In this case, we only have 4 classes, but if we have more classes, there are more places we have to changed.  This breaks the principle of abstraction.  In fact, this breaks abstraction barrier if we are not the implementer of one of the animal classes.  To make matters worse, if we forgot to override this method in one of the subclasses, we will not even get compilation error.</p> <p>Design</p> <p>Hopefully you understand the power of polymorphism as well as its limitation.  In particular, when you design your classes according to OOP principle, you should try to design it in such a way that the changes you expect are about adding classes rather than adding functionality.</p> <ol> <li> <p>If we override <code>equals(Object)</code>, we should generally override <code>hashCode()</code> as well, but let's leave that for another lesson on another day or even another course.\u00a0\u21a9</p> </li> <li> <p>The right way to compare two floating-point numbers is to take their absolute difference and check if the difference is small enough.  We are sloppy here to keep the already complicated code a bit simpler.  You shouldn't do this in your code.\u00a0\u21a9</p> </li> <li> <p>This is not the only condition where type casting is allowed. We will look at other conditions in later units.\u00a0\u21a9</p> </li> </ol>"},{"location":"15-dynamic-binding.html","title":"Unit 15: Method Invocation","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the two step process that Java uses to determine which method implementation will be executed when a method is invoked.</li> <li>understand that Class Methods do not support dynamic binding.</li> </ul>"},{"location":"15-dynamic-binding.html#how-does-dynamic-binding-work","title":"How does Dynamic Binding work?","text":"<p>We have seen that, with the power of dynamic binding and polymorphism, we can write succinct, future-proof code<sup>1</sup>.  Recall that example below, where the magic happens in Line 4.  The method invocation <code>curr.equals(obj)</code> will call the corresponding implementation of the <code>equals</code> method depending on the run-time type of <code>curr</code>.</p> contains v0.1<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>How does dynamic binding work?  To be more precise, when the method <code>equals</code> is invoked on the target <code>curr</code>, how does Java decide which method implementation is this invocation bound to?  While we have alluded to the fact that the run-time type of the target <code>curr</code> plays a role, this is not the entire story.  Recall that we may have multiple versions of <code>equals</code> due to overloading.  So, Java also needs to decide, among the overloaded <code>equals</code>, which version of <code>equals</code> this particular invocation is bound to.</p> <p>This unit elaborates on Java's decision process to resolve which method implemented in which class should be executed when a method is invoked.  This process is a two-part process.  The first occurs during compilation; the second during run time.</p>"},{"location":"15-dynamic-binding.html#during-compile-time","title":"During Compile Time","text":"<p>During compilation, Java determines the method descriptor of the method invoked, using the compile-time type of the target.  For example, in the line</p> <pre><code>curr.equals(obj)\n</code></pre> <p>above, the target <code>curr</code> has the compile-time type <code>Object</code>.</p> <p>Let's generalize the compile-time type of the target to \\(C\\).  To determine the method descriptor, the compiler first searches for all methods that are accessible and have the same name.</p> <p>In this case, if we look at the class <code>Object</code>, there is only one method called <code>equals</code>. Additionally, <code>Object</code> does not have a superclass, so <code>boolean equals(Object)</code> is the only accessible methods with the name <code>equals</code>.</p> <p>If there is none, then the compiler throws an error. Otherwise, the compiler checks for compatible methods. By compatible, we mean all methods that can be correctly invoked on the given argument.</p> <p>In the example above, the method can be correctly invoked with one argument of type <code>Object</code>.</p> <p>What if there are multiple methods that can correctly accept the argument?  In this case, we choose the most specific one.</p> <p>More Specific</p> <p>Intuitively, a method \\(M\\) is more specific than method \\(N\\) if the arguments to \\(M\\) can be passed to \\(N\\) without compilation error.</p> <p>For example, let's say a class <code>Circle</code> implements:</p> <pre><code>boolean equals(Circle c) { .. }\n\n@Override\nboolean equals(Object c) { .. }\n</code></pre> <p>Then, <code>equals(Circle)</code> is more specific than <code>equals(Object)</code>.  Every <code>Circle</code> is an <code>Object</code>, but not every <code>Object</code> is a <code>Circle</code>.  Let's try to understand this using our definition of \"more specific\" above.</p> <p>Consider the second part of the definition, \"if the arguments to \\(M\\) can be passed to \\(N\\) without compilation error\", we need to find what arguments can be accepted by the methods we wish to compare.  In the case of <code>equals(Circle)</code>, it can accept an argument of compile-time type <code>Circle</code> (and all its subclasses), but not an argument of compile-time type <code>Object</code>.  On the other hand, <code>equals(Object)</code> can accept an argument of compile-time type <code>Object</code> and all its subclasses, including <code>Circle</code>.</p> <p>Now we simply have to test if <code>equals(Circle)</code> can accept whatever can be accepted by <code>equals(Object)</code> and vice versa.  So we test <code>equals(Circle)</code> and attempt to pass <code>Object</code> and <code>Circle</code> as argument (since <code>equals(Object)</code> can accept both <code>Object</code> and <code>Circle</code>).  It will pass on <code>Circle</code> but it will fail on <code>Object</code>.</p> <p>Similarly, we test <code>equals(Object)</code> and attempt to pass <code>Circle</code> (since <code>equals(Circle)</code> can only accept <code>Circle</code>).  There is definitely no compilation error here.  So now we have seen that if we set \\(M\\) as the method <code>equals(Circle)</code> and \\(N\\) as <code>equals(Object)</code>,</p> <p>the arguments to \\(M\\) (i.e., <code>equals(Circle)</code>, the argument is <code>Circle</code>) can be passed to \\(N\\) (i.e., <code>equals(Object)</code> can accept <code>Circle</code>) without compilation error.</p> <p>Therefore, <code>equals(Circle)</code> is more specific than <code>equals(Object)</code>.</p> <p>There is a possibility that comparing only two methods, none of the two methods is more specific than the other. For instance, given <code>S1</code> &lt;: <code>T</code> and <code>S2</code> &lt;: <code>T</code>, <code>foo(S1)</code> is not more specific than <code>foo(S2)</code> and <code>foo(S2)</code> is not more specific than <code>foo(S1)</code>.  If the Java compiler fails to determine a single most specific method, it will throw a compilation error.</p> <p>Otherwise, once the Java compiler determines the most specific method, it stores the method's descriptor (return type and signature) in the generated bytecode.</p> <p>In the example above, the method descriptor <code>boolean equals(Object)</code> will be stored in the generated binaries.  Note that it does not include information about the class that implements this method.  The class to take this method implementation from will be determined in Step 2 during run-time.</p>"},{"location":"15-dynamic-binding.html#during-run-time","title":"During Run Time","text":"<p>During execution, when a method is invoked, the method descriptor from Step 1 is first retrieved.  Then, the run-time type of the target is determined.</p> <p>Let the run-time type of the target be \\(R\\).  Java then looks for an accessible method with the matching descriptor in \\(R\\).  If no such method is found, the search will continue up the class hierarchy, first to the parent class of \\(R\\), then to the grand-parent class of \\(R\\), and so on, until we reach the root <code>Object</code>.  The first method implementation with a matching method descriptor found will be the one executed.</p> <p>Matching Method</p> <p>A method \\(M\\) matches the method \\(N\\) if they have the same method signature and the returns type of \\(M\\) is a subtype of the method \\(N\\). Recap that \\(T\\) &lt;: \\(T\\).</p> <p>For example, let's consider again the invocation in the highlighted line below again:</p> contains v0.1<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>Let's say that <code>curr</code> points to a <code>Circle</code> object during run-time.  Suppose that the <code>Circle</code> class does not override the method <code>equals</code> in <code>Object</code>.  As a result, Java can't find a matching method descriptor <code>boolean equals(Object)</code> in the method <code>Circle</code>.  It then looks for the method in the parent of <code>Circle</code>, which is the class <code>Object</code>.  It finds the method <code>Object::equals(Object)</code> with a matching descriptor.  Thus, the method <code>Object::equals(Object)</code> is executed.</p> <p>Now, suppose that <code>Circle</code> overrides the method <code>Object::equals(Object)</code> with its own <code>Circle::equals(Object)</code> method.  Since Java starts searching from the class <code>Circle</code>, it finds the method <code>Circle::equals(Object)</code> that matches the descriptor.  In this case, <code>curr.target(obj)</code> will invoke the method <code>Circle::equals(Object)</code> instead.</p> Steps <p>The information above may be difficult to parse and understand.  So let's try to distill its essence into actionable steps.  In this example, we want to figure out the method invoked on <code>obj.foo(arg)</code>.</p>"},{"location":"15-dynamic-binding.html#compile-time-step","title":"Compile-Time Step","text":"<ol> <li>Determine the compile-time type of <code>obj</code> (i.e., <code>CTT(obj)</code>).</li> <li>Determine the compile-time type of <code>arg</code> (i.e., <code>CTT(arg)</code>).</li> <li>Determine all the methods with the name <code>foo</code> that are accessible in <code>CTT(obj)</code>.<ul> <li>This includes the parent of <code>CTT(obj)</code>, grand-parent of <code>CTT(obj)</code>, and so on.</li> <li>The access modifiers are appropriate.</li> </ul> </li> <li>Determine all the methods from Step 3 that are compatible with <code>CTT(arg)</code>.<ul> <li>Correct number of parameters.</li> <li>Correct parameter types (i.e., supertype of <code>CTT(arg)</code>).</li> </ul> </li> <li>Determine the most specific method from Step 4.<ul> <li>If there is no most specific method, fail with compilation error.</li> <li>Otherwise, record the method descriptor.</li> </ul> </li> </ol>"},{"location":"15-dynamic-binding.html#run-time-step","title":"Run-Time Step","text":"<ol> <li>Retrieve the method descriptor obtained from compile-time step.</li> <li>Determine the run-time type of <code>obj</code> (i.e., <code>RTT(obj)</code>).</li> <li>Starting from <code>RTT(obj)</code>, find the first method that match the method descriptor as retrieved from Step 1.<ul> <li>If not found, check in the parent of <code>RTT(obj)</code>.</li> <li>If not found, check in the grand-parent of <code>RTT(obj)</code>.</li> <li>:</li> <li>If not found, check in the root <code>Object</code>.</li> <li>If not found, run-time error.</li> </ul> </li> </ol> <p>To see the steps in action, please follow the examples below.</p> Example <p>Although the steps above are actionable, it is still instructive to at least see how the steps are carried out.  We will be using the following classes in our example.</p> <pre><code>class U {\n  void foo(T t) { }\n  void foo(U u1, U u2) { }\n}\n\nclass T extends U {\n  void foo(S s) { }\n}\n\nclass S extends T {\n  void foo(U u) { }\n}\n</code></pre> <p>Consider the following variables.</p> <pre><code>U u = new T();\nS s = new S();\n</code></pre> <p>In the last example, we will also show a tabular method that simplifies the steps.</p> u.foo(s)u.foo(u)s.foo(s)s.foo(s) Tabular <p>Hopefully the 3 examples above are informative.  We cannot cover all possibilities but the steps should provide guidance on what to do when new situation arise.  In recitation we will connect this with class diagram so that we can understand the steps visually.</p>"},{"location":"15-dynamic-binding.html#compile-time-step_1","title":"Compile-Time Step","text":"<ol> <li><code>CTT(obj)</code> = <code>U</code></li> <li><code>CTT(arg)</code> = <code>S</code></li> <li><code>foo</code> includes <code>foo(T)</code>, <code>foo(U, U)</code></li> <li><code>S</code> can be accepted by <code>foo(T)</code></li> <li>The most specific is <code>void foo(T)</code></li> </ol>"},{"location":"15-dynamic-binding.html#run-time-step_1","title":"Run-Time Step","text":"<ol> <li>Descriptor = <code>void foo(T)</code></li> <li><code>RTT(obj)</code> = <code>T</code></li> <li>Check method from <code>T</code><ul> <li><code>void T::foo(T)</code> </li> <li><code>void U::foo(T)</code> </li> </ul> </li> </ol>"},{"location":"15-dynamic-binding.html#compile-time-step_2","title":"Compile-Time Step","text":"<ol> <li><code>CTT(obj)</code> = <code>U</code></li> <li><code>CTT(arg)</code> = <code>U</code></li> <li><code>foo</code> includes <code>foo(T)</code>, <code>foo(U, U)</code></li> <li><code>U</code> cannot be accepted by any method from Step 3.</li> </ol> <p>Compilation-Error</p>"},{"location":"15-dynamic-binding.html#compile-time-step_3","title":"Compile-Time Step","text":"<ol> <li><code>CTT(obj)</code> = <code>S</code></li> <li><code>CTT(arg)</code> = <code>S</code></li> <li><code>foo</code> includes <code>foo(U)</code>, <code>foo(S)</code>, <code>foo(T)</code>, <code>foo(U, U)</code></li> <li><code>S</code> can be accepted by <code>foo(U)</code>, <code>foo(S)</code>, <code>foo(T)</code></li> <li>The most specific is <code>void foo(S)</code></li> </ol>"},{"location":"15-dynamic-binding.html#run-time-step_2","title":"Run-Time Step","text":"<ol> <li>Descriptor = <code>void foo(S)</code></li> <li><code>RTT(obj)</code> = <code>S</code></li> <li>Check method from <code>S</code><ul> <li><code>void S::foo(S)</code> </li> <li><code>void T::foo(S)</code> </li> </ul> </li> </ol>"},{"location":"15-dynamic-binding.html#compile-time-step_4","title":"Compile-Time Step","text":"<code>foo</code> Accept <code>foo(S)</code> Most specific <code>foo(U)</code> <code>foo(S)</code> <code>foo(T)</code> <code>foo(U, U)</code> - (can be ignored)"},{"location":"15-dynamic-binding.html#run-time-step_3","title":"Run-Time Step","text":"Class Has <code>void foo(S)</code>? <code>S</code> <code>T</code> <code>U</code> - (can be ignored)"},{"location":"15-dynamic-binding.html#invocation-of-class-methods","title":"Invocation of Class Methods","text":"<p>The description above applies to instance methods.  Class methods, on the other hand, do not support dynamic binding.  The method to invoke is resolved statically during compile time.  The same process in Step 1 is taken, but the corresponding method implementation in class \\(C\\) will always be executed during run-time, without considering the run-time type of the target.</p> <p>Bad Practice</p> <p>To show that invocation of class methods is not via dynamic binding, we have to use example that are basically frowned upon.  Do not follow this bad practice in your coding.</p> <pre><code>class T {\n  static int f() {\n    return 1;\n  }\n}\n\nclass S extends T {\n  static int f() {\n    return 2;\n  }\n}\n</code></pre> <p>Typically, we will invoke the static method <code>f</code> using either <code>T.f()</code> or <code>S.f()</code>.  Unfortunately, to show that invocation of class method is using static binding, we have to use the instance rather than the class.  Which leads us to the unorthodox code snippet below.</p> <pre><code>T t = new S(); // compile-time type is T, run-time type is S\nSystem.out.println(t.f()); // what is the expected result?\n</code></pre> <ol> <li> <p>Unless the future requires us to add functionality to every single classes.\u00a0\u21a9</p> </li> </ol>"},{"location":"16-lsp.html","title":"Unit 16: Liskov Substitution Principle","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the type of bugs that reckless developers can introduce when using inheritance and polymorphism.</li> <li>understand the Liskov Substitution Principle and thus be aware that not all IS-A relationships should be modeled with inheritance.</li> <li>know how to explicitly disallow inheritance when writing a class or disallow overriding with the <code>final</code> keyword.</li> </ul>"},{"location":"16-lsp.html#the-responsibility-when-using-inheritance","title":"The Responsibility When Using Inheritance","text":"<p>As you have seen in Unit 14, polymorphism is a powerful tool that allows a client to change the behavior of existing code written by the implementer, behind the abstraction barrier.</p> <p>As Ben Parker (aka Uncle Ben) said, \"With great power, comes great responsibility.\"   The client must use overriding and inheritance carefully.  Since they can affect how existing code behaves, they can easily break existing code and introduce bugs.  Since the client may not have access to the existing code behind the abstraction barrier, it is often tricky to trace and debug.  Furthermore, the implementer would not appreciate it if their code was working perfectly until one day, someone overriding a method causes their code to fail, even without the implementer changing anything in their code.</p> <p>Ensuring this responsibility cannot be done by the compiler, unfortunately.  It thus becomes a developer's responsibility to ensure that any inheritance with method overriding does not introduce bugs to existing code.  This brings us to the Liskov Substitution Principle (LSP), which says:</p> <p>Liskov Substitution Principle</p> <p>\"Let \\(\\phi(x)\\) be a property provable about objects \\(x\\) of type \\(T\\). Then \\(\\phi(y)\\) should be true for objects \\(y\\) of type \\(S\\) where \\(S &lt;: T\\).\"</p> <p>Barbara Liskov</p> <p>This is consistent with the definition of subtyping, \\(S &lt;: T\\), but spelled out more formally.  We can use many ways to specify the desirable property but the most common is the use of program specification.</p> <p>Example #1: Module</p> <p>Specification</p> <p>We define a class called <code>Module</code> with a method <code>Module::marksToGrade</code>.  The desirable property of this method is that it takes in a <code>double</code> as input and returns a character (i.e., of type <code>char</code>).  The character that are returned is one of the following: <code>'A'</code>, <code>'B'</code>, <code>'C'</code>, or <code>'F'</code>.  How the method <code>Module::marksToGrade</code> is implemented is irrelevant as long as it returns one of the characters above.</p> <p>Usage</p> <pre><code>void displayGrade(Module m, double marks) {\n  char grade = m.marksToGrade(marks);\n  if (grade == 'A')) {\n    System.out.println(\"well done\");\n  } else if (grade == 'B') {\n    System.out.println(\"good\");\n  } else if (grade == 'C') {\n    System.out.println(\"ok\");\n  } else {\n    System.out.println(\"retake again\");\n  }\n}\n</code></pre> <p>Subclass</p> <p>Consider a subclass of <code>Module</code> called <code>CSCUModule</code>.  <code>CSCUModule</code> overrides <code>marksToGrade</code> method such that it now returns only <code>'S'</code> or <code>'U'</code>.  Does this violates LSP?</p> <p>Since <code>CSCUModule</code> is a subclass of <code>Module</code>, we can pass an instance to <code>displayGrade</code>:</p> <pre><code>displayGrade(new CSCUModule(\"GEQ1000\", 100));\n</code></pre> <p>and suddenly <code>displayGrade</code> is displaying <code>retake again</code> even if the student is scoring 100 marks.</p> <p>The example above shows that we may be violating the LSP unintentionally.  The object <code>m</code> has the following property: <code>m.marksToGrade</code> always returns something from the set { <code>'A'</code>, <code>'B'</code>, <code>'C'</code>, <code>'F'</code> }, that the method <code>displayGrade</code> depends on explicitly.  The subclass <code>CSCUModule</code> violated that and makes <code>m.marksToGrade</code> returns <code>'S'</code> or <code>'U'</code>, sabotaging <code>displayGrade</code> and causing it to fail.</p> <p>LSP cannot be enforced by the compiler<sup>1</sup>. The properties of an object have to be managed and agreed upon among programmers.  A common way is to document these properties as part of the code documentation.</p>"},{"location":"16-lsp.html#lsp-through-the-lens-of-testing","title":"LSP Through the Lens of Testing","text":"<p>Another way to develop an intuition of the LSP is through the lens of testing. When we write a method, we may want to introduce test cases to check that our method is working correctly. These test cases are designed based on the specification of our method and not its implementation details<sup>2</sup>. That is, we test based on the expected inputs and resultant outputs.</p> <p>Example #2: Restaurant</p> <p>Specification</p> <p>We would like to model a restaurant booking system for a restaurant chain. Every restaurant in the chain opens at 12 pm and closes at 10 pm, and has a singular method <code>canMakeReservation</code> which allows us to check if the restaurant is available for reservations at a certain <code>time</code>.  The requirement given is that, the system must be able to process a reservation during its opening hours.  On the other hand, we do not care about the behavior outside of the opening hour.</p> <p>We may then arrive at the following class:</p> <pre><code>public class Restaurant {\n  public static final int OPENING_HOUR = 1200;\n  public static final int CLOSING_HOUR = 2200;\n\n  public boolean canMakeReservation(int time) {\n    if (time &lt;= CLOSING_HOUR &amp;&amp; time &gt;= OPENING_HOUR) {\n      return true;\n    }\n    return false;\n  }\n}\n</code></pre> <p>Usage (i.e., Test)</p> <p>The method <code>canMakeReservation</code> returns <code>true</code> when the argument passed in to <code>time</code> is between 12 pm and 10 pm. Let's think about how we would test this method.  Two important edge cases to test is to check if the method returns true for the stated restaurant opening and closing hours.</p> <pre><code>Restaurant r = new Restaurant();\nr.canMakeReservation(1200) == true; // Is true, therefore test passes\n  : // test for other hours between 1200 - 2200\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n</code></pre> <p>Note that these are simple <code>jshell</code> tests, in software engineering modules (e.g., CS2103/T) you will learn better ways to design and formalise these tests.</p> <p>Subclass #1</p> <p>Consider a subclass of <code>Restaurant</code> called <code>LunchRestaurant</code> with the following implementation:</p> <pre><code>public class LunchRestaurant extends Restaurant {\n  private final int peakHourStart = 1200;\n  private final int peakHourEnd = 1400;\n\n  @Override\n  public boolean canMakeReservation(int time) {\n    if (time &lt;= peakHourEnd &amp;&amp; time &gt;= peakHourStart) {\n      return false;\n    } else if (time &lt;= CLOSING_HOUR &amp;&amp; time &gt;= OPENING_HOUR) {\n      return true;\n    }\n    return false;\n  }\n}\n</code></pre> <p><code>LunchRestaurant</code> does not take reservation during peak hours (i.e., 1200 to 1400).  As <code>LunchRestaurant</code> \\(&lt;:\\) <code>Restaurant</code>, we can point our variable <code>r</code> to a new instance of <code>LunchRestaurant</code> and run the test cases of the parent class, as can be seen in the code below.</p> <pre><code>Restaurant r = new LunchRestaurant();\nr.canMakeReservation(1200) == true; // Is false, therefore test fails\n  : // test for other hours between 1200 - 2200\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n</code></pre> <p>Whilst the second test passes, the first test does not since it falls within the peak lunch hour.  Therefore <code>LunchRestaurant</code> is not substitutable for <code>Restaurant</code> and the LSP is violated.  We have changed the expectation of the method in the child class.</p> <p>Subclass #2</p> <p>Let's suppose the restaurant chain starts to roll out online reservation system for a subset of its restaurants.  These restaurants can take reservations any time.  We create a subclass <code>DigitalReadyRestaurant</code>, as follows:</p> <pre><code>public class DigitalReadyRestaurant extends Restaurant {\n\n  @Override\n  public boolean canMakeReservation(int time) {\n    return true;\n  }\n}\n</code></pre> <p>Similarly, as <code>DigitalReadyRestaurant</code> \\(&lt;:\\) <code>Restaurant</code>, we can point our variable <code>r</code> to a new instance of <code>DigitalReadyRestaurant</code> and run the test cases of the parent class, as can be seen in the code below.</p> <pre><code>Restaurant r = new DigitalReadyRestaurant();\nr.canMakeReservation(1200) == true; // Is true, therefore test passes\n  : // test for other hours between 1200 - 2200\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n</code></pre> <p>Both test cases pass.  In fact, all test cases that pass for <code>Restaurant</code> would pass for <code>DigitalReadyRestaurant</code>.  Therefore <code>DigitalReadyRestaurant</code> is substitutable for <code>Restaurant</code>. Anywhere we can use an object of type <code>Restaurant</code>, we can use <code>DigitalReadyRestaurant</code> without breaking any previously written code.</p> <p>We can now rephrase our LSP in terms of testing. A subclass should not break the expectations set by the superclass. If a class <code>B</code> is substitutable for a parent class <code>A</code> then it should be able to pass all test cases of the parent class <code>A</code>. If it does not, then it is not substitutable and the LSP is violated. </p>"},{"location":"16-lsp.html#preventing-inheritance-and-method-overriding","title":"Preventing Inheritance and Method Overriding","text":"<p>Sometimes, it is useful for a developer to explicitly prevent a class to be inherited.  Not allowing inheritance would make it much easier to argue for the correctness of programs, something that is important when it comes to writing secure programs.  Both the two java classes you have seen, <code>java.lang.Math</code> and <code>java.lang.String</code>, cannot be inherited from.  In Java, we use the keyword <code>final</code> when declaring a class to tell Java that we ban this class from being inherited.</p> <p>For example, to prevent <code>Circle</code> from being inherited, </p> <pre><code>final class Circle {\n    :\n}\n</code></pre> <p>Alternatively, we can allow inheritance but still prevent a specific method from being overridden, by declaring a method as <code>final</code>.  Usually, we do this on methods that are critical for the correctness of the class.</p> <p>For instance, to prevent <code>contains</code> from being overridden,  <pre><code>class Circle {\n    :\n  public final boolean contains(Point p) {\n      :\n  }\n}\n</code></pre></p> <p>In short, we have learnt that the <code>final</code> keyword can be used in three places:</p> <ol> <li>In a class declaration to prevent inheritance.</li> <li>In a method declaration to prevent overriding.</li> <li>In a field declaration to prevent re-assignment.</li> </ol> Prevent InheritancePrevent OverridingPrevent Re-Assignment <p>Code</p> <pre><code>final class Circle {\n    :\n}\n</code></pre> <p>Test</p> <pre><code>class ColoredCircle extends Circle {\n    :\n}\n</code></pre> <p>Error Message</p> <pre><code>_.java:_: error: cannot inherit from final Circle\nclass ColoredCircle extends Circle {}\n                            ^\n1 error\n</code></pre> <p>Note</p> <p>Preventing inheritance also prevents overriding.</p> <p>Code</p> <pre><code>class Circle {\n    :\n  public final boolean contains(Point p) {\n      :\n  }\n}\n</code></pre> <p>Test</p> <pre><code>class ColoredCircle extends Circle {\n    :\n  @Override\n  public final boolean contains(Point p) {\n      :\n  }\n}\n</code></pre> <p>Error Message</p> <pre><code>_.java:_: error: contains(Point) in ColoredCircle cannot override contains(Point) in Circle\n    public boolean contains(Point p) {\n                   ^\n  overridden method is final\n1 error\n</code></pre> <p>Code &amp; Test</p> <pre><code>class Circle { \n  private Point c;\n  private final double r;\n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r; // this is ok\n  }\n\n  public void setR(double r) {\n    this.r = r; // this is re-assignment\n  }\n}\n</code></pre> <p>Error Message</p> <pre><code>_.java:_: error: cannot assign a value to final variable r\n        this.r = r;\n            ^\n1 error\n</code></pre> <p>Note</p> <p>The check if an assignment is the first assignment or a re-assignment may produce false positive.  In general, if the assignment to the field is done in the constructor, then it is allowed unless the field has already been initialized before (e.g., <code>private final double r = 0.0;</code>).  This is because a constructor can only be called once for each instance.</p> <p>On the other hand, if we have an assignment to a field not on the constructor like in the mutator, we cannot guarantee such a mutator will only be invoked exactly once.  Therefore, there is a possibility that there is a re-assignment.  The choice is to either prevent compilation or give a runtime error during the re-assignment.  Since compiler is our friend, they want to tell us about the problem early.</p> <ol> <li> <p>We can use <code>assert</code> to check some of the properties though.\u00a0\u21a9</p> </li> <li> <p>The test cases we are describing here are known as black-box tests and you will encounter these in later modules at NUS. We will not go into any further details in this module.\u00a0\u21a9</p> </li> </ol>"},{"location":"17-abstract.html","title":"Unit 17: Abstract Class","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be familiar with the concept of an abstract class.</li> <li>know the use of the Java keyword <code>abstract</code> and the constraints that come with it.</li> <li>understand the usefulness of defining and using an abstract class.</li> <li>understand what makes a class concrete.</li> </ul>"},{"location":"17-abstract.html#high-level-abstraction","title":"High-Level Abstraction","text":"<p>Recall that the concept of abstraction involves hiding away unnecessary complexity and details so that programmers do not have to bogged down with the nitty-gritty.  That's why we abstract a real-world object into a class with only fields and methods because we only want to focus on specific behavior of the object.  For instance, we abstract a circle into a point and a radius such that we can only check if another point is contained within the circle or not via <code>Circle::contains</code> method.  While a circle may also be transformed, as long as we do not have such methods, the behavior is not captured by our abstracted circle.</p> <p>When we code, we should, as much as possible, try to work with the higher-level abstraction, rather than the detailed version.  Following this principle would allow us to write code that is general and extensible, by taking full advantage of inheritance and polymorphism.</p> <p>Take the following example which you have seen,</p> contains v0.1<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>The function above is very general.  We do not assume and do not need to know, about the details of the items being stored or search.  All we required is that the <code>equals</code> method compared if two objects are equal.</p> <p>In contrast, someone whose mind focuses on finding a circle, might write something like this:</p> contains v0.1<pre><code>boolean contains(Circle[] array, Circle circle) {\n  for (Circle curr : array) {\n    if (curr.equals(circle)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>The version above serves the purpose, but is not general enough.  The only method used is <code>equals</code>, which <code>Circle</code> inherits/overrides from <code>Object</code> so that using <code>Circle</code> for this function is too constraining.  We can reuse this for any other subclasses of <code>Circle</code>, but not other classes.</p>"},{"location":"17-abstract.html#abstracting-circles","title":"Abstracting Circles","text":"<p>Now, let's consider the following function, which finds the largest area among the circles in a given array:</p> findLargest v0.1<pre><code>double findLargest(Circle[] array) {\n  double maxArea = 0;\n  for (Circle curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p><code>findLargest</code> suffers from the same specificity as the version 0.3 of <code>contains</code>.  It only works for <code>Circle</code> and its subclasses only.  Can we make this more general?  We cannot replace <code>Circle</code> with <code>Object</code>,</p> findLargest v0.2<pre><code>double findLargest(Object[] array) {\n  double maxArea = 0;\n  for (Object curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p>since <code>getArea</code> is not defined for a generic object (e.g., what does <code>getArea</code> of a string mean?).  </p> <p>To allow us to apply <code>findLargest</code> to a more generic object, we have to create a new type -- something more specific than <code>Object</code> that supports <code>getArea()</code>, yet more general than <code>Circle</code>.  After all, we can have a <code>Square</code> that has an area.</p>"},{"location":"17-abstract.html#shape","title":"Shape","text":"<p>Let's create a new class called <code>Shape</code>, and redefine our <code>Circle</code> class as a subclass of <code>Shape</code>. We can now create other shapes, <code>Square</code>, <code>Rectangle</code>, <code>Triangle</code>, etc, and define the <code>getArea</code> method for each of them.</p> <p>With the new <code>Shape</code> class, we can rewrite <code>findLargest</code> as:</p> findLargest v0.3<pre><code>double findLargest(Shape[] array) {\n  double maxArea = 0;\n  for (Shape curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxShape;\n}\n</code></pre> <p>This version not only works for an array of <code>Square</code>, <code>Rectangle</code>, <code>Circle</code>, etc but also an array containing multiple shapes!</p> <p>Let's actually write out our new <code>Shape</code> class: <pre><code>class Shape {\n  public double getArea() {\n    // what is an area of an unknown shape?\n  }\n}\n</code></pre></p> <p>and rewrite our <code>Circle</code>:</p> Circle v0.8<pre><code>import java.lang.Math;\n\n/**\n * A Circle object encapsulates a circle on a 2D plane.  \n */\nclass Circle extends Shape {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  @Override\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    // TODO: Left as an exercise\n    return false;\n  }\n\n  /**\n   * Return the string representation of this circle.\n   */\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n\n  /**\n   * Return true the object is the same circle (i.e., same center, same radius).\n   */\n  @Override\n  public boolean equals(Object obj) {\n    if (obj instanceof Circle) {\n      Circle circle = (Circle) obj;\n      return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n    }\n  }\n}\n</code></pre> <p>Notably, since our <code>Shape</code> is a highly abstract entity, it does not have any fields.  One question that arises is, how are we going to write <code>Shape::getArea()</code>?   We cannot compute the area of a shape unless we know what sort of shape it is.  </p> <p>One solution is make <code>Shape::getArea()</code> returns 0.</p> <pre><code>class Shape {\n  public double getArea() {\n    return 0;\n  }\n}\n</code></pre> <p>This is not ideal.  It is easy for someone to inherit from <code>Shape</code>, but forget to override <code>getArea()</code>.  If this happens, then the subclass will have an area of 0.  Bugs ensue.</p> <p>As we usually do in CS2030S, we want to exploit programming language constructs and the compiler to check and catch such errors for us.</p>"},{"location":"17-abstract.html#abstract-methods-and-classes","title":"Abstract Methods and Classes","text":"<p>This brings us to the concept of abstract classes.  An abstract class in Java is a class that has been made into something so general that it cannot and should not be instantiated.  Usually, this means that one or more of its instance methods cannot be implemented without further details.</p> <p>Abstract Class</p> <p>An abstract class is a class that cannot be instantiated.  If a class has at least one abstract method, it must be declared as an abstract class with the keyword <code>abstract</code> in the class declaration.</p> <p>Note that an array of abstract class may still be created.</p> <pre><code>Shape[] shapeArr = new Shape[20];\n</code></pre> <p>The <code>Shape</code> class above makes a good abstract class since we do not have enough details to implement <code>Shape::getArea</code>.</p> <p>To declare an abstract class in Java, we add the <code>abstract</code> keyword to the <code>class</code> declaration.  To make a method abstract, we add the keyword <code>abstract</code> when we declare the method.  </p> <p>An <code>abstract</code> method cannot be implemented and therefore should not have any method body (i.e., no <code>{ .. }</code>).  Instead, it ends with a semi-colon (i.e., <code>;</code>).</p> <p>This is how we implement <code>Shape</code> as an abstract class.</p> <pre><code>abstract class Shape {\n  public abstract double getArea();\n}\n</code></pre> <p>An abstract class cannot be instantiated.  Any attempt to do so, such as:</p> <pre><code>Shape s = new Shape();\n</code></pre> <p>would result in a compilation error.</p> <pre><code>_.java:_: error: Shape is abstract; cannot be instantiated\n    Shape s = new Shape();\n              ^\n1 error\n</code></pre> <p>Note that our simple example of <code>Shape</code> only encapsulates one abstract method.  An abstract class can contain multiple fields and multiple methods.  Not all the methods have to be abstract.  As long as one of them is abstract, the class becomes abstract.  </p> <p>To illustrate this, consider <pre><code>abstract class Shape {\n  private int numOfAxesOfSymmetry ;\n\n  public boolean isSymmetric() {\n    return numOfAxesOfSymmetry &gt; 0;\n  }\n\n  abstract public double getArea();\n}\n</code></pre></p> <p><code>Shape::isSymmetric</code> is a concrete method but the class is still abstract since <code>Shape::getArea()</code> is abstract.</p> <p>Rule for Abstract Class</p> <p>Note that the rule for abstract class is not symmetric.</p> <p>A class with at least one abstract method must be declared abstract.</p> <p>On the other hand,</p> <p>An abstract class may have no abstract method.</p>"},{"location":"17-abstract.html#concrete-classes","title":"Concrete Classes","text":"<p>We call a class that is not abstract as a concrete class.  A concrete class cannot have any abstract method.  Thus, any subclass of <code>Shape</code> must override <code>getArea()</code> to supply its own implementation.</p> <p>Class Diagram (Part 5)</p> <p>The class diagram for an abstract class is simple, we simply denote the class with <code>&lt;&lt;abstract&gt;&gt;</code> to indicate that the class is abstract.  As for abstract methods, we write the method in italics.</p> <p>Consider the classes <code>Shape</code>, <code>Circle</code>, and <code>Square</code> such that:</p> <ul> <li><code>Shape</code> is an abstract class:<ul> <li>Has a single abstract method <code>double getArea()</code></li> </ul> </li> <li><code>Circle</code> is a concrete class that is a subclass of <code>Shape</code>:<ul> <li>Has two private fields: <code>Point c</code> (i.e., the center) and <code>double r</code> (i.e., the radius)</li> <li>Has two public concrete methods: <code>boolean contains(Point p)</code> and <code>double getArea()</code></li> </ul> </li> <li><code>Square</code> is a concrete class that is a subclass of <code>Shape</code>:<ul> <li>Has two private fields: <code>Point tl</code> (i.e., the top-left point) and <code>double s</code> (i.e., the sides)</li> <li>Has two public concrete methods: <code>boolean contains(Point p)</code> and <code>double getArea()</code></li> </ul> </li> </ul> <p>The class diagram looks like the following:</p> <p></p>"},{"location":"18-interface.html","title":"Unit 18: Interface","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand interface as a type for modeling \"can do\" behavior.</li> <li>understand the subtype-supertype relationship between a class and its interfaces.</li> </ul>"},{"location":"18-interface.html#modeling-behavior","title":"Modeling Behavior","text":"<p>We have seen how we can write our program using superclasses (including abstract ones) to make our code more general and flexible.  In this unit, we will kick this up one more notch and try to write something even more general, through another abstraction.</p> <p>Let's re-examine this method again:</p> findLargest v0.3<pre><code>double findLargest(Shape[] array) {\n  double maxArea = 0;\n  for (Shape curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p>Note that all that is required for this method to work, is that the type of objects in <code>array</code> supports a <code>getArea</code> method.  While <code>Shape</code> that we defined in the previous unit meets this requirement, it does not have to be.  We could pass in an array of countries or an array of HDB flats.  However, it is unnatural to model a <code>Country</code> or a <code>Flat</code> as a subclass of <code>Shape</code> (recall inheritance models the IS-A relationship so we cannot easily say that a country is a shape).</p> <p>To resolve this, we will look at an abstraction that models what can an entity do, possibly across different class hierarchies.</p>"},{"location":"18-interface.html#interface","title":"Interface","text":"<p>The abstraction to do this is called an interface.  An interface is also a type and is declared with the keyword <code>interface</code>.</p> <p>Since an interface models what an entity can do, the name usually ends with the -able suffix<sup>1</sup>.  Java Comparable is one such example.</p> <p>Now, suppose we want to create a type that supports the<code>getArea()</code> method, be it a shape, a geographical region, or a real estate property.  Let's call it <code>GetAreable</code>:</p> <pre><code>interface GetAreable {\n  public abstract double getArea();\n}\n</code></pre> <p>All methods declared in an interface are <code>public abstract</code> by default.  We could also just write:</p> <pre><code>interface GetAreable {\n  double getArea();\n}\n</code></pre> <p>Now, for every class that we wish to be able to call <code>getArea()</code> on, we tell Java that the class <code>implements</code> that particular interface.</p> <p>For instance, <pre><code>abstract class Shape implements GetAreable {\n  private int numOfAxesOfSymmetry;\n\n  public boolean isSymmetric() {\n    return numOfAxesOfSymmetry &gt; 0;\n  }\n}\n</code></pre></p> <p>The <code>Shape</code> class will now have a <code>public abstract double getArea()</code> thanks to it implementing the <code>GetAreable</code> interface.  Since <code>Shape</code> inherits the abstract <code>GetAreable::getArea()</code> method, it must be declared as an abstract class.</p> <p>We can have a concrete class implementing an interface too.</p> <pre><code>class Flat extends RealEstate implements GetAreable {\n  private int numOfRooms;\n  private String block;\n  private String street;\n  private int floor;\n  private int unit;\n\n  @Override\n  public double getArea() {\n      :\n  }\n}\n</code></pre> <p>For a class to implement an interface and be concrete, it has to override all abstract methods from the interface and provide an implementation to each, just like the example above.  Otherwise, the class becomes abstract.</p> <p>With the <code>GetAreable</code> interface, we can now make our function <code>findLargest</code> even more general.</p> findLargest v0.4<pre><code>double findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p>Class and Interface Inheritance</p> <ul> <li>A class can only extend from one superclass, but it can implement multiple interfaces.</li> <li>An interface can extend from one or more other interfaces, but an interface cannot extend from another class.</li> </ul> Extra Information <p>The rule above may seem weird considering that <code>Object</code> is the root of the class hierarchy.  Wouldn't <code>Object</code> be the supertype of all types?  But <code>Object</code> is a class, so an interface cannot inherit from <code>Object</code>.</p> <p>While it is true that interface cannot inherit from <code>Object</code>, we also have to remember that all run-time type will be a concrete class.  Therefore, all run-time type will be a subtype of <code>Object</code>.  So it follows that all type can be type casted into <code>Object</code>.</p> <p>The problem is during type checking, how can we let the compiler knows that an interface has access to all the methods from the class <code>Object</code> without actually inheriting <code>Object</code>?  The answer is by explicitly adding the method signature for the methods in <code>Object</code> when the interface has no supertype.  So in a way, we have \"inheritance\" without explicitly making it inheritance.</p>"},{"location":"18-interface.html#interface-as-supertype","title":"Interface as Supertype","text":"<p>If a class \\(C\\) implements an interface \\(I\\), \\(C &lt;: I\\).   This definition implies that a type can have multiple supertypes.</p> <p>In the example above, <code>Flat</code> &lt;: <code>GetAreable</code> and <code>Flat</code> &lt;: <code>RealEstate</code>.</p>"},{"location":"18-interface.html#casting-using-an-interface","title":"Casting using an Interface","text":"<p>Like any type in Java, it is also possible to cast a variable into an interface.  Lets consider an interface <code>I</code> and two classes <code>A</code> and <code>B</code>. Note that <code>A</code> does not implement <code>I</code></p> <pre><code>interface I {\n    :\n}\n\nclass A {\n    :\n}\n\nclass B implements I {\n    :\n}\n</code></pre> <p>Now lets, consider the following code excerpt:</p> <pre><code>I i1 = new B(); // Compiles, widening type conversion\nI i2 = (I) new A(); // Also compiles?\n</code></pre> <p>Note that even though <code>A</code> does not implement <code>I</code>, the Java compiler allows this code to compile. Contrast this with casting between classes that have no subtype relationship:</p> <pre><code>A a = (A) new B(); // Does not compile\nB a = (B) new A(); // Does not compile\n</code></pre> <p>How do we explain this? Well, the Java compiler will not let us cast, when it is provable that it won't work (e.g., casting between two classes which have no subtype relationship). However, for interfaces, there is the possibility that a subclass could implement the interface and therefore Java allows it to compile. Consider one such potential subclass <code>AI</code>:</p> <pre><code>class AI extends A implements I {\n    :\n}\n</code></pre> <p>The lesson here is that when we are using typecasting, we are telling the compiler that we know best, and therefore it will not warn us or stop us from making bad decisions. It is important to always be sure when you use an explicit typecast.  Still, the compiler being our friend may decide that we are provably wrong.  But if the compiler cannot show that we are provably wrong in the case of type casting, it will allow us to compile and add a run-time check.</p> Impure Interfaces <p>As we mentioned at the beginning of this module, it is common for software requirements, and their design, to continuously evolve.  Once we define an interface that is exposed beyond the abstraction barrier, however, it is difficult to change that interface.</p> <p>Suppose that, after we define that <code>GetAreable</code> interface, other developers in the team starts to write classes that implement this interface.  One fine day, we realized that we need to add more methods into the <code>getAreable</code>.  Perhaps we need methods <code>getAreaInSquareFeet()</code> and <code>getAreaInSquareMeter()</code> in the interface.  But, one cannot simply add these abstract methods to <code>getAreable</code>.  Otherwise, the other developers will have to change their classes to add the implementation of two methods.  Or else, their code would not compile.  Imagine how unhappy they would be!</p> <p>This is what happened to the Java language when they changed from version 7 to version 8.  The language needed to add a bunch of useful methods to standard interfaces provided by the Java library, but doing so would break existing code written in Java version 7 or before, that rely on these interfaces.</p> <p>The solution that Java came up with is the allow an interface to provide a default implementation of methods that all implementation subclasses will inherit (unless they override).  A method with default implementation is tagged with the <code>default</code> keyword.  This design leads to a less elegant situation where an <code>interface</code> has some abstract methods and some non-abstract default methods.  In CS2030S, we refer to this as impure interfaces and it is a pain to explain since it breaks our clean distinction between a class and an interface.  We prefer not to talk about it -- but it is there in Java 8 and up.</p> <p>Example</p> <p>The following example shows a potential use of impure interface.</p> <pre><code>interface Ordered {\n  boolean lessThan(Ordered o);                     // this &lt; o\n  default boolean greaterThan(Ordered o) {         // this &gt; o   --&gt;  o &lt; this\n    return o.lessThan(this);\n  }\n  default boolean greaterThanOrEqual(Ordered o) {  // this &gt;= o  --&gt;  !(this &lt; o)\n    return !this.lessThan(o);\n  }\n  default boolean lessThanOrEqual(Ordered o) {     // this &lt;= o  --&gt;  !(this &gt; o)  --&gt;  !(o &lt; this)\n    return !o.lessThan(this);\n  }\n}\n</code></pre> <p>So now, if someone implements the <code>Ordered</code> interface, they only need to override one method called <code>lessThan</code>.  Then, automatically, it has inherited the method <code>greaterThan</code>, <code>greaterThanOrEqual</code>, and <code>lessThanEqual</code>.</p>"},{"location":"18-interface.html#multiple-inheritance","title":"Multiple Inheritance","text":"<p>One of the problems that is solved by (pure) interface is the problem of multiple inheritance. Other languages such as Python allows for a class to inherit from multiple parents. This, however, poses a problem of ambiguity in the case of diamond inheritance. Consider the class diagram below.</p> <p></p> <p>Note that the class <code>U</code> has no method called <code>f</code> but it inherits it. Also note that the class diagram is not valid in Java. Consider the following method invocation.</p> <pre><code>U u = new U();\nu.f();\n</code></pre> <p>Which method is invoked? Is it <code>T1::f()</code> or is it <code>T2::f()</code>? Maybe it's both? What if we call <code>super.f()</code>? Such problem is hard to solve and it boils down to the \"convention\" used in each programming languages. Python's convention is called Method Resolution Order or MRO. We will not go into details of this, but just note that it may cause counter-intuitive outcome.</p> <p>If we are only considering pure interface in Java, then such problem cannot occur. To illustrate that, we will first consider the following class diagram.</p> <p></p> <p>At a glance, you may feel that the class diagram above exhibits all the problem of multiple inheritance. However, if you inspect it more closely, you will realize that such diagram cannot occur in Java because of the following contradiction.</p> <p>Proof by Contradiction</p> <ol> <li>Assume <code>U</code> is not abstract and it has no implementation for <code>f()</code>.</li> <li><code>U</code> implements <code>T1</code> and <code>T2</code> hence <code>U</code> &lt;: <code>T1</code> and <code>U</code> &lt;: <code>T2</code>.</li> <li>Since <code>U</code> &lt;: <code>T1</code> and <code>U</code> &lt;: <code>T2</code>, <code>U</code> inherits the abstract method <code>abstract void f()</code>.</li> <li>Since <code>U</code> does not override <code>void f()</code> from either <code>void T1::f()</code> or <code>void T2::f()</code>, <code>void f()</code> is abstract in <code>U</code>.</li> <li>Since <code>U</code> has an abstract method <code>void f()</code>, <code>U</code> must be an abstract class.</li> <li>This contradicts (1) that assumes <code>U</code> is not abstract.  Hence, either<ul> <li><code>U</code> is abstract and cannot be instantiated, or</li> <li><code>U</code> is not abstract and implements <code>void f()</code>.</li> </ul> </li> </ol> <p>Based on the reasoning above, we have two possibilities: </p> <ul> <li><code>U</code> is abstract and there is actually no problem of multiple inheritance because we cannot instantiate <code>U</code>.</li> <li><code>U</code> is not abstract and implements <code>void f()</code>.  In this case, there is no ambiguity which method is invoked because this non-abstract <code>void f()</code> is the one invoked.</li> </ul> <p>The second case can actually be represented as the following class diagram.</p> <p></p> <p>In this latest class diagram, we can also see that since <code>S</code>, <code>T1</code>, and <code>T2</code> are interfaces, they cannot be instantiated.  Consider the following code snippet.</p> <pre><code>S s = /* instantiation omitted */;\n</code></pre> <p>At compile-time, we know that <code>s</code> cannot have a run-time type of <code>S</code>, <code>T1</code>, or <code>T2</code>.  This is important because it shows that what we can instantiate are only concrete classes.  Since the run-time type of <code>s</code> will be a concret class, it means that during run-time step of dynamic binding, a concrete method will be found.</p> <p>Class Diagram (Part 6)</p> <p>Similar to abstract class, we denote interface with <code>&lt;&lt;interface&gt;&gt;</code>.  Furthermore, since all (non default) methods in the interface are public abstract methods, it is best to show them as such.  So, use <code>+</code> to indicate public method and put the name in italics to indicate that they are abstract methods.</p> <p>Also note that if a class is implementing an interface, we connect them with dashed arrow.  Without impure interface, it simplifies our search for a method implementation in the run-time step of dynamic binding.  The method implementation can only be found by following the solid arrow because the dashed arrow leads to an interface.  Since an interface cannot be a subtype of a class, it ensures that there is no method implementation across the dashed arrow.</p> <pre><code>interface GetAreable {\n  double getArea();\n}\n\nabstract class Shape implements GetAreable {\n  private int numOfAxesOfSymmetry;\n\n  public boolean isSymmetric() {\n    return numOfAxesOfSymmetry &gt; 0;\n  }\n\n  abstract double getArea();\n}\n</code></pre> <p></p> <ol> <li> <p>Although in recent Java releases, this is less common.\u00a0\u21a9</p> </li> </ol>"},{"location":"19-wrapper.html","title":"Unit 19: Wrapper Class","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be aware that Java provides wrapper classes around the primitive types.</li> <li>be aware that Java will transparently and automatically box and unbox between primitive types and their corresponding wrapper classes.</li> </ul>"},{"location":"19-wrapper.html#writing-general-code-for-primitive-types","title":"Writing General Code for Primitive Types","text":"<p>We have seen the following general code that takes in an array of <code>Object</code> objects, and searches if another object <code>obj</code> is in the given <code>array</code>.</p> contains v0.1<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>Through polymorphism and overriding of the <code>equals</code> method, we can make sure that it is general enough to work on any reference type.  But what about primitive types?  Do we need to write a separate function for each primitive type, like this?</p> contains v0.4<pre><code>boolean contains(int[] array, int obj) {\n  for (int curr : array) {\n    if (curr == obj) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre>"},{"location":"19-wrapper.html#making-primitive-types-less-primitive","title":"Making Primitive Types Less Primitive","text":"<p>Java provides wrapper classes for each of its primitive types.  A wrapper class is a class that encapsulates a type, rather than fields and methods.  The wrapper class for <code>int</code> is called <code>Integer</code>, for <code>double</code> is called <code>Double</code>, etc.  There is a wrapper class for all of the Java primitives.</p> Primitive Wrapper <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>char</code> <code>Character</code> <code>boolean</code> <code>Boolean</code> <p></p> <p>A wrapper class can be used just like every other class in Java and behave just like every other class in Java. In particular, they are reference types, their instances can be created with <code>new</code> and stored on the heap, etc. </p> <p>For instance,</p> <pre><code>Integer i = Integer.valueOf(4); // new Integer(4) is \"deprecated\"\nint j = i.intValue();\n</code></pre> <p>The code snippet above shows how we can convert a primitive <code>int</code> value to a wrapper instance <code>i</code> of type <code>Integer</code>, and how the <code>intValue</code> method can retrieve the <code>int</code> value from an <code>Integer</code> instance.  </p> <p>With the wrapper type, we can reuse our <code>contains</code> method that takes in an <code>Object</code> array as a parameter to operate on an array of integers -- we just need to pass our integers into the method in an <code>Integer</code> array instead of an <code>int</code> array.</p> <p>All primitive wrapper class objects are immutable -- once you create an object, it cannot be changed.</p>"},{"location":"19-wrapper.html#primitive-vs-wrapper","title":"Primitive vs Wrapper","text":"<p>To see the main difference between primitive types and their wrapper classes, we can look at the stack and heap diagram.  Consider the code above, the stack and heap diagram is as follows.</p> <p></p> <p>In the diagram, we do not know the name of the private field of <code>Integer</code>.  Therefore, we use the placeholder <code>_</code>.  Although we may look at the implementation to know the name, we decide to use the placeholder <code>_</code> to emphasise that it is irrelevant due to abstraction barrier.</p> <p>Now, what this means is that there are different steps taken to retrieve the value depending on whether the value comes from primitive type or from wrapper class.  In the case of primitive, we simply open the box and retrieve the value.  On the other hand, for wrapper class, we need to open the box, follow the arrow, and only then we can retrieve the value.</p>"},{"location":"19-wrapper.html#auto-boxing-and-auto-unboxing","title":"Auto-Boxing and Auto-Unboxing","text":"<p>As conversion back-and-forth between a primitive type and its wrapper class is pretty common, Java provides a feature called auto-boxing/auto-unboxing to perform type conversion between primitive type and its wrapper class.</p> <p>For instance,</p> <pre><code>Integer i = 4;\nint j = i;\n</code></pre> <p>The first statement is an example of auto-boxing, where the primitive value <code>int</code> of 4 is converted into an instance of <code>Integer</code>.  The second statement converts an instance of <code>Integer</code> back to <code>int</code> (without affecting its value of 4).</p> <p>Single Step Auto-Boxing</p> <p>An important thing about auto-boxing and auto-unboxing is that they are a single step process.  Recap from above that all wrapper class has no subtyping relationship with one another.  So the following will be an error.</p> <pre><code>Double d = 2;\n</code></pre> <pre><code>_.java:_: error: incompatible types: int cannot be converted to Double\n        Double d = 2;\n                   ^\n1 error\n</code></pre> <p>This is because <code>int</code> can only be auto-boxed into <code>Integer</code> and not <code>Double</code>.  Since the auto-boxing is a single-step process, Java cannot infer that the following conversion is actually possible: <code>int</code> \\(\\rightarrow\\) <code>double</code> \\(\\rightarrow\\) <code>Double</code>.</p> <p>On the other hand, auto-unboxing happen whenever we need to convert the wrapper class to primitive type.  This can then be followed with the usual primitive subtyping.</p> <pre><code>Integer x = 4; // auto-boxing\ndouble d = x;  // auto-unboxing + primitive subtyping\n</code></pre> <p>The code above compiles.</p>"},{"location":"19-wrapper.html#performance","title":"Performance","text":"<p>Since the wrapper classes allow us to write flexible programs, why not use them all the time and forget about primitive types?</p> <p>The answer: performance. Because using an object comes with the cost of allocating memory for the object and then cleaning up the memory after we have finished using the object, it is less efficient than primitive types.   </p> <p>Consider the following two programs:</p> <pre><code>Double sum = 0.0;\nfor (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n  sum += i;\n}\n</code></pre> <p>vs.</p> <pre><code>double sum = 0.0;\nfor (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n  sum += i;\n}\n</code></pre> <p>The second one can be about or even more than 2 times faster<sup>1</sup>.  The following is a sample run with the timing in milliseconds.</p> Run Using <code>Double</code> Using <code>double</code> 1 7888 ms 1860 ms 2 7763 ms 1862 ms 3 7737 ms 1864 ms 4 7733 ms 1863 ms Average 7780.25 ms 1862.25 ms <p>This makes sense if we think about it in terms of the stack/heap diagram.  When we are using wrapper class, to retrieve the value, we require at least two operations: (i) look for the variable in the stack and retrieve the value (i.e., reference to instance) and (ii) follow the reference into an instance and retrieve the value from the heap.</p> <p>On the other hand, using primitive values, we can simply retrieve the value with one operation: (i) look for the variable in the stack and retrieve the value.  That's it, there is no step (ii).</p> <p>All primitive wrapper class objects are immutable -- once you create an object, it cannot be changed. Thus, every time the sum in the first example above is updated, a new <code>Double</code> object gets created. Due to auto-boxing and auto-unboxing, the cost of creating objects becomes hidden and is often forgotten.</p> <p>The Java API in fact, provides multiple versions of the same method, one for all the reference types using <code>Object</code>, and one for each of the primitive types.  This decision leads to multiple versions of the same code, but with the benefits of better performance.  See the Arrays class for instance.</p> <ol> <li> <p>There might actually be additional optimizations performed when executing the above code multiple times (e.g., wrapping it in a method <code>f()</code> and invoking <code>f()</code> multiple times within a method_ <code>h()</code>).  It also kind of makes sense to perform this additional optimizations only when the method is invoked multiple times because the time taken to optimize this will be paid off by the increase in speed as now the benefit can be reaped multiple times!\u00a0\u21a9</p> </li> </ol>"},{"location":"20-casting.html","title":"Unit 20: Run-Time Class Mismatch","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the need for narrowing type conversion and type casting when writing code that depends on higher-level abstraction.</li> <li>understand the possibility of encountering run-time errors if typecasting is not done properly.</li> </ul>"},{"location":"20-casting.html#problem","title":"Problem","text":"<p>We have seen in Unit 18 how we can write code that is reusable and general by making our code dependent on types at a higher-level of abstraction.  Our main example is the following <code>findLargest</code> method, which takes in an array of objects that support the <code>getArea</code> method, and returns the largest area among these objects.</p> findLargest v0.4<pre><code>double findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p>The method served our purpose well, but it is NOT a very well-designed method.  Just returning the value of the largest area is not as useful as returning the object with the largest area.  Once the caller has a reference of the object, the caller can call <code>getArea</code> to find the value of the largest area.</p> <p>Let's write our <code>findLargest</code> method to find which object has the largest area instead.  </p> findLargest v0.5<pre><code>GetAreable findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  GetAreable maxObj = null;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n      maxObj = curr;\n    }\n  }\n  return maxObj;\n}\n</code></pre> <p>Let's see how <code>findLargest</code> can be used:</p> <pre><code>GetAreable[] circles = new GetAreable[] {\n  new Circle(new Point(1, 1), 2),\n  new Circle(new Point(0, 0), 5)\n};\n\nGetAreable ga = findLargest(circles);  // ok\nCircle c1 = findLargest(circles); // error\nCircle c2 = (Circle) findLargest(circles); // ok\n</code></pre> <p>The return type of <code>findLargest</code> v0.5 is now <code>GetAreable</code>.  On Line 6 above, we assign the return object with a compile-time type of <code>GetAreable</code> to <code>ga</code>, which also has <code>GetAreable</code> as its compile-time type.  Since the variable <code>ga</code> is of type <code>GetAreable</code>, however, it is not very useful.  Recall that <code>GetAreable</code> is an interface with only one method <code>getArea</code>.  We cannot use it as a circle.</p> <p>On Line 7, we try to return the return object to a variable with compile-time type <code>Circle</code>.  This line, however, causes a compile-time error.  Since <code>Circle</code> &lt;: <code>GetAreable</code>, this is a narrowing type conversion and thus is not allowed (See Unit 14).  We will have to make an explicit cast of the result to <code>Circle</code> (on Line 8).  Only with casting, our code can compile and we get a reference with a compile-time type of <code>Circle</code>.</p>"},{"location":"20-casting.html#cast-carefully","title":"Cast Carefully","text":"<p>Typecasting, as we did in Line 8 above, is basically is a way for programmers to ask the compiler to trust that the object returned by <code>findLargest</code> has a run-time type of <code>Circle</code> (or its subtype).</p> <p>In the snippet above, we can be sure (even prove) that the returned object from <code>findLargest</code> must have a run-time type of <code>Circle</code> since the input variable <code>circles</code> contains only <code>Circle</code> objects.</p> <p>The need to cast our returned object, however, leads to fragile code.  Since the correctness of Line 8 depends on the run-time type, the compiler cannot help us.  It is then up to the programmers to not make mistakes.</p> <p>Consider the following two snippets, which will compile perfectly, but will lead to the program crashing at run-time.</p> <pre><code>GetAreable[] circles = new GetAreable[] {\n  new Circle(new Point(1, 1), 2),\n  new Square(new Point(1, 1), 5)\n};\n\nCircle c2 = (Circle) findLargest(circles);\n</code></pre> <p>Or</p> <pre><code>GetAreable[] circles = new GetAreable[] {\n  new Circle(new Point(1, 1), 2),\n  new Circle(new Point(1, 1), 5)\n};\n\nSquare sq = (Square) findLargest(circles);\n</code></pre> <p>We will see how to resolve this problem in later units.</p>"},{"location":"20-casting.html#type-case-checks","title":"Type Case Checks","text":"<p>Although type casting is like telling the compiler that we -- the programmer -- know better, some cases are really indefensible that the compiler will know immediately that it is wrong.  The checks done during type casting in Java can be classified into two parts: compile-time check and run-time check.</p> <p>We consider the following statement:</p> <pre><code>a = (C) b;\n</code></pre>"},{"location":"20-casting.html#compile-time-check","title":"Compile-Time Check","text":"<p>During compile-time, the compile will perform the following checks:</p> <ol> <li>Find the compile-time type of variable <code>b</code> (denoted CTT(<code>b</code>)).</li> <li>Check if there is a \"possibility\" that the run-time type of <code>b</code> (denoted RTT(<code>b</code>)) is a subtype of <code>C</code> (i.e., RTT(<code>b</code>) &lt;: <code>C</code>).  We will explain the possibilities more later.<ul> <li>If it is impossible, then exit with compilation error.</li> <li>Otherwise, continue to step 3.</li> </ul> </li> <li>Find the compile-time type of variable <code>a</code> (denoted CTT(<code>a</code>)).</li> <li>Check if <code>C</code> is a subtype of CTT(<code>a</code>) (i.e., <code>C</code> &lt;: CTT(<code>a</code>)).<ul> <li>If it is not, then exit with compilation error.</li> <li>Otherwise, add run-time check for RTT(<code>b</code>) &lt;: <code>C</code>.</li> </ul> </li> </ol> <p>Note that step (1) and (2) is checking if the type cast operation (i.e., <code>(C) b</code>) can potentially happen or not.  Step (3) and (4) checks if the assignment (i.e., <code>a = &lt;expr&gt;;</code>) satisfies the subtyping relationship or not.  The check at step (4) is simply a check for widening.</p> <p>Possibility</p> <p>We will consider 3 cases where it is possible for RTT(<code>b</code>) to be a subtype of <code>C</code>.  There may be other cases, so you have to think about possibilities in terms of potential new classes added in the future.</p> <ol> <li>Case 1: CTT(<code>b</code>) &lt;: <code>C</code><ul> <li>This is simply widening and is always allowed.</li> <li>The use of explicit type cast is unnecessary but not incorrect.</li> </ul> </li> <li>Case 2: <code>C</code> &lt;: CTT(<code>b</code>)<ul> <li>This is narrowing and requires run-time checks.</li> <li>Consider <code>C</code> &lt;: <code>B</code>:<ul> <li>If CTT(<code>b</code>) = <code>B</code> and RTT(<code>b</code>) = <code>C</code> (or subtype of <code>C</code>), then it is allowed at run-time.</li> <li>If CTT(<code>b</code>) = <code>B</code> and RTT(<code>b</code>) = <code>B</code> (or other subtype of <code>B</code> that is not <code>C</code>), then it not allowed at run-time. Since there is a possibility, the compiler will add codes to check at run-time.</li> </ul> </li> </ul> </li> <li>Case 3: <code>C</code> is an interface<ul> <li>Let CTT(<code>b</code>) = <code>B</code>.  Then it may have a subclass <code>A</code> such that <code>A</code> &lt;: <code>C</code> (i.e., implements the interface <code>C</code>). <pre><code>class A extends B implements C { .. }\n</code></pre></li> <li>If RTT(<code>b</code>) = <code>A</code>, then it is allowed at run-time.</li> </ul> </li> </ol> <p>Impossibility</p> <p>There are certain cases where it is impossible for RTT(<code>b</code>) to be a subtype of <code>C</code>.  We will explain two cases here.</p> <ol> <li>Let CTT(<code>b</code>) = <code>B</code> and let both <code>B</code> and <code>C</code> be two unrelated classes (.e., <code>B</code> &lt;/: <code>C</code> and <code>C</code> &lt;/: <code>B</code>).<ul> <li>Then it is impossible for RTT(<code>b</code>) to be subtype of <code>C</code> because the subclass of <code>B</code> must already extends <code>B</code>.  As such, it cannot also extends from <code>C</code> as Java does not allow a class to extend from two or more classes.</li> </ul> </li> <li>Let <code>C</code> be an interface and CTT(<code>b</code>) be a class with a modifier <code>final</code>.<ul> <li>Then Case (3) on the possibility does not apply as RTT(<code>b</code>) cannot be a subtype of CTT(<code>b</code>) since there cannot a subtype in the first place.  Recap: the <code>final</code> modifier on a class prevents the class from being inherited.</li> </ul> </li> </ol>"},{"location":"20-casting.html#run-time-check","title":"Run-Time Check","text":"<p>The check at run-time is added on step (4) of compile-time check.  This is because at step (2) we are only looking for \"possibility\".  Therefore, there is a chance that such possibility did not occur at run-time.</p> <ol> <li>Find the run-time type of variable <code>b</code> (denoted RTT(<code>b</code>)).</li> <li>Check if RTT(<code>b</code>) &lt;: <code>C</code>.</li> </ol> <p>You may think of the check for the type cast <code>(C) b</code> as logically equivalent to the following</p> <pre><code>if (!(b instanceof C)) {\n  throw new ClassCastException( .. );\n}\n</code></pre> <p>Actual Casting</p> <p>Note that at run-time, there is no need to do an actual casting from one type to another.  Remember that at run-time we will be using the run-time type information.  This run-time type information does not change!</p> <p>What type casting does is to produce an expression such that the compile-time type of the value produced by the expression is now of the specific type as specified in the type cast.  Consider the following code snippet.</p> <pre><code>String str1 = \"CS2030S\";\nObject obj = s; // String &lt;: Object\nString str2 = (String) obj;\n</code></pre> <p>Here, the expression <code>(String) obj</code> produces a value with compile-time type of <code>String</code>.  This value is then assigned to <code>str2</code>.  This is allowed because <code>String</code> (from <code>(String) obj</code>) &lt;: <code>String</code> (from the compile-time type of <code>str2</code>).  Note that the compile-time type of both <code>str1</code> and <code>obj</code> are unchanged.  They are still <code>String</code> and <code>Object</code> respectively.</p> <p>These compile-time type information is needed only for compilation and is no longer needed at run-time.  So at run-time, what Java is actually doing is to check if the given run-time type is actually a subtype of the declared casted type.  This is done without changing the run-time type of the object.  However, if the check fails, then you will get a run-time error <code>ClassCastException</code>.</p>"},{"location":"21-variance.html","title":"Unit 21: Variance","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the definition of the variance of types: covariant, contravariant, and invariant.</li> <li>be aware that the Java array is covariant and how it could lead to run-time errors that cannot be caught during compile time.</li> </ul>"},{"location":"21-variance.html#motivation","title":"Motivation","text":"<p>Both the methods <code>findLargest</code> and <code>contains</code> takes in an array of reference types as parameters:</p> findLargest v0.5<pre><code>GetAreable findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  GetAreable maxObj = null;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n      maxObj = curr;\n    }\n  }\n  return maxObj;\n}\n</code></pre> contains v0.1<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>What are some possible arrays that we can pass into these methods?  Let's try this: <pre><code>Object[] objArray = new Object[] { Integer.valueOf(1), Integer.valueOf(2) };\nInteger[] intArray = new Integer[] { Integer.valueOf(1), Integer.valueOf(2) };\n\ncontains(objArray, Integer.valueOf(1)); // ok\ncontains(intArray, Integer.valueOf(1)); // ok\n</code></pre></p> <p>Line 4 is not surprising since the type for <code>objArray</code> matches that of parameter <code>array</code>.  Line 5, however, shows that it is possible to assign an instance with run-time type <code>Integer[]</code> to a variable with compile-time type <code>Object[]</code>.</p> Why Is It Possible? <p>We have explained the reason for this before and that is because for every reference type that is declared, Java automatically create an array type for that reference type such that follows the subtyping relationship of the reference type.  In this case, since <code>Integer</code> &lt;: <code>Number</code> &lt;: <code>Object</code>, Java automatically create the corresponding array types <code>[LInteger;</code> &lt;: <code>[LNumber;</code> &lt;: <code>[LObject;</code>.</p> <p>For simplicity, from this point onwards, if we have a reference type <code>T</code>, we will be using <code>T[]</code> to indicate the automatically generated array type for <code>T</code>.  Now, note that we only create the array type for reference type.  This means that for primitive type, the developer of Java language have to add special types corresponding to the array of primitive type.</p>"},{"location":"21-variance.html#variance-of-types","title":"Variance of Types","text":"<p>So far, we have established the subtype relationship between classes and interfaces based on inheritance and implementation.  The subtype relationship between complex types such as arrays, however, is not so trivial.  Let's look at some definitions.</p> <p>The variance of types refers to how the subtype relationship between complex types relates to the subtype relationship between components.</p> <p>Let \\(C(S)\\) corresponds to some complex type based on type \\(S\\).  An array of type \\(S\\) is an example of a complex type.</p> <p>We say a complex type is:</p> <ul> <li>covariant if \\(S &lt;: T\\) implies \\(C(S) &lt;: C(T)\\)</li> <li>contravariant if \\(S &lt;: T\\) implies \\(C(T) &lt;: C(S)\\)</li> <li>invariant if it is neither covariant nor contravariant.</li> </ul> <p>How to Memorize</p> <p>Think of variant as an arrow (i.e., it has direction).  Then, the word \"contra\" should evoke the feeling of \"counter\".  In other words, the direction should be in the counter (i.e., opposite) direction.  That's why for contravariant, we have \\(S &lt;: T\\) implies \\(C(S) :&gt; C(T)\\).  Of course, it is actually written as \\(C(T) &lt;: C(S)\\).</p> <p>The word \"co\" should evoke the same direction (like co-payment, co-operation, etc).  So, the direction should be in the same direction.  That's why for covariant, we have \\(S &lt;: T\\) implies \\(C(S) &lt;: C(T)\\).</p> <p>Lastly, invariant is simply neither.</p>"},{"location":"21-variance.html#java-array-is-covariant","title":"Java Array is Covariant","text":"<p>Arrays of reference types are covariant in Java<sup>1</sup>.  This means that, if \\(S &lt;: T\\), then \\(S[] &lt;: T[]\\).  </p> <p>For example, because <code>Integer</code> &lt;: <code>Object</code>, we have <code>Integer[]</code> &lt;: <code>Object[]</code> and we can do the following:</p> CodeWhat Compiler Sees <pre><code>Integer[] intArray;\nObject[] objArray;\nobjArray = intArray; // ok\n</code></pre> <pre><code>Integer[] intArray;  // intArray::Integer[]\nObject[] objArray;   // objArray::Object[]\nobjArray = intArray; // objArray::Object[]  &lt;- intArray::Integer[] (ok because Integer[] &lt;: Object[])\n</code></pre> <p>By making array covariant, however, Java opens up the possibility of run-time errors, even without typecasting!</p> <p>Consider the following code:</p> CodeWhat Compiler Sees Problematic Code<pre><code>Integer[] intArray = new Integer[2] {\n  Integer.valueOf(10), Integer.valueOf(20)\n};\nObject[] objArray;\nobjArray = intArray;\nobjArray[0] = \"Hello!\"; // &lt;- compiles!\n</code></pre> Problematic Code<pre><code>Integer[] intArray = new Integer[2] {\n  Integer.valueOf(10), Integer.valueOf(20)\n};                      // intArray::Integer[]\nObject[] objArray;      // objArray::Object[]\nobjArray = intArray;    // objArray::Object[]  &lt;- intArray::Integer[]\nobjArray[0] = \"Hello!\"; // objArray[0]::Object &lt;- \"Hello!\"::String (ok, because String &lt;: Object)\n</code></pre> <p>On Line 5 above, we set <code>objArray</code> (with a compile-time type of <code>Object[]</code>) to refer to an object with a run-time type of <code>Integer[]</code>.  This is allowed since the array is covariant.</p> <p>On Line 6, we try to put a <code>String</code> object into the <code>Object</code> array.  Since <code>String</code> &lt;: <code>Object</code>, the compiler allows this.  The compiler does not realize that at run-time, the <code>Object</code> array will refer to an array of <code>Integer</code>.  </p> <p>So we now have a perfectly compilable code, that will crash on us when it executes Line 6 -- only then would Java realize that we are trying to stuff a string into an array of integers!</p> <p>This is an example of a type system rule that is unsafe.  Since the array type is an essential part of the Java language, this rule cannot be changed without ruining existing code.  We will see later how Java avoids this pitfall for other complex types (such as a list).</p> <p>Detailed Explanation</p> <p>The \"Problematic Code\" has no compile-time error but has run-time error.</p> <ol> <li>From line 1 to 4, we know the compile-time type of two variables: <code>intArray</code> is <code>Integer[]</code> and <code>objArray</code> is <code>Object[]</code>.</li> <li>Assignment at line 5 has no compile-time error because we are assigning <code>intArray</code> of compile-time type <code>Integer[]</code> into <code>objArray</code> of compile-time type <code>Object[]</code> and <code>Integer[]</code> &lt;: <code>Object[]</code>.</li> <li>At line 6, the compile-time type of <code>objArray[0]</code> is <code>Object</code> because it is an element of <code>objArray</code> that has the type of <code>Object[]</code>.</li> <li>Assignment at line 5 has no compile-time error because we are assigning a <code>String</code> into an <code>Object</code> and <code>String</code> &lt;: <code>Object</code>.</li> <li>Hence, the code compiles without error.</li> <li>However, the run-time type of <code>objArray</code> is <code>Integer[]</code>, so the run-time type of <code>objArray[0]</code> is <code>Integer</code>.</li> <li>Hence, assignment at line 5 is assigning a <code>String</code> into an <code>Integer</code> and this causes an error because <code>String</code> &lt;/: <code>Integer</code>.</li> <li>(5) shows that there is no compile-time error while (7) shows that there is a run-time error.</li> </ol>"},{"location":"21-variance.html#producerconsumer","title":"Producer/Consumer","text":"<p>Variance is closely related to the concept of producer/consumer.  We will encounter this concept again later.  For now, we can simply introduce the following obvious definition.</p> <p>Producer</p> <p>Producer produces value.</p> <p>Consumer</p> <p>Consumer consumes value.</p> <p>We will show two different of producer/consumer.</p> Kind as Producer as Consumer Array <code>X x = arr[n];</code> <code>arr[n] = value;</code> Function <code>X x = f(arg);</code> (i.e., return value is produced) <code>f(value);</code> (i.e., argument is consumed)"},{"location":"21-variance.html#type-problems","title":"Type Problems","text":"<p>There are some type problems related to producer/consumer and variance of types.  We have seen one such example above.  Due to covariance of Java array, there are some run-time errors that cannot be detected by our compiler.  Notice that this happens when we treat the array as a consumer.  We can actually state this more generally,</p> <p>There will be some run-time errors that cannot be detected by compiler when having producer consumer covariant.</p> <p>A more general example is as follows but we will illustrate using array.  Consider <code>A1</code> &lt;: <code>B</code> and <code>A2</code> &lt;: <code>B</code>.  By covariance, <code>A[]</code>  &lt;: <code>B[]</code>.  Then the following code will not produce compilation error but will produce run-time error.</p> <pre><code>A1[] aArr = new A1[] { new A1(), new A1() };\nB[] bArr = aArr;    // assume covariant: A1[] &lt;: B[]\nbArr[0] = new A2(); // compiles because A2 &lt;: B\n                    // but this is a run-time error\n</code></pre> <p>In this case, we see that <code>bArr</code> is used as a consumer (i.e., it consumes the value of <code>new A2()</code>).</p> <p>We can also state the opposite problem.</p> <p>There will be some run-time errors that cannot be detected by compiler when having consumer producer contravariant.</p> <p>We will use the same subtyping relationship as above.  However, note that the following code is simply hypotheticals because Java array is not contravariant.</p> <pre><code>B[] bArr = new B[] { new A1(), new A2() };\nA1[] aArr = bArr;   // assume contravariant: B[] &lt;: A1[]\nA1 a1 = aArr[2];    // compiles because A1 &lt;: A1\n                    // but this is a run-time error\n</code></pre> <p>In this case, we see that <code>aArr</code> is used as a producer (i.e., it produces the value in <code>aArr[2]</code>).</p> <ol> <li> <p>Arrays of primitive types are invariant.\u00a0\u21a9</p> </li> </ol>"},{"location":"22-exception.html","title":"Unit 22: Exceptions","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand about handling java exceptions and how to use the <code>try</code>-<code>catch</code>-<code>finally</code> blocks.</li> <li>understand the hierarchy of exception classes and the difference between checked and unchecked exceptions.</li> <li>be able to create their own exceptions.</li> <li>understand the control flow of exceptions.</li> <li>be aware of good practices for exception handling.</li> </ul>"},{"location":"22-exception.html#checking-exceptions","title":"Checking Exceptions","text":"<p>One of the nuances of programming is having to write code to deal with exceptions and errors.  Consider writing a method that reads in a single integer value from a file.  Here are some things that could go wrong:</p> <ul> <li>The file to read from may not exist.</li> <li>The file to read from exists, but you may not have permission to read it.</li> <li>You can open the file for reading, but it might contain non-numeric text where you expect numerical values.</li> <li>The file might contain fewer values than expected.</li> <li>The file might become unreadable as you are reading through it (e.g., someone unplugs the USB drive).</li> </ul> <p>In C, we usually have to write code like this:</p> <pre><code>fd = fopen(filename,\"r\");\nif (fd == NULL) {\n  fprintf(stderr, \"Unable to open file.\");\n  if (errno == ENFILE) {\n    fprintf(stderr, \"Too many opened files.  Unable to open another\\n\");\n  } else if (errno == ENOENT) {\n    fprintf(stderr, \"No such file %s\\n\", filename);\n  } else if (errno == EACCES) {\n    fprintf(stderr, \"No read permission to %s\\n\", filename);\n  }\n  return -1;\n}\nscanned = fscanf(fd, \"%d\", &amp;value);\nif (scanned == 0) {\n  fprintf(stderr, \"Unable to scan for an integer\\n\");\n  fclose(fd);\n  return -2;\n}\nif (scanned == EOF) {\n  fprintf(stderr, \"No input found.\\n\");\n  fclose(fd);\n  return -3;\n}\n</code></pre> <p>Out of the lines above, only TWO lines correspond to the actual task of opening and reading in a file, the others are for exception checking/handling.  The actual tasks are interspersed between exception checking code, which makes reading and understanding the logic of the code difficult.</p> <p>The examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors. Note that the POSIX API has a global variable <code>errno</code> that signifies the detailed error. First, we have to check for different <code>errno</code> values and react accordingly (we can use <code>perror</code>, but that has its limits). Second, <code>errno</code> is global, and using a global variable is a bad practice.  In fact, the code above might not work because <code>fprintf</code> in Line 3 might have changed <code>errno</code>.</p> <p>Finally, there is the issue of having to repeatedly clean up after an error -- here we <code>fclose</code> the file if there is an error reading, twice. It is easy to forget to do so if we have to do this in multiple places.  Furthermore, if we need to perform a more complex clean up, then we would end up with lots of repeated code.</p> <p>Many modern programming languages support exceptions as a programming construct.  In Java, this is done with <code>try</code>, <code>catch</code>, <code>finally</code> keywords, and a hierarchy of <code>Exception</code> classes.  The <code>try</code>/<code>catch</code>/<code>finally</code> keywords group statements that check/handle errors together making code easier to read. The Java equivalent to the above is:</p> <pre><code>try {\n  reader = new FileReader(filename);\n  scanner = new Scanner(reader);\n  value = scanner.nextInt();\n}\ncatch (FileNotFoundException e) {\n  System.err.println(\"Unable to open \" + filename + \" \" + e);\n}\ncatch (InputMismatchException e) {\n  System.err.println(\"Unable to scan for an integer\");\n}\ncatch (NoSuchElementException e) {\n  System.err.println(\"No input found\");\n}\nfinally {\n  if (scanner != null)\n    scanner.close();\n}\n</code></pre> <p><code>if</code>-<code>else</code> vs <code>try</code>-<code>catch</code></p> <p>As much as possible, you should try checking for potential error condition using <code>if</code>-<code>else</code> as opposed to try to let it run and catch error using <code>try</code>-<code>catch</code>.  You may wonder in the case of reading file, why not just check if the file exists instead of catching <code>FileNotFoundException</code>.  Something along the line of</p> <pre><code>File f = new File(\"path/to/file\");\nif (f.exists() &amp;&amp; !f.isDirectory()) {\n  // are you sure the file still exists in between?\n  f.open();\n  // do something\n}\n</code></pre> <p>You do not need to understand the detail of the code above.  What you need to know to answer this is that your computer runs a lot of other programs.  Given the current processor capabilities, these programs may actually run at the same time.  This means that in between the check that the file exists (i.e., <code>f.exists()</code>) and what you want to do with the file (i.e., in between <code>f.exists()</code> and <code>f.open()</code>), the file may actually already be removed by another program!</p> <p>Such occurrences is rare, but we still need to safeguard against it.  The surest way to know if we can actually read a file is to actually attempt to try to read a file.</p> <p>Let's look at the example more carefully.  The general syntax for <code>try</code>-<code>catch</code>- <code>finally</code> is the following:</p> <pre><code>try {\n  // do something\n} catch (an exception parameter) {\n  // handle exception\n} finally {\n  // clean up code\n  // regardless of there is an exception or not\n}\n</code></pre>"},{"location":"22-exception.html#try-block","title":"<code>try</code> Block","text":"<p>In the example above, we have the <code>try</code> block:</p> <pre><code>try {\n  reader = new FileReader(filename);\n  scanner = new Scanner(reader);\n  value = scanner.nextInt();\n}\n  :\n</code></pre> <p>which opens the file and reads an integer from it.  Thus the main task for the code is put together in one place, making it easier to read and understand (and thus less bug-prone).</p>"},{"location":"22-exception.html#catch-block","title":"<code>catch</code> Block","text":"<p>Next we have a sequence of <code>catch</code> blocks.</p> <pre><code>  :\ncatch (FileNotFoundException e) {\n    System.err.println(\"Unable to open \" + filename + \" \" + e);\n} catch (InputMismatchException e) {\n    System.err.println(\"Unable to scan for an integer\");\n} catch (NoSuchElementException e) {\n    System.err.println(\"No input found\");\n}\n</code></pre> <p>The error handling comes under the <code>catch</code> clauses, each handling a different type of exception.  In Java, exceptions are instances that are a subtype of the <code>Exception</code> class.  Information about an exception is encapsulated in an exception instance and is \"passed\" into the <code>catch</code> block.  In the example above, <code>e</code> is the variable containing an exception instance.</p> <p>The catch blocks are checked in the order they appear in our program. The first catch block that has an exception type compatible with the type of the thrown exception (i.e., a subtype) is selected to handle the exception. This means the actual type of the exception object must be the same as, or a subclass of, the exception type specified in the catch block. Consider if we have <code>ExceptionX</code> &lt;: <code>ExceptionY</code> and we have the following <code>catch</code> block:</p> <pre><code>  :\n} catch(ExceptionY e) {\n  // handle ExceptionY\n} catch(ExceptionX e) {\n  // handle ExceptionX\n}\n  :\n</code></pre> <p>As such, we will never execute the second <code>catch</code> as <code>ExceptionX</code> will already be caught by <code>catch(ExceptionY e) { .. }</code>.  Indeed, the Java compiler will prevent this issue with a compilation error.</p> <pre><code>_.java:_: error: exception ExceptionX has already been caught\n        } catch(ExceptionX e) {\n          ^\n1 error\n</code></pre> <p>What this also means is that if you have the following <code>catch</code> block</p> <pre><code>  :\ncatch(Exception e) {\n  // handle Exception\n}\n  :\n</code></pre> <p>it will handle all exceptions!  Also, <code>catch(Exception e)</code> cannot be above other <code>catch</code> blocks that handles the subclass of <code>Exception</code>.  That rules out all exceptions<sup>1</sup>!</p> <p>Now with the exception, we no longer rely on a special return value from a function nor a global variable to indicate exceptions.</p>"},{"location":"22-exception.html#finally-block","title":"<code>finally</code> Block","text":"<p>Finally, we have the optional <code>finally</code> clause for house-keeping tasks.  Here, we close the <code>scanner</code> if it is opened.</p> <pre><code>  :\nfinally {\n  if (scanner != null)\n    scanner.close();\n}\n</code></pre> <p>In cases where the code to handle the exceptions is the same, you can avoid repetition by combining multiple exceptions into one catch statement:</p> <pre><code>catch (FileNotFoundException | InputMismatchException | NoSuchElementException e) {\n  System.err.println(e);\n}\n</code></pre> <p><code>finally</code> is ALWAYS Executed</p> <p>Note that when we say that <code>finally</code> block is always executed, we really mean that it is always executed.  In fact, the only time when <code>finally</code> is not executed is when the error is so fatal that your program cannot even recover from such error (e.g., your computer shut off or a meteor strikes your computer just before it reaches the <code>finally</code> block).</p> <p>Try the following counter-intuitive example to show that <code>finally</code> is always executed.  First, try to guess what the output is likely to be.  Then, run the code to see what the output really is.</p> <pre><code>class FinallyAlwaysExecuted {\n  public static int f() {\n    try {\n      System.out.println(1);\n      int x = 1/0;\n      System.out.println(2);\n      return 1;\n    } catch(Exception e) {\n      System.out.println(3);\n      return 2;\n    } finally {\n      System.out.println(4);\n      return 3;\n    }\n  }\n  public static void main(String[] args) {\n    System.out.println(f());\n  }\n}\n</code></pre> <p>Additionally, the <code>catch</code> block is also optional.  In particular, you may have <code>try</code>-<code>finally</code>.  In this case, you are not handling any exception but you still want to clean up any resources you have.</p> <p>If you have a <code>return</code> inside the <code>finally</code>, the exception are replaced with the return value.  However, we do not consider these exceptions as handled.  So we have a missing unhandled exception.</p>"},{"location":"22-exception.html#throwing-exceptions","title":"Throwing Exceptions","text":"<p>The <code>try</code>-<code>catch</code>-<code>finally</code> blocks above show you how to handle exceptions.  Let's see how we can throw an exception.  Let's revisit our <code>Circle</code> class.  A circle cannot have a negative radius.  Let's say that we wish our constructor to throw an <code>IllegalArgumentException</code> when a negative radius is passed in.  </p> <p>We need to do two things.  First, we need to declare that the construct is throwing an exception, with the <code>throws</code> keyword.  Second, we have to create a new <code>IllegalArgumentException</code> object and throw it to the caller with the <code>throw</code> keywords.</p> <pre><code>class Circle {\n  private Point c;\n  private double r;\n\n  public Circle(Point c, double r) throws IllegalArgumentException {\n    if (r &lt; 0) {\n      throw new IllegalArgumentException(\"radius cannot be negative.\");\n    }\n    this.c = c;\n    this.r = r;\n  }\n}\n</code></pre> <p>Note that executing the <code>throw</code> statement causes the method to immediately return.  In the example above, the initialization of the center <code>c</code> and radius <code>r</code> does not happen.</p> <p>The caller then can catch and handle this exception: <pre><code>try {\n  c = new Circle(point, radius);\n} catch (IllegalArgumentException e) {\n  System.err.println(\"Illegal arguement:\" + e.getMessage());\n}\n</code></pre></p> <p><code>throw</code> vs <code>throws</code></p> <p>The keyword <code>throws</code> is used in method declaration.  The keyword <code>throw</code> is the actual throwing of exceptions.</p>"},{"location":"22-exception.html#checked-vs-unchecked-exceptions","title":"Checked vs Unchecked Exceptions","text":"<p>Java distinguishes between two types of exceptions: unchecked and checked.</p>"},{"location":"22-exception.html#unchecked-exceptions","title":"Unchecked Exceptions","text":"<p>An unchecked exception is an exception caused by a programmer's errors.  They should not happen if perfect code is written.  <code>IllegalArgumentException</code>, <code>NullPointerException</code>, <code>ClassCastException</code> are examples of unchecked exceptions.  Generally, unchecked exceptions are not explicitly caught or thrown.  They indicate that something is wrong with the program and cause run-time errors.</p> <p>In Java, unchecked exceptions are subclasses of the class <code>RuntimeException</code>.</p>"},{"location":"22-exception.html#checked-exceptions","title":"Checked Exceptions","text":"<p>A checked exception is an exception that a programmer has no control over.  Even if the code written is perfect, such an exception might still happen.  The programmer should thus actively anticipate the exception and handle them.  For instance, when we open a file, we should anticipate that in some cases, the file cannot be opened.  <code>FileNotFoundException</code> and <code>InputMismatchException</code> are two examples of is an example of a checked exception.  A checked exception must be either handled, or else the program will not compile.</p>"},{"location":"22-exception.html#execution","title":"Execution","text":"<p>Consider the general syntax for <code>try</code>-<code>catch</code>-<code>finally</code> above.  We have two possible execution pathways assuming no error escaped.  The first possibility is that <code>// do something</code> does not have a run-time error.  The second possibility is <code>//do something</code> has a run-time error.  We call the first normal execution and the second error execution.</p> <p>There are other possibilities when we consider cases where the error escaped from the current context.  This can either be because the <code>catch</code> block does not catch the required exception or because the <code>catch</code>/<code>finally</code> block themselves have a run-time error!  As there can be too many possibilities, we restrict ourselves to cases where the error does not escape.  in \"Passing the Buck\", you will see the execution when the error escaped.</p>"},{"location":"22-exception.html#normal-execution","title":"Normal Execution","text":"<p>A normal execution is illustrated by the following flow.</p> <p></p> <p>Here, the <code>catch</code> block is not executed because there is no run-time error.  Since <code>finally</code> block is always executed, the execution continues to the <code>finally</code> block after the execution of <code>try</code> block is completed.</p>"},{"location":"22-exception.html#error-execution","title":"Error Execution","text":"<p>An error execution is illustrated by the following flow.</p> <p></p> <p>We assume that the <code>catch</code> block is catching the required exception.  We also assume that the line that causes the error is the third line (out of five lines) of <code>try</code> block.</p> <p>First note that because the error is caused by line 3, all subsequent lines in the <code>try</code> block is not executed.  Instead, the execution continues to the <code>catch</code> block.  Since we may have many possible <code>catch</code> blocks, we look one-by-one from top to bottom for the first <code>catch</code> block such that the run-time type of the exception is a subtype of the exception declared by the <code>catch</code> block.</p> <p>Next, the execution continues from the <code>catch</code> block to the <code>finally</code> block because the <code>finally</code> block is always executed.</p>"},{"location":"22-exception.html#passing-the-buck","title":"Passing the Buck","text":"<p>The caller of the method that generates (i.e., <code>new</code> and <code>throws</code>) an exception need not catch the exception.  The caller can pass the exception to its caller, and so on if the programmer deems that it is not the right place to handle it.  </p> <p>An unchecked exception, if not caught, will propagate automatically down the stack until either, it is caught or if it is not caught at all, resulting in an error message displayed to the user.</p> <p>For instance, the following toy program would result in <code>IllegalArgumentException</code> being thrown out of <code>main</code> and displayed to the user.</p> Throwing Unchecked IllegalArgumentException<pre><code>class Main {\n  static void createCircles() {\n    int radius = 10;\n    for (int i = 0; i &lt;= 11; i++) {\n      new Circle(new Point(1, 1), radius--);\n    }\n  }\n  public static void main(String[] args) {\n    createCircles();\n  }\n}\n</code></pre> <p>A checked exception, on the other hand, must be handled.  Consider the following example:</p> Checked Exception v0.1 (Compilation Error)<pre><code>class Main {\n  static FileReader openFile(String filename) {\n    return new FileReader(filename);\n  }\n  public static void main(String[] args) {\n    openFile();\n  }\n}\n</code></pre> <p>This program won't compile because the checked exception <code>FileNotFoundException</code> is not handled.  That's why it is called checked exception, because the compiler checks that the error is either handled or passed upwards the call stack.  As the example we have seen, we could handle it in <code>openFile</code>.  In this case, <code>openFile</code> does not throw any exception.</p> Checked Exception v0.2 (Handled In-Situ)<pre><code>class Main {\n  static FileReader openFile(String filename) {\n    try {\n      return new FileReader(filename);\n    } catch (FileNotFoundException e) {\n      System.err.println(\"Unable to open \" + filename + \" \" + e);\n    }\n  }\n  public static void main(String[] args) {\n    openFile();\n  }\n}\n</code></pre> <p>Alternatively, <code>openFile</code> can pass the buck to the caller instead of catching it.  </p> Checked Exception v0.3 (Passed to Caller)<pre><code>class Main {\n  static FileReader openFile(String filename) throws FileNotFoundException {\n    return new FileReader(filename);\n  }\n  public static void main(String[] args) {\n    try {\n      openFile();\n    } catch (FileNotFoundException e) {\n      // warn user and pop up dialog box to select another file.\n    }\n  }\n}\n</code></pre> <p>Sometimes the caller is a better place to handle the exception.  Where an exception should be handled is a design decision.  We will see some considerations for this later in this unit.</p> <p>What should not happen is the following:</p> Checked Exception v0.4 (Passed to User)<pre><code>class Main {\n  static FileReader openFile(String filename) throws FileNotFoundException {\n    return new FileReader(filename);\n  }\n  public static void main(String[] args) throws FileNotFoundException {\n    openFile();\n  }\n}\n</code></pre> <p>In the code above, every method passes the buck around.  No one takes the responsibility to handle it and the user ends up with the exception.  The ugly internals of the program (such as the call stack) is then revealed to the user.</p> <p>A good program always handle checked exception gracefully and hide the details from the users.</p>"},{"location":"22-exception.html#control-flow-of-exceptions","title":"Control Flow of Exceptions","text":"<p>Here is a more detailed description of the control flow of exceptions. Consider we have a <code>try</code>-<code>catch</code>-<code>finally</code> block that catches two exceptions <code>E1</code> and <code>E2</code>. Inside the try block, we call a method <code>m1()</code>; <code>m1()</code> calls <code>m2()</code>; <code>m2()</code> calls <code>m3()</code>, and <code>m3()</code> calls <code>m4()</code>.</p> <p>We highlight method invocation with yellow dot.  In other words, there will be arrows out from yellow dot to another method.  At the end of the execution of that method, the arrow will return back to the yellow dot.  Additionally, each dashed line corresponds to a block (i.e., enclosed in curly bracket).</p> <p></p> <pre><code>try {\n  m1();\n} catch (E1 e) {\n    :\n} catch (E2 e) {\n    :\n} finally {\n    :\n}\n</code></pre> <pre><code>void m1() {\n    :\n  m2();\n    :\n}\n\nvoid m2() {\n    :\n  m3();\n    :\n}\n\nvoid m3() {\n    :\n  m4();\n    :\n}\n\nvoid m4() {\n    :\n  if (condition()) {\n    throw new E2();\n  }\n    :\n}\n</code></pre> <p>First, notice that we typically put \"guards\" around the <code>throw</code> statement.  Otherwise, the exception is always thrown. As for the execution, in a normal (no exception) situation, the control flow looks like this:</p> <p></p> <p>The statements in the try block are executed, followed by the statements in the <code>finally</code> block.</p> <p>Now, let's suppose something went wrong deep inside the nested call, in <code>m4()</code> as represented by the red dot. One of the statement executes <code>throw new E2();</code>, which causes the execution in <code>m4()</code> to stop. JVM now looks for the block of code that catches <code>E2</code>, going down the call stack, until it can find a place where the exception is handled. In this example, we suppose that none of <code>m1()</code>-<code>m4()</code> handles (i.e., <code>catch</code>) the exception. Thus, JVM then jumps to the code that handles <code>E2</code>. Finally, JVM executes the <code>finally</code> block.</p> <p>Note that the <code>finally</code> block is always executed even when <code>return</code> or <code>throw</code> is called in a <code>catch</code> block.</p> <p></p> <p>So the reason why the execution jumps from the call frame of <code>m4()</code> directly to the <code>catch(E2 e)</code> is because in between them there are no other <code>catch</code> blocks.  Should there be a <code>catch(E2 e)</code> in <code>m2()</code>, then the execution jumps from <code>m4()</code> to <code>m2()</code>.  Afterwards, the execution continues normally from the <code>catch(E2 e)</code> block in <code>m2()</code>.  This is illustrated below.</p> <p></p>"},{"location":"22-exception.html#creating-our-own-exceptions","title":"Creating Our Own Exceptions","text":"<p>If you find that none of the exceptions provided by Java meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones. But, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler.</p> <p>Here is an example:</p> <pre><code>class IllegalCircleException extends IllegalArgumentException {\n  private Point center;\n\n  public IllegalCircleException(String message) {\n    super(message);\n  }\n\n  public IllegalCircleException(Point c, String message) {\n    super(message);\n    this.center = c;\n  }\n\n  @Override\n  public String toString() {\n    return \"The circle centered at \" + this.center + \" cannot be created:\" + getMessage();\n  }\n}\n</code></pre>"},{"location":"22-exception.html#overriding-method-that-throws-exceptions","title":"Overriding Method that Throws Exceptions","text":"<p>When you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method. This rule follows the Liskov Substitution Principle. The caller of the overridden method cannot expect any new checked exception beyond what has already been \"promised\" in the method specification.</p>"},{"location":"22-exception.html#good-practices-for-exception-handling","title":"Good Practices for Exception Handling","text":""},{"location":"22-exception.html#catch-exceptions-to-clean-up","title":"Catch Exceptions to Clean Up","text":"<p>While it is convenient to just pass the buck and let the calling method deals with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so. Consider the example earlier, where <code>m1()</code>, <code>m2()</code>, and <code>m3()</code> do not handle exception <code>E2</code>. Let's say that <code>E2</code> is a checked exception, and it is possible to react to this and let the program continues properly. Also, suppose that <code>m2()</code> allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method. By not handling the exception, the code that deallocates these resources does not get called when an exception occurs.  It is better for <code>m2()</code> to catch the exception, handle the resource deallocation in a <code>finally</code> block. If there is a need for the calling methods to be aware of the exception, <code>m2()</code> can always re-throw the exception:</p> <pre><code>public void m2() throws E2 {\n  try {\n    // setup resources\n    m3();\n  } catch (E2 e) {\n    throw e;\n  } finally {\n    // clean up resources\n  }\n}\n</code></pre> <p>Rethrow</p> <p>Although the code may be simplified into simply <code>try-finally</code> without any <code>catch</code>, such code in general is less readable.  Always use <code>try</code>-<code>catch</code> or <code>try</code>-<code>catch</code>-<code>finally</code>.</p>"},{"location":"22-exception.html#do-not-catch-them-all","title":"Do NOT Catch-Them-All!","text":"<p>Sometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions. Since Java uses checked exceptions, it forces you to handle the exceptions, or else your code will not compile. One way to quickly get around this is to write:</p> <pre><code>try {\n  // your code\n} catch (Exception e) {\n  // do nothing\n}\n</code></pre> <p>to stop the compiler from complaining.  DO NOT DO THIS.  Since <code>Exception</code> is the superclass of all exceptions, every exception that is thrown, checked or unchecked, is now silently ignored!  You will not be able to figure out if something is wrong with your program.  This practice is such a bad practice that there is a name for it -- this is called Pokemon Exception Handling<sup>2</sup>.</p>"},{"location":"22-exception.html#do-not-overreact","title":"Do NOT Overreact","text":"<p>Do not exit a program just because of an exception. This would prevent the calling function from cleaning up their resources. Worse, do not exit a program silently.</p> <pre><code>try {\n  // your code\n} catch (Exception e) {\n  System.exit(0);\n}\n</code></pre>"},{"location":"22-exception.html#do-not-break-abstraction-barrier","title":"Do NOT Break Abstraction Barrier","text":"<p>Sometimes, letting the calling method handle the exception causes the implementation details to be leaked, and make it harder to change the implementation later.</p> <p>For instance, suppose we design a class <code>ClassRoster</code> with a method <code>getStudents()</code>, which reads the list of students from a text file.</p> <pre><code>class ClassRoster {\n    :\n  public Students[] getStudents() throws FileNotFoundException {\n      :\n  }\n}\n</code></pre> <p>Here, the fact that a <code>FileNotFoundException</code> is thrown leaks the information that the information is read from a file.  </p> <p>Suppose that, later, we change the implementation to reading the list from an SQL database.  We may have to change the exception thrown to something else:</p> <pre><code>class ClassRoster {\n    :\n  public Students[] getStudents() throws SQLException {\n      :\n  }\n}\n</code></pre> <p>The caller will have to change their exception handling code accordingly.</p> <p>We should, as much as possible, handle the implementation-specific exceptions within the abstraction barrier.</p>"},{"location":"22-exception.html#do-not-use-exception-as-a-control-flow-mechanism","title":"Do NOT Use Exception As a Control Flow Mechanism","text":"<p>This is probably the most commonly seen mistakes among new programmers.  Exceptions are meant to handle unexpected errors, not to handle the logic of your program.  Consider the following snippet:</p> <pre><code>if (obj != null) {\n  obj.doSomething();\n} else {\n  doTheOtherThing();\n}\n</code></pre> <p>We use an <code>if</code> condition to handle the logic.  Some programmers wrote this: <pre><code>try {\n  obj.doSomething();\n} catch (NullPointerException e) {\n  doTheOtherThing();\n}\n</code></pre></p> <p>Not only is this less efficient, but it also might not be correct, since a <code>NullPointerException</code> might be triggered by something else other than <code>obj</code> being null.</p> <p>Relevant XKCD</p> <p></p>"},{"location":"22-exception.html#do-not-return-from-finally","title":"Do NOT Return from Finally","text":"<p>Since the <code>finally</code> block is always executed, having a <code>return</code> statement in the <code>finally</code> block leads to many counter-intuitive behavior.  In some cases, the exceptions may be considered lost while not being handled.</p>"},{"location":"22-exception.html#the-error-class","title":"The <code>Error</code> class","text":"<p>Java has another class called <code>Error</code> for situations where the program should terminate as generally there is no way to recover from the error. For instance, when the heap is full (<code>OutOfMemoryError</code>) or the stack is full (<code>StackOverflowError</code>).  Typically we don't need to create or handle such errors.  In fact, because handling exceptions/errors require memory, we may not even be able to handle <code>OutOfMemoryError</code>.</p> <p><code>Exception</code> and <code>Error</code> shares a common superclass called <code>Throwable</code>.  In fact, only objects that are instances of this class or its subclasses can be thrown by the <code>throw</code> statement or caught by the <code>catch</code> block.  The hierarchy is shown in the class diagram below.</p> <p></p> <p><code>try</code>-<code>catch</code>-<code>finally</code> inside <code>finally</code></p> <p>One of the quirk of Java is that you may encounter code where <code>try</code>-<code>catch</code>-<code>finally</code> inside <code>finally</code> is a necessity.  This may happen when you are reading file using <code>FileReader</code> class.  Your code may look like the following</p> <pre><code>FileReader file = null;\ntry {\n  file = new FileReader(\"/path/to/file\");\n  // the constructor may throw IOException\n  // reading may also throw IOException\n} catch(IOException e) {\n  // handle exception\n} finally {\n  if (file != null) {\n    file.close();\n  }\n}\n</code></pre> <p>That looks like a perfectly reasonable code except for the fact the <code>file.close()</code> may actually throw an <code>IOException</code>.  Since <code>IOException</code> is a checked exception, you must either handle the exception or pass the buck.  To handle the exception, the code requires nested <code>try</code>-<code>catch</code>-<code>finally</code>.</p> <pre><code>FileReader file = null;\ntry {\n  file = new FileReader(\"/path/to/file\");\n  // the constructor may throw IOException\n  // reading may also throw IOException\n} catch(IOException e) {\n  // handle exception\n} finally {\n  if (file != null) {\n    try {\n      file.close();\n    } catch(IOException e) {\n      // not sure what to do, probably just do nothing\n    }\n    // finally is also probably not needed\n  }\n}\n</code></pre> <p>So there you have it, a nested <code>try</code>-<code>catch</code>-<code>finally</code> and something that cannot even be considered to be a bad practice.  Luckily, we do not use <code>FileReader</code> in this module.</p> <ol> <li> <p><code>Exception</code> has a superclass called <code>Throwable</code>.  You can also catch a <code>Throwable</code>.  Although the name has a suffix \"-able\", it is not an interface but an actual class.\u00a0\u21a9</p> </li> <li> <p>An even worse offence would be to <code>catch(Throwable t)</code>.  The only exception to this rule (pun intended) is when you are writing code for system that must NEVER shut down like a nuclear power plant or an airplane midflight.  Then by all means, catch a throwable and don't cause a nuclear meltdown or planes crashing down.\u00a0\u21a9</p> </li> </ol>"},{"location":"23-generics.html","title":"Unit 23: Generics","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>know how to define and instantiate a generic type and a generic method.</li> <li>be familiar with the term parameterized types, type arguments, type parameters.</li> <li>appreciate how generics can reduce duplication of code and improve type safety.</li> </ul>"},{"location":"23-generics.html#the-pair-class","title":"The <code>Pair</code> class","text":"<p>Sometimes it is useful to have a lightweight class to bundle a pair of variables together.  One could, for instance, write a method that returns two values.  The example defines a class <code>IntPair</code> that bundles two <code>int</code> variables together. This is a utility class with neither semantics nor methods associated with it and so, we did not attempt to hide the implementation details.</p> Integer Pair<pre><code>class IntPair {\n  private int first;\n  private int second;\n\n  public IntPair(int first, int second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  int getFirst() {\n    return this.first;\n  }\n\n  int getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>This class can be used, for instance, in a function that returns two <code>int</code> values.</p> <pre><code>IntPair findMinMax(int[] array) {\n  int min = Integer.MAX_VALUE;  // stores the min\n  int max = Integer.MIN.VALUE;  // stores the max\n  for (int i : array) {\n    if (i &lt; min)  {\n      min = i;\n    }\n    if (i &gt; max) {\n      max = i;\n    }\n  }\n  return new IntPair(min, max);\n}\n</code></pre> <p>We could similarly define a pair class for two doubles (<code>DoublePair</code>), two booleans (<code>BooleanPair</code>), etc.  In other situations, it is useful to define a pair class that bundles two variables of two different types, say, a <code>Customer</code> and a <code>CoffeeCounter</code>; a <code>String</code> and an <code>int</code>; etc.  </p> <p>We should not, however, create one class for each possible combination of types.  A better idea is to define a class that stores two <code>Object</code> references:</p> Pair v0.1<pre><code>class Pair {\n  private Object first;\n  private Object second;\n\n  public Pair(Object first, Object second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  Object getFirst() {\n    return this.first;\n  }\n\n  Object getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>At the cost of using a wrapper class in place of primitive types, we get a single class that can be used to store any type of values.  </p> <p>You might recall that we used a similar approach for our <code>contains</code> method to implement a general method that works for any type of object.  Here, we are using this approach for a general class that encapsulates any type of object.</p> <p>Unfortunately, the issues we faced with narrowing type conversion and potential run-time errors apply to the <code>Pair</code> class as well.  Suppose that a function returns a <code>Pair</code> containing a <code>String</code> and an <code>Integer</code>, and we accidentally treat this as an <code>Integer</code> and a <code>String</code> instead, the compiler will not be able to detect the type mismatch and stop the program from crashing during run-time.</p> <pre><code>Pair foo() {\n  return new Pair(\"hello\", 4);\n}\n\nPair p = foo();\nInteger i = (Integer) p.getFirst(); // run-time ClassCastException\n</code></pre> <p>To reduce the risk of human error, what we need is a way to specify the following: suppose the type of <code>first</code> is \\(S\\) and type of <code>second</code> is \\(T\\), then we want the return type of <code>getFirst</code> to be \\(S\\) and of <code>getSecond</code> to be \\(T\\).</p>"},{"location":"23-generics.html#generic-types","title":"Generic Types","text":"<p>In Java and many other programming languages, the mechanism to do this is called generics or templates.  Java allows us to define a generic type that takes other types as type parameters, just like how we can write methods that take in variables as parameters.  </p>"},{"location":"23-generics.html#declaring-a-generic-type","title":"Declaring a Generic Type","text":"<p>Let's see how we can do this for <code>Pair</code>:</p> Pair v0.2<pre><code>class Pair&lt;S,T&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>We declare a generic type by specifying its type parameters between <code>&lt;</code> and <code>&gt;</code> when we declare the type.  By convention, we use a single capital letter to name each type parameter.  These type parameters are scoped within the definition of the type.  In the example above, we have a generic class <code>Pair&lt;S,T&gt;</code> (read \"pair of S and T\")  with <code>S</code> and <code>T</code> as type parameters.  We use <code>S</code> and <code>T</code> as the type of the fields <code>first</code> and <code>second</code>.  We ensure that <code>getFirst()</code> returns type <code>S</code> and <code>getSecond()</code> returns type <code>T</code>, so that the compiler will give an error if we mix up the types.</p> <p>Note that the constructor is still declared as <code>Pair</code> (without the type parameters).</p>"},{"location":"23-generics.html#usinginstanting-a-generic-type","title":"Using/Instanting a Generic Type","text":"<p>To use a generic type, we have to pass in type arguments, which itself can be a non-generic type, a generic type, or another type parameter that has been declared.  Once a generic type is instantiated, it is called a parameterized type.</p> <p>To avoid potential human errors leading to <code>ClassCastException</code> in the example above, we can use the generic version of <code>Pair</code> as follows, taking in two non-generic types:</p> <pre><code>Pair&lt;String,Integer&gt; foo() {\n  return new Pair&lt;String,Integer&gt;(\"hello\", 4);\n}\n\nPair&lt;String,Integer&gt; p = foo();\nInteger i = (Integer) p.getFirst(); // compile-time error\n</code></pre> <p>With the parameterized type <code>Pair&lt;String,Integer&gt;</code>, the return type of <code>getFirst</code> is bound to <code>String</code>, and the compiler now have enough type information to check and give us an error since we try to cast a <code>String</code> to an <code>Integer</code> in the expression <code>(Integer) p.getFirst()</code>.  We can see this by the following reasoning below.</p> <p>Type Analysis</p> <ol> <li>The return type of <code>p.getFirst()</code> is the generic type <code>S</code>.</li> <li>The variable <code>p</code> has the compile-time type of <code>Pair&lt;String, Integer&gt;</code>.</li> <li>The class <code>Pair</code> is declared with two type parameters <code>Pair&lt;S, T&gt;</code>.</li> <li>By type parameter passing, we have <code>S</code> = <code>String</code> and <code>T</code> = <code>Integer</code>.</li> <li>The return type of <code>p.getFirst()</code> is <code>S</code>.</li> <li>Since <code>S</code> is a <code>String</code> due to (4), the return type of <code>p.getFirst()</code> is <code>String</code>.</li> <li>Since <code>String</code> &lt;/: <code>Integer</code> and both are concrete classes, we cannot type cast <code>String</code> to <code>Integer</code>.</li> <li>Hence we get compile-time error.</li> </ol> <p>Note that we use <code>Integer</code> instead of <code>int</code>, since only reference types can be used as type arguments.</p> <p>Just like you can pass a parameter of a method to another method, we can pass the type parameter of a generic type to another:</p> <pre><code>class DictEntry&lt;T&gt; extends Pair&lt;String,T&gt; {\n    :\n}\n</code></pre> <p>We define a generic class called <code>DictEntry&lt;T&gt;</code> with a single type parameter <code>T</code> that extends from <code>Pair&lt;String,T&gt;</code>, where <code>String</code> is the first type argument (in place of <code>S</code>), while the type parameter <code>T</code> from <code>DictEntry&lt;T&gt;</code> is passed as the type argument for <code>T</code> of <code>Pair&lt;String,T&gt;</code>.</p> <p>Generic Type Declaration vs Usage</p> <p>In geenral, generic type declaration will always be enclosed within <code>&lt; .. &gt;</code>.  However, there are at least two cases where the types within <code>&lt; .. &gt;</code> are not declared but used.</p> <ol> <li>Extending/implementing a generic class/interface.<ul> <li>Consider <code>class DictEntry&lt;T&gt; extends Pair&lt;String, T&gt;</code>.</li> <li>We declare a generic type <code>T</code> in <code>class DictEntry&lt;T&gt; ..</code>.</li> <li>We use the non-generic type <code>String</code> in <code>.. extends Pair&lt;String, ..&gt;</code>.</li> <li>We use the generic type <code>T</code> in <code>.. extends Pair&lt;.., T&gt;</code>.</li> </ul> </li> <li>Instantiating an instance of a generic type.<ul> <li>Consider <code>new Pair&lt;X, Y&gt;( ,, )</code>.</li> <li>The two types <code>X</code> and <code>Y</code> are not generic type declaration.</li> </ul> </li> </ol>"},{"location":"23-generics.html#generic-methods","title":"Generic Methods","text":"<p>Methods can be parameterized with a type parameter as well.  Consider the <code>contains</code> method, which we now put within a class for clarity.</p> contains v0.1<pre><code>class A {\n  // version 0.1 (with polymorphism)\n  public static boolean contains(Object[] array, Object obj) {\n    for (Object curr : array) {\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>While using this method does not involve narrowing type conversion and type casting, it is a little to general -- it allows us to call <code>contains</code> in a nonsensical way, like this:</p> <pre><code>String[] strArray = new String[] { \"hello\", \"world\" };\nA.contains(strArray, 123);\n</code></pre> <p>Searching for an integer within an array of strings is a futile attempt!  Let's constrain the type of the object to search for to be the same as the type of the array.  We can make this type the parameter to this method:</p> contains v0.5<pre><code>class A {\n  public static &lt;T&gt; boolean contains(T[] array, T obj) {\n    for (T curr : array) {\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>The above shows an example of a generic method.  The type parameter <code>T</code> is declared within <code>&lt;</code> and <code>&gt;</code> and is added before the return type of the method.  This parameter <code>T</code> is then scoped within the whole method.</p> <p>To call a generic method, we need to pass in the type argument placed before the name of the method<sup>1</sup>.  For instance,</p> <pre><code>String[] strArray = new String[] { \"hello\", \"world\" };\nA.&lt;String&gt;contains(strArray, 123); // type mismatch error\n</code></pre> <p>The code above won't compile since the compiler expects the second argument to also be a <code>String</code>.</p> <pre><code>_.java:_: error: incompatible types: int cannot be converted to String\n        A.&lt;String&gt;contains(strArray, 123); // type mismatch error\n                                     ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n</code></pre> <p>Additionally, the number of type arguments passed must match the number of type arguments expected.  This is similar to how the number of argument values passed must match the number of parameter variables expected.  Consider the following method invocation.</p> <pre><code>String[] strArray = new String[] { \"hello\", \"world\" };\nA.&lt;String, String&gt;contains(strArray, \"123\"); // no more type mismatch, but wrong number of type arguments\n</code></pre> <p>The code will not compile with the following error message.</p> <pre><code>_.java:_: error: method contains in class A cannot be applied to given types;\n        A.&lt;String, String&gt;contains(strArray, \"123\"); // type mismatch error\n         ^\n  required: T[],T\n  found: String[],String\n  reason: wrong number of type arguments; required 1\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;contains(T[],T)\n1 error\n</code></pre> <p>Our old implementation of <code>contains</code> method (reproduced below) is simply a special case of the contains method above.</p> <pre><code>boolean oldContains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>The following two statements are equivalent.</p> <pre><code>oldContains(objArr, obj);\nA.&lt;Object&gt;contains(objArr, obj);\n</code></pre> <p>Type Parameter Confusion</p> <p>A potential confusion arise when we declare type parameter with the same name but are actually different type.  Recap that we declare a type parameter by enclosing it within <code>&lt;</code> and <code>&gt;</code>.  As you have seen in Declaring a Generic Type and Generic Methods, the two places where you can declare type parameters are when you declare a class or when you declare a method.</p> <p>We can also declare a type <code>&lt;T&gt;</code> in both as shown below.</p> <pre><code>class Confused&lt;T&gt; {\n  private T t;\n\n  public &lt;T&gt; T getT() {\n    return this.t;\n  }\n}\n</code></pre> <p>You will notice that you get a weird error.</p> <pre><code>Main.java:5: error: incompatible types: T#1 cannot be converted to T#2\n        return this.t;\n                   ^\n  where T#1,T#2 are type-variables:\n    T#1 extends Object declared in class Confused\n    T#2 extends Object declared in method &lt;T#2&gt;getT()\n1 error\n</code></pre> <p>What are these <code>T#1</code> and <code>T#2</code>?  In the class declaration, we have <code>class Confused&lt;T&gt; { .. }</code> so we are declaring that we have a type called <code>T</code> that is generic.  In the method, this <code>T</code> is shadowed by the nearer type parameter declaration <code>public &lt;T&gt; T getT() { .. }</code>.  So the two <code>T</code> are actually different types, they just happen to have the same name.</p> <p>To differentiate them, Java compiler typically will add a unique numbering.  The <code>T</code> from <code>class Confused&lt;T&gt; { .. }</code> is then renamed into <code>T#1</code> together with all its usage.  The <code>T</code> from <code>public &lt;T&gt; T getT() { .. }</code> is then renamed into <code>T#2</code>.  So internally, Java may actually be looking at the following:</p> <pre><code>class Confused&lt;T#1&gt; {\n  private T#1 t;\n\n  public &lt;T#2&gt; T#2 getT() {\n    return this.t;\n  }\n}\n</code></pre> <p>Of course the above is not a valid code as <code>T#1</code> is not a valid name for a type.  But you can clearly see that <code>this.t</code> has a type of <code>T#1</code>, but we expect the return type of <code>T#2</code>.</p>"},{"location":"23-generics.html#bounded-type-parameters","title":"Bounded Type Parameters","text":"<p>Let's now try to apply our newly acquired trick to fix the issue with <code>findLargest</code>.  Recall that we have the following <code>findLargest</code> method (which we now put into an ad hoc class just for clarity), which requires us to perform a narrowing type conversion to cast from <code>GetAreable</code> and possibly leading to a run-time error.</p> findLargest v0.5<pre><code>class A {\n  public static GetAreable findLargest(GetAreable[] array) {\n    double maxArea = 0;\n    GetAreable maxObj = null;\n    for (GetAreable curr : array) {\n      double area = curr.getArea();\n      if (area &gt; maxArea) {\n        maxArea = area;\n        maxObj = curr;\n      }\n    }\n    return maxObj;\n  }\n}\n</code></pre> <p>Let's try to make this method generic, by forcing the return type to be the same as the type of the elements in the input array,</p> findLargest v0.6<pre><code>class A {\n  public static &lt;T&gt; T findLargest(T[] array) {\n    double maxArea = 0;\n    T maxObj = null;\n    for (T curr : array) {\n      double area = curr.getArea();\n      if (area &gt; maxArea) {\n        maxArea = area;\n        maxObj = curr;\n      }\n    }\n    return maxObj;\n  }\n}\n</code></pre> <p>The code above won't compile, since the compiler cannot be sure that it can find the method <code>getArea()</code> in type <code>T</code>.  In contrast, when we run <code>contains</code>, we had no issue since we are invoking the method <code>equals</code>, which exists in any reference type in Java.</p> <p>Since we intend to use <code>findLargest</code> only in classes that implement the <code>GetAreable</code> interface and supports the <code>getArea()</code> method, we can put a constraint on <code>T</code>.  We can say that <code>T</code> must be a subtype of <code>GetAreable</code> when we specify the type parameter:</p> findLargest v0.7<pre><code>class A {\n  public static &lt;T extends GetAreable&gt; T findLargest(T[] array) {\n    double maxArea = 0;\n    T maxObj = null;\n    for (T curr : array) {\n      double area = curr.getArea();\n      if (area &gt; maxArea) {\n        maxArea = area;\n        maxObj = curr;\n      }\n    }\n    return maxObj;\n  }\n}\n</code></pre> <p>We use the keyword <code>extends</code> here to indicate that <code>T</code> must be a subtype of <code>GetAreable</code>.  It is unfortunate that Java decides to use the term <code>extends</code> for any type of subtyping when declaring a bounded type parameter, even if the supertype is an interface (such as <code>GetAreable</code>).</p> <p>We can use bounded type parameters for declaring generic classes as well.  For instance, Java has a generic interface <code>Comparable&lt;T&gt;</code>, which dictates the implementation of the following <code>int compareTo(T t)</code> for any concrete class that implements the interface.   Any class that implements the <code>Comparable&lt;T&gt;</code> interface can be compared with an instance of type <code>T</code> to establish an ordering.  Such ordering can be useful for sorting objects, for instance.</p> <p>Suppose we want to compare two <code>Pair</code> instances, by comparing the first element in the pair, we could do the following:</p> Pair v0.3<pre><code>class Pair&lt;S extends Comparable&lt;S&gt;,T&gt; implements Comparable&lt;Pair&lt;S,T&gt;&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n\n  @Override\n  public int compareTo(Pair&lt;S,T&gt; s1) {\n    return this.first.compareTo(s1.first);\n  }\n\n  @Override\n  public String toString() {\n    return this.first + \" \" + this.second;\n  }\n}\n</code></pre> <p>Let's look at what it means:</p> <ul> <li>We declared <code>Pair</code> to be a generic type of two type parameters: the first one <code>S</code> is bounded and must be a subtype of <code>Comparable&lt;S&gt;</code>.  This bound is self-referential, but it is intuitive -- we say that <code>S</code> must be comparable to itself, which is common in many use cases.</li> <li>Since we want to compare two <code>Pair</code> instances, we make <code>Pair</code> implements the <code>Comparable</code> interface too, passing in <code>Pair&lt;S,T&gt;</code> as the type argument to <code>Comparable</code>.</li> </ul> <p>Let's see this in action with <code>Arrays::sort</code> method, which sorts an array based on the ordering defined by <code>compareTo</code>.</p> <pre><code>Object[] array = new Object[] {\n  new Pair&lt;String,Integer&gt;(\"Alice\", 1),\n  new Pair&lt;String,Integer&gt;(\"Carol\", 2),\n  new Pair&lt;String,Integer&gt;(\"Bob\", 3),\n  new Pair&lt;String,Integer&gt;(\"Dave\", 4),\n};\n\njava.util.Arrays.sort(array);\n\nfor (Object o : array) {\n  System.out.println(o);\n}\n</code></pre> <p>You will see the pairs are sorted by the first element.</p> <p>Upper Bound</p> <p>Note that there is only \"upper bound\" in bounded type parameters.  For a more flexible typing, we have to rely on wildcards that can specify either the upper bound or the lower bound.</p> <ol> <li> <p>Java actually can infer the type using the type inference mechanism and allows us to skip the type argument, but for clarity, we insist on specifying the type explicitly until students get used to the generic types and reasoning about types.\u00a0\u21a9</p> </li> </ol>"},{"location":"24-erasure.html","title":"Unit 24: Type Erasure","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand that generics are implemented with type erasure in Java.</li> <li>understand that type information is not fully available during run-time when generics are used, and problems that this could cause.</li> <li>be aware that arrays and generics don't mix well in Java.</li> <li>know the terms reifiable type and heap pollution.</li> </ul>"},{"location":"24-erasure.html#implementing-generics","title":"Implementing Generics","text":"<p>There are several ways one could implement generics in a programming language.</p>"},{"location":"24-erasure.html#code-specialization","title":"Code Specialization","text":"<p>For instance, in C#, every instantiation of a generic type causes new code to be generated for that instantiated type.  For instance, instantiating <code>Pair&lt;S,T&gt;</code> into <code>Pair&lt;String,Integer&gt;</code> causes a new type to be generated during run-time.  In C++ and in Rust, instantiating <code>Pair&lt;String,Integer&gt;</code> causes new code to be generated during compile-time.  This approach is sometimes called code specialization.</p> <p>The disadvantages of such approach are</p> <ul> <li>codes are duplicated, so the resulting program is larger.</li> <li>changing the client by adding more use cases requires recompilation of the entire generic <code>Pair</code> class as we may need to generate the specialized code for a new type.</li> </ul> <p>Note, in the example below, the specialized codes are hypothethical as Java does not use code specialization technique.  Additionally, the name of the class is improper as it contains the character <code>#</code>.</p> Template CodeString/IntegerSender/Receiver <pre><code>class Pair&lt;S, T&gt; {\n  private S first;\n  pruvate T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n}\n</code></pre> <pre><code>class Pair#String#Integer {\n  private String first;\n  pruvate Integer second;\n\n  public Pair(String first, Integer second) {\n    this.first = first;\n    this.second = second;\n  }\n}\n</code></pre> <pre><code>class Pair#Sender#Receiver {\n  private Sender first;\n  pruvate Receiver second;\n\n  public Pair(Sender first, Receiver second) {\n    this.first = first;\n    this.second = second;\n  }\n}\n</code></pre>"},{"location":"24-erasure.html#code-sharing","title":"Code Sharing","text":"<p>Java takes a code sharing approach, instead of creating a new type for every instantiation, it chooses to erase the type parameters and type arguments during compilation (after type checking, of course).  Thus, there is only one representation of the generic type in the generated code, representing all the instantiated generic types, regardless of the type arguments.  The resulting compiled code does not to be recompiled when encountering new types!  </p> <p>Part of the reason to do this is for compatibility with the older version of Java.  Java introduces generics only from version 5 onwards.  Prior to version 5, one has to use <code>Object</code> to implement classes that are general enough to works on multiple types, similar to what we did with <code>Pair</code> here:</p> Pair v0.1<pre><code>class Pair {\n  private Object first;\n  private Object second;\n\n  public Pair(Object first, Object second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public Object getFirst() {\n    return this.first;\n  }\n\n  public Object getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>The Java type erasure process transforms the code below into the code above.  Press on the tab to see the comparison.</p> Generic CodeType Erased Code (aligned) Pair v0.2<pre><code>class Pair&lt;S,T&gt; {\n  private S      first;\n  private T      second;\n\n  public Pair(S      first, T      second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S      getFirst() {\n    return this.first;\n  }\n\n  public T      getSecond() {\n    return this.second;\n  }\n}\n</code></pre> Pair v0.2 (Type Erased)<pre><code>class Pair      {\n  private Object first;\n  private Object second;\n\n  public Pair(Object first, Object second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public Object getFirst() {\n    return this.first;\n  }\n\n  public Object getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>Note that each type parameter <code>S</code> and <code>T</code> are replaced with <code>Object</code>.  If the type parameter is bounded, it is replaced by the bounds instead (e.g., If <code>T extends GetAreable</code>, then <code>T</code> is replaced with <code>GetAreable</code>).</p> <p>Where a generic type is instantiated and used, the code</p> <pre><code>Integer i = new Pair&lt;String,Integer&gt;(\"hello\", 4).getSecond();\n</code></pre> <p>is transformed into</p> <pre><code>Integer i = (Integer) new Pair(\"hello\", 4).getSecond();\n</code></pre> <p>The generated code is similar to what we would write earlier, but this is generated by the compiler after type checking, it ensures that the casting will not lead to <code>ClassCastException</code> during run-time.</p> <p>Type erasures have several important implications.  We will explore some of them below, and a few others during recitation.  </p>"},{"location":"24-erasure.html#generics-and-arrays-cant-mix","title":"Generics and Arrays Can't Mix","text":"<p>Let's consider the hypothetical code below (that does not compile):</p> Generic CodeType Erased Code (aligned) <pre><code>// create a new array of pairs\nPair&lt;String,Integer&gt;[] pairArray = new Pair&lt;String,Integer&gt;[2];\n\n// pass around the array of pairs as an array of object\nObject[] objArray = pairArray;\n\n// put a pair into the array -- no ArrayStoreException!\nobjArray[0] = new Pair&lt;Double,Boolean&gt;(3.14, true);\n</code></pre> <pre><code>// create a new array of pairs\nPair                [] pairArray = new Pair                [2];\n\n// pass around the array of pairs as an array of object\nObject[] objArray = pairArray;\n\n// put a pair into the array -- no ArrayStoreException!\nobjArray[0] = new Pair                (3.14, true);\n</code></pre> <p>This is similar to what we have in Unit 21, where we showed we could get an <code>ArrayStoreException</code> due to Java arrays being covariant.  We would not, however, get an exception when we try to put a pair of double and boolean, into an array meant to store a pair of string and integer!  This type checking is done during run-time, and due to type erasure, the run-time has no information about what is the type arguments to <code>Pair</code>.  The run-time sees:</p> Type Erased Code <pre><code>// create a new array of pairs\nPair[] pairArray = new Pair[2];\n\n// pass around the array of pairs as an array of object\nObject[] objArray = pairArray;\n\n// put a pair into the array -- no ArrayStoreException!\nobjArray[0] = new Pair(3.14, true);\n</code></pre> <p>It checks that we have an array of pairs and we are putting another pair inside.   Everything checks out.  This would have caused a heap pollution, a term that refers to the situation where a variable of a parameterized type refers to an object that is not of that parameterized type.</p> <p>Heap pollution is dangerous, as now, we will get a <code>ClassCastException</code> when we do: <pre><code>// getting back a string?  -- now we get ClassCastException\nString str = pairArray[0].getFirst();\n</code></pre></p> <p>The example above shows why generics and arrays don't mix well together.  An array is what is called reifiable type -- a type where full type information is available during run-time.  It is because Java array is reifiable that the Java run-time can check what we store into the array matches the type of the array and throw an <code>ArrayStoreException</code> at us if there is a mismatch.  Java generics, however, is not reifiable due to type erasure.  Java designers have decided not to mix the two.</p> <p>The hypothetical code above actually is not a valid Java syntax.  We can't compile this line: <pre><code>Pair&lt;String,Integer&gt;[] pairArray = new Pair&lt;String,Integer&gt;[2];\n</code></pre></p> <p>The following are illegal as well: <pre><code>new Pair&lt;S,T&gt;[2];\nnew T[2];\n</code></pre></p> <p>On the other hand, given a generic type <code>T</code>, the following is allowed.</p> <pre><code>T[] array;\n</code></pre> <p>In summary, generic array declaration is fine but generic array instantiation is not.</p>"},{"location":"24-erasure.html#generic-type-rules","title":"Generic Type Rules","text":"<p>Before we add rules for determining type check as well as dynamic binding, we first need two additional terminologies<sup>1</sup>: (i) class-level type parameters and (ii) method-level type parameters.</p> <p>We can then state the type rules as follows.</p> <ol> <li>Generic method signature includes type parameters.<ul> <li>Two type parameters are considered the same if we can rename all type parameters into the same name.  In other words, they are equal up to renaming.</li> </ul> </li> <li>Type check uses type argument for class-level type parameter if available.<ul> <li>This allows for more type safety checks to be done but it may have counter-intuitive interaction with dynamic binding.</li> </ul> </li> <li>Method descriptor stored in dynamic binding during compile-time step is the type erased descriptor.<ul> <li>This is because the code we are executing is the type erased version.  Type erased code does not have type parameters anymore.</li> <li>The type parameters are available as additional information (i.e., metadata) that can be used for compilation but not used at run-time.</li> </ul> </li> </ol> <p>We can now apply these rules to some interesting cases.  For simplicity of explanation, we will use the following types with the following subtyping relationships: <code>T4</code> &lt;: <code>T3</code> &lt;: <code>T2</code> &lt;: <code>T1</code>.</p>"},{"location":"24-erasure.html#method-level-overriding","title":"Method-Level Overriding","text":"<p>Consider the interface <code>I</code> without class-level type parameter.  It has a single method-level type parameter which we will try to override.</p> <ul> <li> <p>Original Code</p> <pre><code>interface I {\n  &lt;T extends T1&gt; int foo(T t);\n}\n</code></pre> </li> <li> <p>Type Erased Code</p> <pre><code>interface I {\n  int foo(T1 t);\n}\n</code></pre> </li> </ul> <p>Since we use type parameter as part of method signature but allow renaming, we have the following correct overriding below.</p> <ul> <li> <p>PASS</p> <pre><code>class C implements I {\n  @Override\n  public &lt;T extends T1&gt; int foo(T t) {\n    return 0;\n  }\n}\n</code></pre> </li> <li> <p>PASS</p> <pre><code>class C implements I {\n  @Override\n  public &lt;S extends T1&gt; int foo(S t) {\n    return 0;\n  }\n}\n</code></pre> </li> </ul> <p>Unfortunately, the following does not work because we either have different number of type parameters or different type parameter after renaming.  Renaming is simply looking at the name and not at the bound of the type.</p> <ul> <li> <p>FAIL: Different Number</p> <pre><code>class C implements I {\n  @Override\n  public &lt;T extends T1, S&gt; int foo(T t) {\n    return 0;\n  }\n}\n</code></pre> </li> <li> <p>FAIL: Not Renaming</p> <pre><code>class C&lt;T extends T1&gt; implements I {\n  @Override\n  public &lt;S extends T&gt; int foo(S t) {\n    return 0;\n  }\n}\n</code></pre> </li> </ul> <p>One exceptional case is when the type parameter is not present.  In which case, for method-level type parameter, we use the type erased version.  So the code below pass type checking.</p> <ul> <li> <p>PASS</p> <pre><code>class C implements I {\n  @Override\n  public int foo(T1 t) {\n    return 0;\n  }\n}\n</code></pre> </li> <li> <p>PASS</p> <pre><code>class C&lt;S&gt; implements I {\n  @Override\n  public int foo(T1 t) {\n    return 0;\n  }\n}\n</code></pre> </li> </ul> <p>Unfortunately, if a method-level type parameter is present -- even if it is not used -- it no longer pass type check.  As for class-level type parameter, it will only causes failure if used.</p> <ul> <li> <p>FAIL: Method-Level Type parameter</p> <pre><code>class C implements I {\n  @Override\n  public &lt;S&gt; int foo(T1 t) {\n    return 0;\n  }\n}\n</code></pre> </li> <li> <p>FAIL: Class-Level Type parameter</p> <pre><code>class C&lt;S extends T1&gt; implements I {\n  @Override\n  public int foo(S t) {\n    return 0;\n  }\n}\n</code></pre> </li> </ul>"},{"location":"24-erasure.html#class-level-overriding","title":"Class-Level Overriding","text":"<p>In the case of class-level type parameter, we need to activate the second rule too when determining overriding.  To do that, we will consider a different interface <code>I&lt;T&gt;</code>.</p> <ul> <li> <p>Original Code</p> <pre><code>interface I&lt;T&gt; {\n  int foo(T t);\n}\n</code></pre> </li> <li> <p>Type Erased Code</p> <pre><code>interface I {\n  int foo(Object t);\n}\n</code></pre> </li> </ul> <p>Since we use type argument when possible.  This means implementing <code>I&lt;String&gt;</code> forces us to implement <code>foo(String)</code> instead of <code>foo(Object)</code>.</p> <ul> <li> <p>PASS</p> <pre><code>class C implements I&lt;String&gt; {\n  @Override\n  public int foo(String t) {\n    return 0;\n  }\n}\n</code></pre> </li> <li> <p>FAIL: Not Using Type Argument</p> <pre><code>class C implements I&lt;String&gt; {\n  @Override\n  public int foo(Object t) {\n    return 0;\n  }\n}\n</code></pre> </li> </ul> <p>On the other hand, if we are implemeting <code>I&lt;S&gt;</code>, we have two options.  The code on the left has no compilation error because we simply replace <code>T</code> with <code>S</code>.  The code on the right has no compilation error because we have no other information regarding <code>S</code> except that it is bounded by <code>Object</code>.</p> <ul> <li> <p>PASS</p> <pre><code>class C&lt;S&gt; implements I&lt;S&gt; {\n  @Override\n  public int foo(S t) {\n    return 0;\n  }\n}\n</code></pre> </li> <li> <p>PASS</p> <pre><code>class C&lt;S&gt; implements I&lt;S&gt; {\n  @Override\n  public int foo(Object t) {\n    return 0;\n  }\n}\n</code></pre> </li> </ul> <p>We can test this hypothesis further by compiling the following code below.  It compiles because we still have no other information about <code>S</code> but the bound is now <code>T1</code>.</p> <ul> <li> <p>Interface</p> <pre><code>interface I&lt;T extends T1&gt; {\n  int foo(T t);\n}\n</code></pre> </li> <li> <p>Class</p> <pre><code>class C&lt;S extends T1&gt; implements I&lt;S&gt; {\n  @Override\n  public int foo(T1 t) {\n    return 0;\n  }\n}\n</code></pre> </li> </ul>"},{"location":"24-erasure.html#overloading","title":"Overloading","text":"<p>In the case of overloading, we need to ensure that the code has no ambiguity.  The following code cannot even be compiled because the type erased version already has ambiguity.</p> <ul> <li> <p>Original Code</p> <pre><code>class C&lt;T extends T3&gt; {\n  void foo(T t) { }\n  &lt;T extends T3&gt; void foo(T t) { }\n}\n</code></pre> </li> <li> <p>Type Erased Code</p> <pre><code>class C {\n  void foo(T3 t) { }\n  void foo(T3 t) { }\n}\n</code></pre> </li> </ul> <p>Now, let us look at it in relation to rule (3).  This is because at run-time, we are executing the type erased code.  But we also need to ensure that there is no ambiguity in which method to be selected.  We will look at how rule (2) and (3) interacts at compilation of caller and not the callee.  We assume that the following callee is already compiled.</p> <ul> <li> <p>Original Code</p> <pre><code>class C&lt;T extends T1&gt; {\n  void foo(T t) { }\n  &lt;T extends T3&gt; void foo(T t) { }\n}\n</code></pre> </li> <li> <p>Type Erased Code</p> <pre><code>class C {\n  void foo(T1 t) { }\n  void foo(T3 t) { }\n}\n</code></pre> </li> </ul> <p>We should first note that the method signature after type erasure is different.  So the class <code>C</code> can be compiled.  However, this is insufficient to determine if the usage has no ambiguity.</p> <p>Remember by rule (2), we need to consider the type argument at compilation.  But here, we are compiling the caller.  The code on the left has no ambiguity while the code on the right has ambiguity.  The simplified method signature being checked are given below it.</p> <ul> <li> <p>PASS</p> <pre><code>C&lt;T2&gt; c = new C&lt;T2&gt;();\nc.foo(new T3());\n</code></pre> <p>Simplified method signature checked using type signature.</p> <ul> <li><code>foo(T2)</code></li> <li><code>foo(T3)</code></li> </ul> </li> <li> <p>FAIL</p> <pre><code>C&lt;T3&gt; c = new C&lt;T3&gt;();\nc.foo(new T3());\n</code></pre> <p>Simplified method signature checked using type signature.</p> <ul> <li><code>foo(T3)</code></li> <li><code>foo(T3)</code></li> </ul> </li> </ul> <p>Assuming that all of these checks are ok, we then move on to the actual dynamic binding involving generic.</p>"},{"location":"24-erasure.html#dynamic-binding-with-generic","title":"Dynamic Binding with Generic","text":"<p>Before continuing, we need to clarify rule (3).  The simplified method signature above is only used for type checking.  At the end, when we run the code, we are executing the type erased version.  This means the method descriptor stored at compile-time step of dynamic binding is the type erased version.</p> <p>How can we show that?  We can use the following two related generic classes.</p> <ul> <li> <p>Superclass</p> <pre><code>class C&lt;T extends T1&gt; {\n  void foo(T t) { }\n  &lt;T extends T3&gt; void foo(T t) { }\n}\n</code></pre> </li> <li> <p>Subclass</p> <pre><code>class D&lt;T extends T1&gt; extends C&lt;T&gt; {\n  @Override void foo(T1 t) { }\n  @Override void foo(T3 t) { }\n}\n</code></pre> </li> </ul> <p>We first check that the classes can compile.  By the overriding rule, <code>void D::foo(T1)</code> overrides <code>void C::foo(T)</code> and <code>void D::too(T3)</code> overrides <code>&lt;T extends T3&gt; void C::foo(T)</code>.  Additionally, there is no ambiguity in the type signature after type erasure.</p> <p>Let us consider the dynamic binding process in more details.  We will use rule (2) before step (3) of compile-time step of dynamic binding.  This will affect which methods are accessible, compatible, and most specific.  Consider the code below and the simplified method signature created from our overloading explanation above.</p> <ul> <li> <p>Usage</p> <pre><code>C&lt;T4&gt; c = new D&lt;T4&gt;();\nc.foo(new T4());\n</code></pre> </li> <li> <p>Signature</p> <pre><code>foo(T4) // from foo at line 2\nfoo(T3) // from foo at line 3\n</code></pre> </li> </ul> CTT of target CTT of param Accessible Compatible Most Specific Method Descriptor Method Executed <code>C</code> <code>T4</code> <code>foo(T4)</code><code>foo(T3)</code> <code>foo(T4)</code><code>foo(T3)</code> <code>foo(T4)</code> <code>void foo(T1)</code> <code>void D::foo(T1)</code> <p>Now, although the most specific method is <code>foo(T4)</code>, the method descriptor is the method descriptor corresponding to the method <code>foo</code> at line 2.  This means, the method descriptor stored is <code>void foo(T1)</code>.</p> <p>This distinction is important because because when we execute the code, we will execute <code>void D::foo(T1)</code> since this method match the method descriptor we stored during compile-time step of dynamic binding.</p> <p>We can look at three more usages to assure ourselves that our hypothesis correct.  The explanation of which method executed is given as a similar table as above.</p> <ul> <li> <p>Usage</p> <pre><code>C&lt;T4&gt; c = new D&lt;T4&gt;();\nc.foo(new T3());\n</code></pre> </li> <li> <p>Signature</p> <pre><code>foo(T4) // from foo at line 2\nfoo(T3) // from foo at line 3\n</code></pre> </li> </ul> CTT of target CTT of param Accessible Compatible Most Specific Method Descriptor Method Executed <code>C</code> <code>T3</code> <code>foo(T4)</code><code>foo(T3)</code> <code>foo(T3)</code> <code>foo(T3)</code> <code>void foo(T3)</code> <code>void D::foo(T3)</code> <ul> <li> <p>Usage</p> <pre><code>C&lt;T2&gt; c = new D&lt;T2&gt;();\nc.foo(new T2());\n</code></pre> </li> <li> <p>Signature</p> <pre><code>foo(T2) // from foo at line 2\nfoo(T3) // from foo at line 3\n</code></pre> </li> </ul> CTT of target CTT of param Accessible Compatible Most Specific Method Descriptor Method Executed <code>C</code> <code>T2</code> <code>foo(T2)</code><code>foo(T3)</code> <code>foo(T2)</code> <code>foo(T2)</code> <code>void foo(T1)</code> <code>void D::foo(T1)</code> <ul> <li> <p>Usage</p> <pre><code>C&lt;T2&gt; c = new D&lt;T2&gt;();\nc.foo(new T3());\n</code></pre> </li> <li> <p>Signature</p> <pre><code>foo(T2) // from foo at line 2\nfoo(T3) // from foo at line 3\n</code></pre> </li> </ul> CTT of target CTT of param Accessible Compatible Most Specific Method Descriptor Method Executed <code>C</code> <code>T3</code> <code>foo(T2)</code><code>foo(T3)</code> <code>foo(T2)</code><code>foo(T3)</code> <code>foo(T3)</code> <code>void foo(T3)</code> <code>void D::foo(T3)</code> <p>You can test the hypothesis above by running the following code and check that the output matches our explanation.</p> <pre><code>class T1 {}\nclass T2 extends T1 {}\nclass T3 extends T2 {}\nclass T4 extends T3 {}\n\nclass C&lt;T extends T1&gt; {\n  void foo(T t) { System.out.println(1); }\n  &lt;T extends T3&gt; void foo(T t) { System.out.println(2); }\n}\n\nclass D&lt;T extends T1&gt; extends C&lt;T&gt; {\n  @Override\n  void foo(T1 t) { System.out.println(3); }\n  @Override\n  void foo(T3 t) { System.out.println(4); }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    C&lt;T4&gt; c4 = new D&lt;T4&gt;();\n    c4.foo(new T3());  // 4\n    c4.foo(new T4());  // 3\n\n    C&lt;T2&gt; c2 = new D&lt;T2&gt;();\n    c2.foo(new T2());  // 3\n    c2.foo(new T3());  // 4\n    c2.foo(new T4());  // 4\n  }\n}\n</code></pre> <ol> <li> <p>It is always useful to give names when explaining things.  Unless we already have a name for a concept, you may use your own name as long as you also explained the meaning.\u00a0\u21a9</p> </li> </ol>"},{"location":"25-unchecked.html","title":"Unit 25: Unchecked Warnings","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be aware of how to use generics with an array.</li> <li>be aware of unchecked warnings that compilers can give when we are using generics.</li> <li>be able to make arguments why a piece of code is type-safe for simple cases.</li> <li>know how to suppress warnings from compilers.</li> <li>be aware of the ethics when using the <code>@SuppressWarnings(\"unchecked\")</code> annotation.</li> <li>know what is a raw type.</li> <li>be aware that raw types should never never be used in modern Java.</li> </ul>"},{"location":"25-unchecked.html#creating-arrays-with-type-parameters","title":"Creating Arrays with Type Parameters","text":"<p>We have seen how arrays and generics do not mix well.  One way to get around this is to use Java Collections, a library of data structures provided by Java, instead of arrays, to store our items.  The <code>ArrayList</code> class provides similar functionality to an array, with some performance overhead.  </p> <pre><code>ArrayList&lt;Pair&lt;String,Integer&gt;&gt; pairList;\npairList = new ArrayList&lt;Pair&lt;String,Integer&gt;&gt;(); // ok\n\npairList.add(0, new Pair&lt;Double,Boolean&gt;(3.14, true));  // error\n\nArrayList&lt;Object&gt; objList = pairList;  // error\n</code></pre> <p><code>ArrayList</code> itself is a generic class, and when parameterized, it ensures type-safety by checking for appropriate types during compile time.  We can't add a <code>Pair&lt;Double,Boolean&gt;</code> object to a list of <code>Pair&lt;String,Integer&gt;</code>.  Furthermore, unlike Java array, which is covariant, generics are invariant.  There is no subtyping relationship between <code>ArrayList&lt;Object&gt;</code> and <code>ArrayList&lt;Pair&lt;String,Integer&gt;&gt;</code> so we can't alias one with another, preventing the possibility of heap pollution.</p> <p>Using <code>ArrayList</code> instead of arrays only gets around the problem of mixing arrays and generics, as a user.  <code>ArrayList</code> is implemented with an array internally after all.  As computing students, especially computer science students, it is important to know how to implement your own data structures instead of using ones provided by Java or other libraries.  </p> <p>Let's try to build one and to minimize confusion, let's call it <code>Seq&lt;T&gt;</code>:</p> Seq v0.1<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    this.array = (T[]) new Object[size];\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n\n  public T[] getArray() {\n    return this.array;\n  }\n}\n</code></pre> <p>This generic class is a wrapper around an array of type <code>T</code>.  Recall that we cannot instantiate a generic array direction (i.e., cannot instantiate <code>new T[]</code>).  On Line 6, to get around this restriction, we instantiate via <code>new</code> keyword, an array of <code>Object</code> instead, and then cast it to an array of <code>T[]</code> instead.</p> <p>The code now compiles.  Why would we expect this to compile at all?  Think about what the type erased code would look like.  So there is at least some reason why we would expect the code to work.</p> Type Erased CodeGeneric Code (aligned) <pre><code>// version 0.1\nclass Array    {\n  private Object[] array;\n\n  Array(int size) {\n    this.array = (Object[]) new Object[size];\n  }\n\n  public void set(int index, Object item) {\n    this.array[index] = item;\n  }\n\n  public Object get(int index) {\n    return this.array[index];\n  }\n\n  public Object[] getArray() {\n    return this.array;\n  }\n}\n</code></pre> <pre><code>// version 0.1\nclass Array&lt;T&gt; {\n  private T     [] array;\n\n  Array(int size) {\n    this.array = (T     []) new Object[size];\n  }\n\n  public void set(int index, T      item) {\n    this.array[index] = item;\n  }\n\n  public T      get(int index) {\n    return this.array[index];\n  }\n\n  public T     [] getArray() {\n    return this.array;\n  }\n}\n</code></pre> <p>As we can see from the type erased code, the type of the field <code>array</code> is indeed <code>Object[]</code>.  Unfortunately, although the code compiles, we receive the following message:</p> <pre><code>$ javac Seq.java\nNote: Seq.java uses unchecked or unsafe operations.\nNote: Recompile with -Xlint:unchecked for details.\n</code></pre> <p>Let's do what the compiler tells us, and compile with the <code>-Xlint:unchecked</code> flags. <pre><code>$ javac -Xlint:unchecked Seq.java\nSeq.java:6: warning: [unchecked] unchecked cast\n    array = (T[]) new Object[size];\n                  ^\n  required: T[]\n  found:    Object[]\n  where T is a type-variable:\n    T extends Object declared in class Seq\n1 warning\n</code></pre></p> <p>We get a warning that our Line 6 is doing an unchecked cast.  </p>"},{"location":"25-unchecked.html#unchecked-warnings","title":"Unchecked Warnings","text":"<p>An unchecked warning is basically a message from the compiler that it has done what it can, and because of type erasures, there could be a run-time error that it cannot prevent. Recall that type erasure generates the following code: <pre><code>(String) array.get(0);\n</code></pre></p> <p>Since <code>array</code> is an array of <code>Object</code> instances and Java array is covariant, the compiler can't guarantee that the code it generated is safe anymore.</p> <p>Consider the following: <pre><code>Seq&lt;String&gt; seq = new Seq&lt;String&gt;(4);\nObject[] objArray = seq.getArray();\nobjArray[0] = 4;\nseq.get(0);  // ClassCastException\n</code></pre></p> <p>The last line would generate a <code>ClassCastException</code>, exactly a scenario that the compiler has warned us.</p> <p>It is now up to us humans to change our code so that the code is safe.  Suppose we remove the <code>getArray</code> method from the <code>Seq</code> class,</p> Seq v0.2<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    this.array = (T[]) new Object[size];\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n}\n</code></pre> <p>Can we prove that our code is type-safe?  In this case, yes.</p> <p>Type Safety</p> <ol> <li><code>array</code> is declared as <code>private</code> so it is accessible only by code written inside the class <code>Seq</code>.</li> <li>The only way someone can put something into <code>array</code> is through the method <code>Seq::set(int, T)</code>.</li> <li><code>Seq::set(int, T)</code> only put items of type <code>T</code> into <code>array</code> based on the implementation.</li> <li>The only type of objects we can get out of array must be of type <code>T</code> (or subtype of <code>T</code>).</li> <li><code>Seq::get(int)</code> will always retrieve either <code>T</code> (or subtype of <code>T</code>).</li> <li>Since we can only insert/retrieve <code>T</code> from <code>array</code> due to (4) and (5), it is safe to cast <code>Object[]</code> to <code>T[]</code>.</li> </ol> <p>If we wish to put in a paragraph, we can write the following instead.</p> <p>Since <code>array</code> is declared as <code>private</code>, the only way someone can put something into the <code>array</code> is through the <code>Seq::set</code> method<sup>1</sup>.  <code>Seq::set</code> only put items of type <code>T</code> into <code>array</code>.  So the only type of objects we can get out of <code>array</code> must be of type <code>T</code>.  So we, as humans, can see that casting <code>Object[]</code> to <code>T[]</code> is type-safe.</p> <p>If we are sure (and only if we are sure) that the line</p> <pre><code>    array = (T[]) new Object[size];\n</code></pre> <p>is safe, we can thank the compiler for its warning and assure the compiler that everything is going to be fine.  We can do so with the <code>@SuppressWarning(\"unchecked\")</code> annotation.</p> Seq v0.3<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    // The only way we can put an object into array is through\n    // the method set() and we only put object of type T inside.\n    // So it is safe to cast `Object[]` to `T[]`.\n    @SuppressWarnings(\"unchecked\")\n    T[] a = (T[]) new Object[size];\n    this.array = a;\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n}\n</code></pre> <p><code>@SuppressWarning</code> is a powerful annotation that suppresses warning messages from compilers.  Like everything that is powerful, we have the responsibility to use it properly:</p> <ul> <li><code>@SuppressWarning</code> can apply to declaration at a different scope: a local variable, a method, a type, etc.  We must always use <code>@SuppressWarning</code> to the most limited scope to avoid unintentionally suppressing warnings that are valid concerns from the compiler.</li> <li>We must suppress a warning only if we are sure that it will not cause a type error later.  </li> <li>We must always add a note (as a comment) to fellow programmers explaining why a warning can be safely suppressed.</li> </ul> <p>Note that since <code>@SuppressWarnings</code> cannot apply to an assignment but only to declaration, we declare a local variable <code>a</code> in the example above before assigning <code>this.array</code> to <code>a</code>.</p>"},{"location":"25-unchecked.html#raw-types","title":"Raw Types","text":"<p>Another common scenario where we can get an unchecked warning is the use of raw types.  A raw type is a generic type used without type arguments.  Suppose we do:</p> <pre><code>Seq a = new Seq(4);\n</code></pre> <p>The code would compile perfectly.  We are using the generic <code>Seq&lt;T&gt;</code> as a raw type <code>Seq</code>.  Java allows this code to compile for backward compatibility.  This is anyway what the code looks like after type erasure and how we would write the code in Java before version 5.   Without a type argument, the compiler can't do any type checking at all.  We are back to the uncertainty that our code could bomb with <code>ClassCastException</code> after it ships.</p> <p>Mixing raw types with paramterized types can also lead to errors.  Consider: <pre><code>Seq&lt;String&gt; seq = new Seq&lt;String&gt;(4);\npopulateSeq(seq);\nString str = seq.get(0);\n</code></pre></p> <p>where the method <code>populateArray</code> uses raw types: <pre><code>void populateArray(Seq a) {\n  a.set(0, 1234);\n}\n</code></pre></p> <p>Since we use raw types in this method, the compiler can't help us.  It will warn us: <pre><code>Seq.java:24: warning: [unchecked] unchecked call to set(int,T) as a member of the raw type Seq\n    a.set(0, 1234);\n         ^\n  where T is a type-variable:\n    T extends Object declared in class Seq\n1 warning\n</code></pre></p> <p>If we ignore this warning or worse, suppress this warning, we will get a run-time error when we execute <code>a.get(0)</code>.</p> <p>Raw types must not be used in your code, ever.  The only exception to this rule is using it as an operand of the <code>instanceof</code> operator<sup>2</sup>.  Since <code>instanceof</code> checks for run-time type and type arguments have been erased, we can only use the <code>instanceof</code> operator on raw types.</p> <ol> <li> <p>Another win for information hiding!\u00a0\u21a9</p> </li> <li> <p>Even this one will be subsumed in the future and we will no longer allow any use of raw types.\u00a0\u21a9</p> </li> </ol>"},{"location":"26-wildcard.html","title":"Unit 26: Wildcards","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be aware of the meaning of wildcard <code>?</code> and bounded wildcards.</li> <li>know how to use wildcards to write methods that are more flexible in accepting a range of types.</li> <li>know that upper-bounded wildcard is covariant and lower-bounded wildcard is contravariant.</li> <li>know the PECS principle and how to apply it.</li> <li>be aware that the unbounded wildcard allows us to not use raw types in our programs.</li> </ul>"},{"location":"26-wildcard.html#contains-with-seqt","title":"<code>contains</code> with <code>Seq&lt;T&gt;</code>","text":"Running Example <p>For our running example in this unit, we will be using the following classes.</p> Class Declaration<pre><code>abstract class Shape { .. }\nclass Circle extends Shape { .. }\nclass Square extends Shape { .. }\nclass ColoredCircle extends Circle { .. }\nclass LinedCircle extends Circle { .. }\n</code></pre> <p>We can summarize this as the following subtype relationship.</p> <ul> <li><code>ColoredCircle</code> &lt;: <code>Circle</code> &lt;: <code>Shape</code></li> <li><code>LinedCircle</code> &lt;: <code>Circle</code> &lt;: <code>Shape</code></li> <li><code>Square</code> &lt;: <code>Shape</code></li> </ul> <p>The class diagram for visualization is shown below.  Note that <code>Shape</code> extends from <code>Object</code> implicitly.</p> <p></p> <p>Recap our latest version of <code>contains</code> v0.5 using generic array.</p> contains v0.5<pre><code>class A {\n  public static &lt;T&gt; boolean contains(T[] array, T obj) {\n    for (int i = 0; i &lt; array.length; i++) {\n      T curr = array[i];\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>Now that we have our <code>Seq&lt;T&gt;</code> class, let's modify our generic <code>contains</code> method and replace the type of the argument <code>T[]</code> with <code>Seq&lt;T&gt;</code>.</p> contains v0.6<pre><code>class A {\n  public static &lt;T&gt; boolean contains(Seq&lt;T&gt; seq, T obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      T curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>Similar to <code>contains</code> v0.5, using generics allows us to constrain the type of the elements of the sequence and the object to search for to be the same.  This allows the following code to type-check correctly:</p> <pre><code>Seq&lt;String&gt; stringSeq;\nSeq&lt;Circle&gt; circleSeq;\nCircle circle;\n  :\nA.&lt;String&gt;contains(stringSeq, \"hello\");\n// OK: Seq&lt;String&gt; &lt;: Seq&lt;String&gt;\n//   &amp; String &lt;: String\nA.&lt;Circle&gt;contains(circleSeq, circle);\n// OK: Seq&lt;Circle&gt; &lt;: Seq&lt;Circle&gt;\n//   &amp; Circle &lt;: Circle\n</code></pre> <p>But trying to search for a circle in a sequence of strings would lead to a type error:</p> <pre><code>A.&lt;String&gt;contains(stringSeq, circle); // ERROR: Circle &lt;/: String\n</code></pre> <p>Consider now having a sequence of shapes.</p> <pre><code>Seq&lt;Shape&gt; shapeSeq;\nSeq&lt;Circle&gt; circleSeq;\nShape shape;\nCircle circle;\n  :\nA.&lt;Shape&gt;contains(shapeSeq, shape);\n// OK: Seq&lt;Shape&gt; &lt;: Seq&lt;Shape&gt;\n//   &amp; Shape  &lt;: Shape\nA.&lt;Circle&gt;contains(circleSeq, circle);\n// OK: Seq&lt;Circle&gt; &lt;: Seq&lt;Circle&gt;\n//   &amp; Circle &lt;: Circle\n</code></pre> <p>As expected, we can pass <code>Shape</code> as the argument for <code>T</code>, and search for a <code>Shape</code> in an instance of <code>Seq&lt;Shape&gt;</code>. Similarly, we can pass <code>Circle</code> as the argument for <code>T</code> and search for a <code>Circle</code> in an instance of <code>Seq&lt;Circle&gt;</code>.</p> <p>We could also look for a <code>Circle</code> instance from <code>Seq&lt;Shape&gt;</code> if we pass <code>Shape</code> as the argument for <code>T</code>.</p> <pre><code>A.&lt;Shape&gt;contains(shapeSeq, circle);\n// OK: Seq&lt;Shape&gt; &lt;: Seq&lt;Shape&gt;\n//   &amp; Circle &lt;: Shape\n</code></pre> <p>Note that we can pass in a <code>Circle</code> instance as a <code>Shape</code>, since <code>Circle</code> &lt;: <code>Shape</code>.</p> <p>Recall that generics are invariant in Java (i.e., there is no subtyping relationship between <code>Seq&lt;Shape&gt;</code> and <code>Seq&lt;Circle&gt;</code>).  <code>Seq&lt;Circle&gt;</code> is not a subtype of <code>Seq&lt;Shape&gt;</code>.  Otherwise, it would violate the Liskov Substitution Principle, we can put a square into a <code>Seq&lt;Shape&gt;</code> instance, but we can't put a square into a <code>Seq&lt;Circle&gt;</code> instance.</p> <p>So, we can't call: <pre><code>A.&lt;Circle&gt;contains(shapeSeq, circle);\n// ERROR: Seq&lt;Shape&gt; &lt;/: Seq&lt;Circle&gt;\n</code></pre></p> <p>The following would result in compilation errors as well:</p> <pre><code>A.&lt;Shape&gt;contains(circleSeq, shape);\n// ERROR: Seq&lt;Circle&gt; &lt;/: Seq&lt;Shape&gt;\nA.&lt;Circle&gt;contains(circleSeq, shape);\n// ERROR: Shape &lt;/: Circle\n</code></pre> <p>Thus, with our current implementation, we can't look for a shape (which may be a circle) in a sequence of circles, even though this is something reasonable that a programmer might want to do.  This constraint is due to the invariance of generics -- while we avoided the possibility of run-time errors by avoiding covariance arrays, our methods have become less general.</p> <p>Let's see how we can fix this with bounded type parameters first.  We can introduce another type parameter, say <code>S</code>, to remove the constraints that the type of the sequence must be the same as the type of the object to search for.  I.e., we change from</p> <pre><code>public static &lt;T&gt; boolean contains(Seq&lt;T&gt; seq, T obj) { .. }\n</code></pre> <p>to: <pre><code>public static &lt;S, T&gt; boolean contains(Seq&lt;T&gt; seq, S obj) { .. }\n</code></pre></p> <p>But we don't want to completely decouple <code>T</code> and <code>S</code>, as we want <code>T</code> to be a subtype of <code>S</code>.  We can thus make <code>T</code> a bounded type parameter, and write: <pre><code>public static &lt;S, T extends S&gt; boolean contains(Seq&lt;T&gt; seq, S obj) { .. }\n</code></pre></p> <p>Now, we can search for a shape in a sequence of circles. <pre><code>A.&lt;Shape,Circle&gt;contains(circleSeq, shape);\n</code></pre></p>"},{"location":"26-wildcard.html#copying-to-and-from-seqt","title":"Copying to and from <code>Seq&lt;T&gt;</code>","text":"<p>Let's consider another example.  Let's add two methods <code>copyFrom</code> and <code>copyTo</code>, to <code>Seq&lt;T&gt;</code> so that we can copy to and from one array to another.</p> Seq v0.4<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    // The only way we can put an object into the array is through\n    // the method set() and we only put an object of type T inside.\n    // So it is safe to cast `Object[]` to `T[]`.\n    @SuppressWarnings(\"unchecked\")\n    T[] a = (T[]) new Object[size];\n    this.array = a;\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n\n  public void copyFrom(Seq&lt;T&gt; src) {\n    int len = Math.min(this.array.length, src.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      this.set(i, src.get(i));\n    }\n  }\n\n  public void copyTo(Seq&lt;T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      dest.set(i, this.get(i));\n    }\n  }\n}\n</code></pre> <p>With this implementation, we can copy, say, a <code>Seq&lt;Circle&gt;</code> to another <code>Seq&lt;Circle&gt;</code>, a <code>Seq&lt;Shape&gt;</code> to another <code>Seq&lt;Shape&gt;</code>, but not a <code>Seq&lt;Circle&gt;</code> into a <code>Seq&lt;Shape&gt;</code>, even though each circle is a shape!</p> <pre><code>Seq&lt;Circle&gt; circleSeq; // T = Circle --&gt; copyTo(Seq&lt;Circle&gt;) &amp; copyFrom(Seq&lt;Circle&gt;)\nSeq&lt;Shape&gt; shapeSeq;   // T = Shape  --&gt; copyTo(Seq&lt;Shape&gt;)  &amp; copyFrom(Seq&lt;Shape&gt;)\n  :\nshapeSeq.copyFrom(circleSeq); // ERROR: Seq&lt;Circle&gt; &lt;/: Seq&lt;Shape&gt;\ncircleSeq.copyTo(shapeSeq);   // ERROR: Seq&lt;Shape&gt;  &lt;/: Seq&lt;Circle&gt;\n</code></pre>"},{"location":"26-wildcard.html#upper-bounded-wildcards","title":"Upper-Bounded Wildcards","text":"<p>Let's consider the method <code>copyFrom</code>.  We should be able to copy from a sequence of shapes, a sequence of circles, a sequence of squares, etc, into a sequence of shapes.  In other words, we should be able to copy from a sequence of any subtype of shapes into a sequence of shapes.  Is there such a type in Java?</p> <p>The type that we are looking for is <code>Seq&lt;? extends Shape&gt;</code>.  This generic type uses the wildcard <code>?</code>.  Just like a wild card in card games, it is a substitute for any type.   A wildcard can be bounded.  Here, this wildcard is upper-bounded by <code>Shape</code> (i.e., the <code>?</code> can be substituted with either <code>Shape</code> or any subtype of <code>Shape</code>).</p> Substituted <p>They key here is substituted.  Consider our running example.  Given the type <code>Seq&lt;? extends Shape&gt;</code>, the <code>?</code> can be substituted with any one of the following:</p> <ul> <li><code>Shape</code>: because <code>Shape</code> &lt;: <code>Shape</code> so we get <code>Seq&lt;Shape&gt;</code>.</li> <li><code>Circle</code>: because <code>Circle</code> &lt;: <code>Shape</code> so we get <code>Seq&lt;Circle&gt;</code>.</li> <li><code>Square</code>: because <code>Square</code> &lt;: <code>Shape</code> so we get <code>Seq&lt;Square&gt;</code>.</li> <li><code>ColoredCircle</code>: because <code>ColoredCircle</code> &lt;: <code>Shape</code> so we get <code>Seq&lt;ColoredCircle&gt;</code>.</li> <li><code>LinedCircle</code>: because <code>LinedCircle</code> &lt;: <code>Shape</code> so we get <code>Seq&lt;LinedCircle&gt;</code>.</li> </ul> <p>This can be seen more clearly by looking at the class diagram.  In the class diagram below, the types that can be used to substitute <code>?</code> is highlighted with red background.</p> <p></p> <p>What this means is that we can actually do the following sequence of assignments.</p> <pre><code>Seq&lt;? extends Shape&gt; arr;\narr = new Seq&lt;ColoredCircle&gt;(1); // ? is substituted with ColoredCircle\narr = new Seq&lt;Square&gt;(1);        // ? is now substituted with Square\n</code></pre> <p>The upper-bounded wildcard is an example of covariance.  The upper-bounded wildcard has the following subtyping relations:</p> <ul> <li>If <code>S</code> &lt;: <code>T</code>, then <code>A&lt;? extends S&gt;</code> &lt;: <code>A&lt;? extends T&gt;</code> (covariance)</li> <li>For any type <code>S</code>, <code>A&lt;S&gt;</code> &lt;: <code>A&lt;? extends S&gt;</code></li> </ul> Covariance <p>To see this, consider <code>Seq&lt;? extends Circle&gt;</code> and <code>Seq&lt;? extends Shape&gt;</code>.  Now we look at the types that can be used to substitute <code>?</code> in both cases.  The types are summarized in the table below.</p> <code>Seq&lt;? extends Circle&gt;</code> <code>Seq&lt;? extends Shape&gt;</code> - <code>Shape</code> <code>Circle</code> <code>Circle</code> - <code>Square</code> <code>ColoredCircle</code> <code>ColoredCircle</code> <code>LinedCircle</code> <code>LinedCircle</code> <p>So, whatever type can be used to substitute <code>?</code> in <code>Seq&lt;? extends Circle&gt;</code> can also be used to substitute <code>?</code> in <code>Seq&lt;? extends Shape&gt;</code>.  So the following assignment would work because whatever type we substitute <code>?</code> with, <code>Seq&lt;? extends Shape&gt;</code> can accept those.</p> <pre><code>Seq&lt;? extends Circle&gt; arr1 = ..; // run-time type omitted\nSeq&lt;? extends Shape&gt; arr2 = arr1;\n</code></pre> <p>The table can also be visualized using class diagram.  Blue background highlights the type that can be used to substitute <code>?</code> for <code>Seq&lt;? extends Circle&gt;</code> and red background highlights the type that can be used to substitute <code>?</code> for <code>Seq&lt;? extends Shape&gt;</code>.  If one is a subset of the other, it implies a subtyping relationship.</p> <p></p> <p>Simply using the covariance rule above, we can also infer a few things.  For instance, we can infer <code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends Shape&gt;</code>.  The proof is as follows</p> <p>Proof</p> <ol> <li><code>Circle</code> &lt;: <code>Shape</code> (given)</li> <li><code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends Circle&gt;</code> (upper-bounded wildcard property)</li> <li><code>Seq&lt;? extends Circle&gt;</code> &lt;: <code>Seq&lt;? extends Shape&gt;</code> (using (1) and covariance of upper-bounder wildcard)</li> <li><code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends Shape&gt;</code> (transitivity of subtyping relationship using (2) and (3))</li> </ol> <p>Because <code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends Shape&gt;</code>, if we change the type of the parameter to <code>copyFrom</code> to <code>Seq&lt;? extends T&gt;</code>, </p> <pre><code>  public void copyFrom(Seq&lt;? extends T&gt; src) {\n    int len = Math.min(this.array.length, src.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      this.set(i, src.get(i));\n    }\n  }\n</code></pre> <p>We can now call:</p> <pre><code>shapeSeq.copyFrom(circleSeq);\n// OK: Seq&lt;Circle&gt; &lt;: Seq&lt;? extends Shape&gt;\n//     --&gt; because Circle &lt;: Shape\n</code></pre> <p>without error.</p>"},{"location":"26-wildcard.html#lower-bounded-wildcards","title":"Lower-Bounded Wildcards","text":"<p>Let's now try to allow copying of a <code>Seq&lt;Circle&gt;</code> to <code>Seq&lt;Shape&gt;</code>.</p> <pre><code>circleSeq.copyTo(shapeSeq); \n</code></pre> <p>by doing the same thing:</p> <pre><code>  public void copyTo(Seq&lt;? extends T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n        dest.set(i, this.get(i));\n    }\n  }\n</code></pre> <p>The code above would not compile.  We will get the following somewhat cryptic message when we compile with the <code>-Xdiags:verbose</code> flag:</p> <pre><code>Seq.java:32: error: method set in class Seq&lt;T&gt; cannot be applied to given types;\n        dest.set(i, this.get(i));\n          ^\n  required: int,CAP#1\n  found: int,T\n  reason: argument mismatch; T cannot be converted to CAP#1\n  where T is a type-variable:\n    T extends Object declared in class Seq\n  where CAP#1 is a fresh type-variable:\n    CAP#1 extends T from capture of ? extends T\n1 error\n</code></pre> <p>CAP?</p> <p>The type <code>CAP#1</code> is an internal compiler name for the implicit type parameter represented by the wildcard (i.e., <code>?</code>).  The name comes from \"capture\".  The numbering is to differentiate the different captured types.</p> <p>Similar to how different declared type parameters are renamed with <code>#1</code> and <code>#2</code>, all the <code>?</code> are referring to different implicit type parameters.  So, the different <code>?</code> can be replaced with different type arguments.</p> <p>Let's try not to understand what the error message means first, and think about what could go wrong if the compiler allows:</p> <pre><code>        dest.set(i, this.get(i));\n</code></pre> <p>Here, we are trying to put an instance with compile-time type <code>T</code> into a sequence that contains elements with the compile-time type of <code>T</code> or subtype of <code>T</code>.  </p> <p>The <code>copyTo</code> method of <code>Seq&lt;Shape&gt;</code> would allow a <code>Seq&lt;Circle&gt;</code> as an argument, and we would end up putting instance with compile-time type <code>Shape</code> into <code>Seq&lt;Circle&gt;</code>.  If all the shapes are circles, we are fine, but there might be other shapes (rectangles, squares) in <code>this</code> instance of <code>Seq&lt;Shape&gt;</code>, and we can't fit them into <code>Seq&lt;Circle&gt;</code>!  Thus, the line </p> <pre><code>        dest.set(i, this.get(i));\n</code></pre> <p>is not type-safe and could lead to <code>ClassCastException</code> during run-time.  </p> <p>Where can we copy our shapes into?  We can only copy them safely into a <code>Seq&lt;Shape&gt;</code>, <code>Seq&lt;Object&gt;</code>, for instance.  In other words, into arrays containing <code>Shape</code> or supertype of <code>Shape</code>.  Unfortunately our running example no longer have <code>GetAreable</code>.  Otherwise, we can also safely insert into <code>Seq&lt;GetAreable&gt;</code> too!</p> <p>We need a wildcard lower-bounded by <code>Shape</code>, and Java's syntax for this is <code>? super Shape</code>.  Using this new notation, we can replace the type for <code>dest</code> with:</p> <pre><code>  public void copyTo(Seq&lt;? super T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      dest.set(i, this.get(i));\n    }\n  }\n</code></pre> <p>The code would now type-check and compile.</p> Substituted <p>We can do the entire reasoning similar to the reasoning we did for upper-bounder wildcard.  First, let's keep it specific.  We will let <code>T</code> to be <code>Circle</code>.  This means <code>Seq&lt;? super T&gt;</code> should be treated as <code>Seq&lt;? super Circle&gt;</code><sup>1</sup>.  So now we try to figure out what are the types that can be used to substitute <code>?</code> in <code>Seq&lt;? super Circle&gt;</code>.  There are only 3 possible types:</p> <ul> <li><code>Circle</code>: because <code>Circle</code> &lt;: <code>Circle</code> so we get <code>Seq&lt;Circle&gt;</code>.</li> <li><code>Shape</code>: because <code>Circle</code> &lt;: <code>Shape</code> so we get <code>Seq&lt;Shape&gt;</code>.</li> <li><code>Object</code>: because <code>Circle</code> &lt;: <code>Object</code> so we get <code>Seq&lt;Object&gt;</code>.</li> </ul> <p>Again, visually, this will be the following class diagram.</p> <p></p> <p>Now, looking back at the relevant part of the code of <code>copyTo</code>, we see the following line:</p> <pre><code>        dest.set(i, this.get(i));\n</code></pre> <p>First, the method <code>set</code> has the following signature: <code>Seq::set(int, T)</code>.  The type <code>T</code> depends on the type of <code>dest</code>.  Second, the method <code>get</code> has the following descriptor <code>T Seq::get(int)</code>.  The type<code>T</code> depends on the type of <code>this</code>.</p> <p>Now, remember, the compile-time type of <code>dest</code> is <code>Seq&lt;? super Circle&gt;</code> and the compile-time type of <code>this</code> is <code>Seq&lt;Circle&gt;</code> (because we let <code>T</code> to be <code>Circle</code>).  By process of enumeration, we see that all possibilities of types that can be used to substitute <code>?</code> in the compile-time type of <code>dest</code> can safely accept <code>Circle</code>.</p> <ul> <li><code>Circle</code>: the method signature for <code>set</code> is <code>Seq::set(int, Circle)</code> and the return type of <code>Seq::get(int)</code> is <code>Circle</code> so this type-checked because <code>Circle</code> &lt;: <code>Circle</code>.</li> <li><code>Shape</code>: the method signature for <code>set</code> is <code>Seq::set(int, Shape)</code> and the return type of <code>Seq::get(int)</code> is <code>Circle</code> so this type-checked because <code>Circle</code> &lt;: <code>Shape</code>.</li> <li><code>Object</code>: the method signature for <code>set</code> is <code>Seq::set(int, Object)</code> and the return type of <code>Seq::get(int)</code> is <code>Circle</code> so this type-checked because <code>Circle</code> &lt;: <code>Object</code>.</li> </ul> <p>The lower-bounded wildcard is an example of contravariance.  We have the following subtyping relations:</p> <ul> <li>If <code>S</code> &lt;: <code>T</code>, then <code>A&lt;? super T&gt;</code> &lt;: <code>A&lt;? super S&gt;</code> (contravariance)</li> <li>For any type <code>S</code>, <code>A&lt;S&gt;</code> &lt;: <code>A&lt;? super S&gt;</code></li> </ul> Contravariance <p>Without going into the lengthy explanation with the tables, we will show the class diagram showing that <code>Seq&lt;? super Shape&gt;</code> is a subtype of <code>Seq&lt;? super Circle&gt;</code>.</p> <p></p> <p>Since we did the proof for upper-bounded wildcard, let us do the same for lower-bounded wildcard.  We will show that <code>Seq&lt;Shape&gt;</code> &lt;: <code>Seq&lt;? super Circle&gt;</code>.</p> <p>Proof</p> <ol> <li><code>Circle</code> &lt;: <code>Shape</code> (given)</li> <li><code>Seq&lt;Shape&gt;</code> &lt;: <code>Seq&lt;? super Shape&gt;</code> (lower-bounded wildcard property)</li> <li><code>Seq&lt;? super Shape&gt;</code> &lt;: <code>Seq&lt;? super Circle&gt;</code> (using (1) and contravariance of lower-bounded wildcard)</li> <li><code>Seq&lt;Shape&gt;</code> &lt;: <code>Seq&lt;? super Circle&gt;</code> (transitivity of subtyping relationship using (2) and (3))</li> </ol> <p>The line of code below now compiles:</p> <pre><code>circleArray.copyTo(shapeArray); \n</code></pre> <p>Our new <code>Seq&lt;T&gt;</code> is now</p> Seq v0.5<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n  // The only way we can put an object into the array is through\n  // the method set() and we only put an object of type T inside.\n  // So it is safe to cast `Object[]` to `T[]`.\n  @SuppressWarnings(\"unchecked\")\n    T[] a = (T[]) new Object[size];\n  this.array = a;\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n\n  public void copyFrom(Seq&lt;? extends T&gt; src) {\n    int len = Math.min(this.array.length, src.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      this.set(i, src.get(i));\n    }\n  }\n\n  public void copyTo(Seq&lt;? super T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      dest.set(i, this.get(i));\n    }\n  }\n}\n</code></pre> Non Subtype Reasoning <p>So far, we have shown the visualization for subtyping relationship.  In both cases, the types that can be substituted for <code>?</code> for the subtype is a subset of the types that can be substituted for <code>?</code> for the supertype.  What about the case where there is no subtyping relationship?</p> <p>Consider <code>Seq&lt;? extends Shape&gt;</code> and <code>Seq&lt;? super Circle&gt;</code>.  Neither are a subtype of the other.  So how would this look like in the class diagram?</p> <p></p> <p>You can see that there is an overlap but clearly, none can be fully contained within the other.  This is what it looks like when there is no subtyping relationship.</p>"},{"location":"26-wildcard.html#pecs","title":"PECS","text":"<p>Now we will introduce the rule that governs when we should use the upper-bounded wildcard <code>? extends T</code> and a lower-bounded wildcard <code>? super T</code>.  This choice depends on the role of the variable in our program.   If the variable is a producer that returns a variable of type <code>T</code>, it should be declared with the wildcard <code>? extends T</code>.  Otherwise, if it is a consumer that accepts a variable of type <code>T</code>, it should be declared with the wildcard <code>? super T</code>.</p> <p>As an example, the variable <code>src</code> in <code>copyFrom</code> above acts as a producer.  It produces a variable of type <code>T</code>.  The type parameter for <code>src</code> must be either <code>T</code> or a subtype of <code>T</code> to ensure type safety.  So the type for <code>src</code> is <code>Seq&lt;? extends T&gt;</code>.    </p> <p>On the other hand, the variable <code>dest</code> in <code>copyTo</code> above acts as a consumer.  It consumes a variable of type <code>T</code>.  The type parameter of <code>dest</code> must be either <code>T</code> or supertype of <code>T</code> for it to be type-safe.  As such, the type for <code>dest</code> is <code>Seq&lt;? super T&gt;</code>.  </p> <p>This rule can be remembered with the mnemonic PECS, or \"Producer Extends; Consumer Super\".</p> <p>PECS: Produced Extends ; Consumer Super</p> Deriving PECS <p>While it is easier to simply memorize PECS, you can actually derive these rules yourself.  The key here is to change your point of view from the client to the implementer.  As a client, you have to think about how you can use the methods implemented by the implementer given the method descriptor.  Let's simulate that.</p> <p>First, a convention.  Since we are looking through the lens of a method, the method consumes a value via its parameter.  Additionally, the method produces a value via its return value.</p> <p>Assume that we have the following six variables.  We have to exclude <code>Shape</code> because it cannot be instantiated.  Note that <code>ColoredCircle</code> &lt;: <code>Circle</code> &lt;: <code>Object</code>.</p> <pre><code>Object arg1 = new Object();\nCircle arg2 = new Circle(..);\nColoredCircle arg3 = new ColoredCircle(..);\n\nObject res1;\nCircle res2;\nColoredCircle res3;\n</code></pre> <p>Now consider an implementer has implemented the method <code>f</code> with the following descriptor: <code>Circle f(Circle)</code>.  We can then see which of the method invocation works.</p> Invocation Argument Type Compilation <code>f(arg1)</code> <code>Object</code> <code>f(arg2)</code> <code>Circle</code> <code>f(arg3)</code> <code>ColoredCircle</code> <p><code>f(arg1)</code> fails compilation because the parameter is accepting <code>Circle</code> but we are passing <code>Object</code>.  Since <code>Object</code> is not a subtype of <code>Circle</code>, we have compilation error.</p> <p>Now we assume that the argument will always be accepted by the parameter and we look at whether the return type can be accepted by the variable.</p> Invocation Variable Type Compilation <code>res1 = f(..)</code> <code>Object</code> <code>res2 = f(..)</code> <code>Circle</code> <code>res3 = f(..)</code> <code>ColoredCircle</code> <p><code>res3 = f(..)</code> fails compilation because the return type is <code>Circle</code>.  But we are trying to assign it to <code>ColoredCircle</code>.  Since <code>Circle</code> is not a subtype of <code>ColoredCircle</code>, we have compilation error.</p> <p>Notice how what we have arrived at is the opposite of PECS<sup>2</sup>.  Looking at the consumer (i.e., parameter), we actually have \"consumer extends\" because we can accept <code>Circle</code> or subtype of <code>Circle</code> (e.g., <code>ColoredCircle</code>).  Looking at the produced (i.e., return value), we actually have \"producer super\" because we can accept <code>Circle</code> or supertype of <code>Circle</code> (e.g., <code>Object</code>).</p> <p>So how do we derive PECS then?  We need to look at it from the point of view of the implementer.  Consider that as an implementer, you will always do the following line.</p> <pre><code>res2 = f(arg2);\n</code></pre> <p>So now, we need to know which of the following method descriptor can be used for <code>f</code>.  Let's draw two tables, one created by varying the parameter type and the other created by varying the return type.  Here we have to assume that each method descriptor are compiled separately and there is no overriding and/or overloading.</p> Method Descriptor Parameter Type Compilation <code>Circle f(Object)</code> <code>Object</code> <code>Circle f(Circle)</code> <code>Circle</code> <code>Circle f(ColoredCircle)</code> <code>ColoredCircle</code> <p>Notice that now we are always passing <code>Circle</code> as argument.  So obviously, if a method can accept <code>Object</code>, it can also accept <code>Circle</code>.</p> Method Descriptor Return Type Compilation <code>Object f(Circle)</code> <code>Object</code> <code>Circle f(Circle)</code> <code>Circle</code> <code>ColoredCircle f(Circle)</code> <code>ColoredCircle</code> <p>Similarly, notice that we are always going to assign the return value to a variable that can accept <code>Circle</code>.  So if the method always returns <code>ColoredCircle</code>, it can be assigned to <code>Circle</code>.</p> <p>The result now conforms to PECS!  So to derive PECS, you can change your point of view from client to implementer.  This follows the explanation we have given for <code>copyTo</code> and <code>copyFrom</code>.  We are -- after all -- the implementer of these two functions.  In the case of <code>copyTo</code>, we are always going to invoke the line</p> <pre><code>        dest.set(i, this.get(i));\n</code></pre> <p>This is similar to how we always execute <code>res2 = f(arg2);</code>.  Our choice of the type we can use for <code>res2</code> and <code>arg2</code> are now restricted.  In our derivation here, we change the method descriptor.  But in the explanation in this unit, we restrict the type parameter <code>T</code> to behave the way we want it to by using either upper-bounded or lower-bounded wildcards.</p>"},{"location":"26-wildcard.html#unbounded-wildcards","title":"Unbounded Wildcards","text":"<p>It is also possible to have unbounded wildcards, such as <code>Seq&lt;?&gt;</code>.  <code>Seq&lt;?&gt;</code> is the supertype of every parameterized type of <code>Seq&lt;T&gt;</code>.  Recall that <code>Object</code> is the supertype of all reference types.  When we want to write a method that takes in a reference type, but we want the method to be flexible enough, we can make the method accept a parameter of type <code>Object</code>.  Similarly, <code>Seq&lt;?&gt;</code> is useful when you want to write a method that takes in an array of some specific type, and you want the method to be flexible enough to take in an array of any type.  For instance, if we have:</p> <pre><code>void foo(Seq&lt;?&gt; seq) {\n}\n</code></pre> <p>We could call it with: <pre><code>Seq&lt;Circle&gt; circleSeq;\nSeq&lt;String&gt; stringSeq;\nfoo(circleSeq); // ok\nfoo(stringSeq); // ok\n</code></pre></p> <p>A method that takes in generic type with unbounded wildcard would be pretty restrictive, however.  Consider the following:</p> <pre><code>void foo(Seq&lt;?&gt; seq) {\n    :\n  x = seq.get(0);\n  seq.set(0, y);\n}\n</code></pre> <p>What should the type of the returned element <code>x</code> be?  Since <code>Seq&lt;?&gt;</code> is the supertype of all possible <code>Seq&lt;T&gt;</code>, the method <code>foo</code> can receive an instance of <code>Seq&lt;Circle&gt;</code>, <code>Seq&lt;String&gt;</code>, etc. as an argument.  The only safe choice for the type of <code>x</code> is <code>Object</code>.</p> <p>The type for <code>y</code> is every more restrictive.  Since there are many possibilities of what type of array it is receiving, we can only put <code>null</code> into <code>array</code>! </p> <p>There is an important distinction to be made between <code>Seq</code>, <code>Seq&lt;?&gt;</code> and <code>Seq&lt;Object&gt;</code>.  Whilst <code>Object</code> is the supertype of all <code>T</code>, it does not follow that <code>Seq&lt;Object&gt;</code> is the supertype of all <code>Seq&lt;T&gt;</code> due to generics being invariant. Therefore, the following statements will fail to compile:</p> <p>Cannot Compile</p> <pre><code>Seq&lt;Object&gt; seq1 = new Seq&lt;String&gt;(0); \nSeq&lt;Object&gt; seq2 = new Seq&lt;Integer&gt;(0);\n</code></pre> <p>Whereas the following statements will compile:</p> <p>Compile</p> <pre><code>Seq&lt;?&gt; seq1 = new Seq&lt;String&gt;(0);  // Does compile\nSeq&lt;?&gt; seq2 = new Seq&lt;Integer&gt;(0); // Does compile\n</code></pre> <p>If we have a function <pre><code>void bar(Seq&lt;Object&gt; seq) {\n}\n</code></pre></p> <p>Then, the method <code>bar</code> is restricted to only takes in a <code>Seq&lt;Object&gt;</code> instance as argument.</p> <pre><code>Seq&lt;Circle&gt; circleSeq;\nSeq&lt;String&gt; stringSeq;\nbar(circleSeq); // compilation error\nbar(stringSeq); // compilation error\n</code></pre> <p>What about raw types?  Suppose we write the method below that accepts a raw type</p> <pre><code>void qux(Seq seq) {\n}\n</code></pre> <p>Then, the method <code>qux</code> is also flexible enough to take in any <code>Seq&lt;T&gt;</code> as argument.</p> <pre><code>Seq&lt;Circle&gt; circleSeq;\nSeq&lt;String&gt; stringSeq;\nqux(circleSeq); \nqux(stringSeq); \n</code></pre> <p>Unlike <code>Seq&lt;?&gt;</code>, however, the compiler does not have the information about the type of the component of the array, and cannot type check for us.  It is up to the programmer to ensure type safety.  For this reason, we must not use raw types.</p> <p>... we must not use raw types.</p> <p>Intuitively, we can think of <code>Seq&lt;?&gt;</code>, <code>Seq&lt;Object&gt;</code>, and <code>Seq</code> as follows:</p> <ul> <li><code>Seq&lt;?&gt;</code> is a sequence of objects of some specific, but unknown type;</li> <li><code>Seq&lt;Object&gt;</code> is a sequence of <code>Object</code> instances, with type checking by the compiler;</li> <li><code>Seq</code> is a sequence of <code>Object</code> instances, without type checking.</li> </ul> <p>Unbounded and Non Wildcard</p> <p>For completeness, we will show the visualization in class diagram for <code>Seq&lt;?&gt;</code> and for non wildcard such as <code>Seq&lt;Circle&gt;</code>.  In the case of unbounded, it actually encompasses all types!</p> <p></p> <p>Clearly, it cannot be a subtype of anything besides <code>Seq&lt;?&gt;</code> and <code>Object</code>.  The latter because <code>Object</code> is the root of the class hierarchy.  But at that point, we cannot invoke the methods intended for <code>Seq</code>.  So while it is more general, it is less flexible to use <code>Object</code>.</p> <p>Now for non wildcard, it is actually encompasses just that single type.  This is why <code>Seq&lt;Circle&gt;</code> is a subtype of both <code>Seq&lt;? extends Circle&gt;</code> and <code>Seq&lt;? super Circle&gt;</code> when we reason only using class diagram visualization.</p> <p></p>"},{"location":"26-wildcard.html#back-to-contains","title":"Back to <code>contains</code>","text":"<p>Now, let's simplify our <code>contains</code> methods with the help of wildcards.  Recall that to add flexibility into the method parameter and allow us to search for a shape in an array of circles, we have modified our method into the following:</p> contains v0.6<pre><code>class A {\n  public static &lt;S, T extends S&gt; boolean contains(Seq&lt;T&gt; seq, S obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      T curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>Can we make this simpler using wildcards?  Since we want to search for an object of type <code>S</code> in a sequence of its subtype, we can remove the second parameter type <code>T</code> and change the type of <code>seq</code> to <code>Seq&lt;? extends S&gt;</code>:</p> contains v0.7<pre><code>class A {\n  public static &lt;S&gt; boolean contains(Seq&lt;? extends S&gt; seq, S obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      S curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>We can double-check that <code>seq</code> is a producer (it produces <code>curr</code> on Line 5) and this follows the PECS rules. Now, we can search for a shape in a sequence of circles.</p> <pre><code>A.&lt;Shape&gt;contains(circleSeq, shape);\n</code></pre> <p>What is the difference between the two?  In <code>contains</code> v0.6, we require two type parameters while in <code>contains</code> v0.7 we only require one.  Say we have both versions in two different classes: <code>A::contains(Seq&lt;? extends S&gt;, S)</code> and <code>B::contains(Seq&lt;T&gt;, S)</code>.  Then we have the following behavior:</p> <pre><code>A.&lt;Shape&gt;contains(circleSeq, shape); // OK\nB.&lt;Shape&gt;contains(circleSeq, shape); // ERROR: wrong number of type arguments; required 2\n\nA.&lt;Shape, Circle&gt;.contains(circleSeq, shape); // ERROR: wrong number of type arguments; required 1\nB.&lt;Shape, Circle&gt;.contains(circleSeq, shape); // OK\n</code></pre>"},{"location":"26-wildcard.html#revisiting-raw-types","title":"Revisiting Raw Types","text":"<p>In previous units, we said that you may use raw types only in two scenarios. Namely, when using generics and <code>instanceof</code> together, and when creating arrays. However, with unbounded wildcards, we can now see it is possible to remove both of these exceptions. We can now use <code>instanceof</code> in the following way:</p> <pre><code>a instanceof A&lt;?&gt; \n</code></pre> <p>Recall that in the example above, <code>instanceof</code> checks of the run-time type of <code>a</code>.  Previously, we said that we can't check for, say,</p> <pre><code>a instanceof A&lt;String&gt; \n</code></pre> <p>since the type argument <code>String</code> is not available during run-time due to erasure.  Using <code>&lt;?&gt;</code> fits the purpose here because it explicitly communicates to the reader of the code that we are checking that <code>a</code> is an instance of <code>A</code> with some unknown (erased) type parameter.</p> <p>Similarly, we can create arrays in the following way:</p> <pre><code>new Comparable&lt;?&gt;[10];\n</code></pre> <p>Previously, we said that we could not create an array using the expression <code>new Comparable&lt;String&gt;[10]</code> because generics and arrays do not mix well.  Java insists that the array creation expression uses a reifiable type, i.e., a type where no type information is lost during compilation.  Unlike <code>Comparable&lt;String&gt;</code>, however, <code>Comparible&lt;?&gt;</code> is reifiable.  Since we don't know what is the type of <code>?</code>, no type information is lost during erasure!</p> <p>Going forward now in the module, we will not permit the use of raw types in any scenario.</p> <p>No More Raw Type</p> <p>We will NOT permit the use of raw types in any scenario.</p> <ol> <li> <p>The reasoning can be made more abstract without restricting <code>T</code> but that will only complicate things and make it more difficult to follow the argument.\u00a0\u21a9</p> </li> <li> <p>CEPS? PSCE?\u00a0\u21a9</p> </li> </ol>"},{"location":"27-inference.html","title":"Unit 27: Type Inference","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be familiar how Java infers missing type arguments.</li> </ul>"},{"location":"27-inference.html#motivation","title":"Motivation","text":"<p>We have seen in the past units the importance of types in preventing run-time errors.  Utilizing types properly can help programmers catch type mismatch errors that could have caused a program to fail during run-time, possibly after it is released and shipped.</p> <p>By including type information everywhere in the code, we make the code explicit in communicating the intention of the programmers to the readers.  Although it makes the code more verbose and cluttered -- it is a small price to pay for ensuring the type correctness of the code and reducing the likelihood of bugs as the code complexity increases.</p> <p>Java, however, allows the programmer to skip some of the type annotations and try to infer the type argument of a generic method and a generic type, through the type inference process.  The basic idea of type inference is simple:</p> <p>Java will looking among the matching types that would lead to successful type checks, and pick the most specific ones.</p> <p>There are deviations to the \"most specific\" ones but that is because Java will only infer based on the type that is available in the type constraints.  Remember, when Java is performing compilation, it somewhat guarantees that the compiled code (i.e., the JVM bytecode) can be used regardless of what classes are going to be added in the future.</p> <p>Inferring the type allows you to write less code.  This is especially useful if the type that is used is horribly long.  Here is an example of a possibly horribly long generic type.</p> <pre><code>Map&lt;String, Map&lt;String, Map&lt;String, String&gt;&gt;&gt; map;\n</code></pre> <p>That is only variable declaration.  We will have to copy the type to instantiate the <code>Map</code>.</p>"},{"location":"27-inference.html#diamond-operator","title":"Diamond Operator","text":"<p>One example of type inference is the diamond operator <code>&lt;&gt;</code> when we insantiate a generic type using the <code>new</code> operator:</p> <pre><code>Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;();\n</code></pre> <p>Java can infer that <code>p</code> should be an instance of <code>Pair&lt;String, Integer&gt;</code> since the compile-time type of <code>p</code> is <code>Pair&lt;String, Integer&gt;</code>.  The line above is equivalent to:</p> <pre><code>Pair&lt;String,Integer&gt; p = new Pair&lt;String,Integer&gt;();\n</code></pre> <p>So now, we can immediately see how this is useful for our <code>Map</code>.  We can simply type</p> <pre><code>map = new Map&lt;&gt;();\n</code></pre> <p>and voila, we do not have to copy the entire type.  It should be noted that there is a slight drawback to this.  We have to be careful in typing the type during the declaration of the variable <code>map</code>.  If there is a mistake there, Java type inference cannot help you.  On the other hand, if you spelled out the type in two places, it is like having to \"confirm your password\".</p>"},{"location":"27-inference.html#argument-typing","title":"Argument Typing","text":"<p>We have been invoking </p> Seq v0.7<pre><code>class A {\n  public static &lt;S&gt; boolean contains(Seq&lt;? extends S&gt; seq, S obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      S curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>by explicitly passing in the type argument <code>Shape</code> (also called type witness in the context of type inference).</p> <pre><code>     A.&lt;Shape&gt;contains(circleSeq, shape);\n</code></pre> <p>We could remove the type argument <code>&lt;Shape&gt;</code> so that we can call <code>contains</code> just like a non-generic method:</p> <pre><code>     A.contains(circleSeq, shape);\n</code></pre> <p>and Java could still infer that <code>S</code> should be <code>Shape</code>.  The type inference process looks for all possible types that match (that are known from type constraints).  In this example, the type of the two parameters must match.  Let's consider each individually first:</p> <ul> <li>An object of type <code>Shape</code> is passed as an argument to the parameter <code>obj</code> (i.e., the second parameter).  So <code>S</code> might be <code>Shape</code> or, if widening type conversion has occurred, one of the other supertypes of <code>Shape</code>. Therefore, we can say that <code>Shape &lt;: S &lt;: Object</code>.<ul> <li>For obvious reason, we put the type upper-bound at <code>Object</code> because <code>Object</code> has no supertype.</li> </ul> </li> <li>A <code>Seq&lt;Circle&gt;</code> has been passed into <code>Seq&lt;? extends S&gt;</code>.  Because Java generic is invariant and wild card works by substitution, the only possible type for <code>?</code> is <code>Circle</code>.<ul> <li>We start with <code>? extends S</code> and we replace <code>?</code> with <code>Circle</code>, so this gives us <code>Circle extends S</code>.</li> <li>In other words, we have <code>Circle &lt;: S &lt;: Object</code>.</li> </ul> </li> </ul> <p>Solving for these two constraints on <code>S</code>, we get the following:</p> <pre><code>Shape &lt;: S &lt;: Object \n</code></pre> <p>We therefore know that <code>S</code> could be <code>Shape</code> or one of its supertypes: <code>GetAreable</code> and <code>Object</code>.   We choose the lower bound, so <code>S</code> is inferred to be <code>Shape</code>.</p> <p>Type inferencing can have unexpected consequences.  Let's consider an older version of <code>contains</code> that we wrote:</p> contains v0.4<pre><code>class A {\n  public static &lt;T&gt; boolean contains(T[] array, T obj) {\n    for (T curr : array) {\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>Recall that we want to prevent nonsensical calls where we are searching for an integer in an array of strings.</p> <pre><code>String[] strArray = new String[] { \"hello\", \"world\" };\nA.&lt;String&gt;contains(strArray, 123); // type mismatch error\n</code></pre> <p>But, if we write:</p> <pre><code>A.contains(strArray, 123); // ok!  (huh?)\n</code></pre> <p>The code compiles!  Let's go through the type inferencing steps to understand what happened.  Again, we have two parameters:</p> <ul> <li><code>strArray</code> has the type <code>String[]</code> and is passed to <code>T[]</code>.  So <code>T</code> must be <code>String</code> or its superclass <code>Object</code> (i.e. <code>String &lt;: T &lt;: Object</code>).  The latter is possible since Java array is covariant.</li> <li><code>123</code> is passed as type <code>T</code>.  Since <code>123</code> is a primitive <code>int</code> and <code>T</code> is a reference type, we auto-box <code>int</code> into the wrapper class <code>Integer</code>.  So the value is treated as <code>Integer</code> and, therefore, <code>T</code> must be either <code>Integer</code>,  or its superclasses <code>Number</code>, and <code>Object</code> (i.e. <code>Integer &lt;: T &lt;: Object</code>). </li> </ul> <p>Solving for these two constraints:</p> <pre><code>Object &lt;: T &lt;: Object\n</code></pre> <p>Therefore <code>T</code> can only have the type <code>Object</code>, so Java infers <code>T</code> to be <code>Object</code>.  But why is the type lower-bound also <code>Object</code> and not one of <code>String</code> or <code>Integer</code>?  This is because <code>String</code> and <code>Integer</code> has no other common supertype<sup>1</sup> besides <code>Object</code>.</p> <p>The code above is equivalent to:</p> <pre><code>A.&lt;Object&gt;contains(strSeq, 123);\n</code></pre> <p>And our <code>contains</code> v0.4 is actually quite fragile and does not work as intended.  We were bitten by the fact that the Java array is covariant, yet again.</p>"},{"location":"27-inference.html#target-typing","title":"Target Typing","text":"<p>The example above performs type inferencing on the parameters of the generic methods.  Type inferencing can involve the type of the expression as well.  This is known as target typing.  Take the following upgraded version of <code>findLargest</code>:</p> findLargest v0.6<pre><code>public static &lt;T extends GetAreable&gt; T findLargest(Seq&lt;? extends T&gt; seq) {\n  double maxArea = 0;\n  T maxObj = null;\n  for (int i = 0; i &lt; seq.getLength(); i++) {\n    T curr = seq.get(i);\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n      maxObj = curr;\n    }\n  }\n  return maxObj;\n}\n</code></pre> <p>and we call</p> <pre><code>Shape o = A.findLargest(new Seq&lt;Circle&gt;(0));\n</code></pre> <p>We have a few more constraints to check:</p> <ul> <li>Due to target typing, the return type of <code>T</code> must be a subtype of <code>Shape</code> (i.e. <code>T &lt;: Shape</code>)</li> <li>Due to the bound of the type parameter (i.e., <code>&lt;T extends GetAreable&gt;</code>), <code>T</code> must be a subtype of <code>GetAreable</code> (i.e. <code>T &lt;: GetAreable</code>)</li> <li>Due to argument typing, <code>Seq&lt;Circle&gt;</code> must be a subtype of <code>Seq&lt;? extends T&gt;</code>, so <code>?</code> is <code>Circle</code> because Java generic is invariant.  This means, <code>T</code> must be the supertype of <code>Circle</code> (i.e., <code>Circle &lt;: T &lt;: Object</code>).</li> </ul> <p>Solving for all three of these constraints:</p> <pre><code>Circle &lt;: T &lt;: Shape\n</code></pre> <p>The lower bound is <code>Circle</code>, so the call above is equivalent to:</p> <pre><code>Shape o = A.&lt;Circle&gt;findLargest(new Seq&lt;Circle&gt;(0));\n</code></pre>"},{"location":"27-inference.html#further-type-inference-examples","title":"Further Type Inference Examples","text":"<p>We now return to our <code>Circle</code> and <code>ColoredCircle</code> classes and the <code>GetAreable</code> interface. Recall that <code>Circle</code> implements <code>GetAreable</code> and <code>ColoredCircle</code> inherits from <code>Circle</code>.</p>"},{"location":"27-inference.html#example-1","title":"Example 1","text":"<p>Consider the following method signature of a generic method <code>foo</code>:</p> <pre><code>public &lt;T extends Circle&gt; T foo(Seq&lt;? extends T&gt; seq)\n</code></pre> <p>Then we consider the following code excerpt:</p> <pre><code>ColoredCircle c = foo(new Seq&lt;GetAreable&gt;());\n</code></pre> <p>What does the java compiler infer <code>T</code> to be? Lets look at all of the constraints on <code>T</code>.</p> <ul> <li>Argument Typing: <code>Seq&lt;GetAreable&gt;</code> is passed into <code>Seq&lt;? extends T&gt;</code>.<ul> <li><code>?</code> must be <code>GetAreable</code>, so we have <code>GetAreable extends T</code>.</li> <li>Type Constraint: <code>GetAreable &lt;: T &lt;: Object</code>.</li> </ul> </li> <li>Target Typing: <code>T</code> is assigned to <code>ColoredCircle</code>.<ul> <li><code>T</code> must be a subtype of <code>ColoredCircle</code>.</li> <li>Type Constraint: <code>T &lt;: ColoredCircle</code>.</li> </ul> </li> <li>Type Parameter: <code>&lt;T extends Circle&gt;</code><ul> <li>Type Constraint: <code>T &lt;: Circle</code>.</li> </ul> </li> </ul> <p>Type Constraints</p> <ul> <li><code>GetAreable &lt;: T &lt;: Object</code></li> <li><code>T &lt;: ColoredCircle</code></li> <li><code>T &lt;: Circle</code></li> </ul> <p>We can see that there no solution to our contraints, <code>T</code> can not be both a subtype of <code>ColoredCircle</code> and a supertype of <code>GetAreable</code> and therefore the Java compiler can not find a type <code>T</code>. The Java compiler will throw an error stating the inference variable <code>T</code> has incompatible bounds.</p>"},{"location":"27-inference.html#example-2","title":"Example 2","text":"<p>Lets consider another example using the following method signature of a generic method <code>bar</code>:</p> <pre><code>public &lt;T extends Circle&gt; T bar(Seq&lt;? super T&gt; seq)\n</code></pre> <p>Then we consider the following code excerpt:</p> <pre><code>GetAreable c = bar(new Seq&lt;Circle&gt;());\n</code></pre> <p>What does the java compiler infer <code>T</code> to be? Again, lets look at all of the constraints on <code>T</code>.</p> <ul> <li>Argument Typing: <code>Array&lt;Circle&gt;</code> is passed into <code>Array&lt;? super T&gt;</code>.<ul> <li><code>?</code> must be <code>Circle</code>, so we have <code>Circle super T</code>.</li> <li>Type Constraint: <code>T &lt;: Circle</code>.</li> </ul> </li> <li>Target Typing: <code>T</code> is assigned to <code>GetAreable</code>.<ul> <li><code>T</code> must be a subtype of <code>GetAreable</code>.</li> <li>Type Constraint: <code>T &lt;: GetAreable</code>.</li> </ul> </li> <li>Type Parameter: <code>&lt;T extends Circle&gt;</code><ul> <li>Type Constraint: <code>T &lt;: Circle</code>.</li> </ul> </li> </ul> <p>Type Constraints</p> <ul> <li><code>T &lt;: GetAreable</code></li> <li><code>T &lt;: Circle</code></li> </ul> <p>Solving for these two constraints, we can simplify it to:</p> <pre><code>T &lt;: Circle\n</code></pre> <p>Whilst <code>ColoredCircle</code> is also a subtype of <code>Circle</code> it is not included in the type constraint and therefore the compiler does not consider this class during type inference.  Indeed, the compiler cannot be aware<sup>2</sup> of all subtypes of <code>Circle</code> and there could be more than one subtype. Therefore <code>T</code> can only have the type <code>Circle</code>, so Java infers <code>T</code> to be <code>Circle</code>. </p> <p>Multiple <code>?</code></p> <p>Recap that we should treat each wildcard <code>?</code> separately.  In other words, each <code>?</code> should be treated as potentially different type.  An easy way to remember this is to put a number for each <code>?</code>.</p> <p>So the first <code>?</code> you see should be renamed into <code>?1</code>.  This is similar to how Java treated this internally by renaming it into <code>CAP#1</code>.  In the end, the different <code>?</code> may be the same type, but at the start you should treat them separately.</p> <p>Also, please remember that the focus of the type inference is to infer the type parameter and not to infer each <code>?</code>.  So please focus on the type parameter and not the wildcards.</p> <p>Of course, from our discussion, we simply replace the wildcards with a type because there has to be an explicit usage of it for us to infer.  But if there is no usage at all (e.g., the method with type parameter is not even invoked), then <code>?</code> can be anything.  This may lead to a potential issue where the code may initially compile but after the usage is added, it no longer compiles.</p>"},{"location":"27-inference.html#rules-for-type-inference","title":"Rules for Type Inference","text":"<p>We now summarize the steps for type inference.  First, we figure out all of the type constraints and then we solve these constraints. If no type can satisfy all the constraints, we know that Java will fail to compile.</p> <p>So where do these type constraints come from?</p> <ol> <li>Argument Typing: Type of argument is passed to parameter.</li> <li>Target Typing: Return type is passed to variable.</li> <li>Type Parameter: The declared type, especially for bounded type parameter.</li> </ol> <p>Once you have collected all the type constraints, you can start resolving the type constraints.  If in resolving the type constraints for a given type parameter <code>T</code> we are left with:</p> <ul> <li><code>Type1 &lt;: T &lt;: Type2</code>, then <code>T</code> is inferred as <code>Type1</code>.</li> <li><code>Type1 &lt;: T</code><sup>3</sup>, then <code>T</code> is inferred as <code>Type1</code>.<ul> <li>Alternatively, consider the constraint as <code>Type1 &lt;: T &lt;: Object</code>.</li> </ul> </li> <li><code>T &lt;: Type2</code>, then <code>T</code> is inferred as <code>Type2</code>.<ul> <li>Alternatively, consider the constraint as <code>Type2 &lt;: T &lt;: Type2</code>.</li> </ul> </li> </ul> <p>where <code>Type1</code> and <code>Type2</code> are arbitrary types.</p> <p>No Usage Typing</p> <p>The type constraints come strictly from the three parts above.  How the type is used is irrelevant for inference.  This may lead to a failure in type inference although there is actually a type that can be used.  Consider the same example from above</p> <pre><code>public &lt;T extends Circle&gt; T bar(Array&lt;? super T&gt; array)\n</code></pre> <p>Now consider the following code snippet where <code>getColor</code> is a method available in <code>ColoredCircle</code> but not <code>Circle</code>.</p> <pre><code>bar(new Array&lt;Circle&gt;()).getColor();\n</code></pre> <p>Remember that the type inference procedure above inferred the <code>T</code> is <code>Circle</code>.  But <code>Circle</code> has no method <code>getColor</code>.  So this will end in a compilation error.  However, also note that if the inference was <code>T</code> is <code>ColoredCircle</code>, the compilation should have been successful.  This shows that the type inference does not take into account how the type is going to be used.</p> <ol> <li> <p>The reality is more complicated.  Both <code>String</code> and <code>Integer</code> are subtype of <code>Comparable&lt;T&gt;</code> for their respective <code>T</code>.  So the deduced type is closer to <code>Object &amp; Comparable</code>.  Such complications do not occur if we create our own classes.  In most cases, we will consider only the \"obvious\" supertype and ignore <code>Comparable</code> (or any type after <code>&amp;</code>).\u00a0\u21a9</p> </li> <li> <p>Due to evolving specifications of software, at the time of compilation, a subtype may not have even been conceived of or written yet!\u00a0\u21a9</p> </li> <li> <p>Note that <code>T &lt;: Object</code> is implicit here. We can see that this case could also be written as <code>Type1 &lt;: T &lt;: Object</code>, and would therefore also be explained by the previous case (<code>Type1 &lt;: T &lt;: Type2</code>).\u00a0\u21a9</p> </li> </ol>"},{"location":"28-immutability.html","title":"Unit 28: Immutability","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand when a class is immutable or not.</li> <li>be able to create an immutable class.</li> </ul>"},{"location":"28-immutability.html#avoiding-change","title":"Avoiding Change","text":"<p>So far in this course, we have been focusing on three ways of dealing with software complexity: (i) by encapsulating and hiding the complexity behind abstraction barriers, (ii) by using a language with a strong type system and adhering to the subtyping substitution principle, and (iii) applying the abstraction principles and reusing code written as functions, classes, and generics types.</p> <p>Another useful strategy to reduce bugs when code complexity increases is to avoid change altogether.  That is not to say we do not want our specification/design to change.  It is a fact of life as a software engineer that specification and design will change.  What we want instead is for instances of our class to be unchangeable, at least externally.</p> <p>This can be done by making our classes immutable.  We create an instance of an immutable class, the instance cannot have any visible changes outside its abstraction barrier.  This means that every call of the instance's method must behave the same way throughout the lifetime of the instance.</p> <p>Immutable Class</p> <p>An immutable class is a class for which there cannot be any visible changes outside of its abstraction barrier.</p> <p>There are many advantages of why we want to make our class immutable when possible.  To start, let's revisit a common bug due to aliasing.  Recall the following example from Unit 9,  where we create two circles <code>c1</code> and <code>c2</code> centered at the origin (0, 0).</p> <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\n</code></pre> <p>Let's say that we have the <code>moveTo</code> method in both <code>Circle</code> and <code>Point</code>, to move the circle and point respectively.</p> Mutable Point<pre><code>public class Point {\n  private double x;\n  private double y;\n\n    :\n\n  public void moveTo(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre> Mutable Circle<pre><code>public class Circle {\n  private Point c;\n  private double r;\n\n  public Circle (Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n    :\n\n  public void moveTo(double x, double y) {\n    c.moveTo(x, y);\n  }\n}\n</code></pre> <p>Suppose we want to move <code>c1</code> and only <code>c1</code> to be centered at (1,1).</p> <pre><code>c1.moveTo(1, 1);\n</code></pre> <p>The line of code above surprisingly moved the center of both <code>c1</code> and <code>c2</code>, due to both circles <code>c1</code> and <code>c2</code> sharing the same point.  We have explored a solution below:</p> <pre><code>Point p1 = new Point(0, 0);\nCircle c1 = new Circle(p1, 1);\n\nPoint p2 = new Point(0, 0);\nCircle c2 = new Circle(p2, 4);\n\nc1.moveTo(1, 1);\n</code></pre> <p>This approach avoids sharing references by creating copies of our points so that no two references point to the same instance, avoiding aliasing altogether.  This partial fix, however, comes with extra costs in computational resources as the number of objects may proliferate.</p> <p>This is also not a complete solution because surprisingly, we can move <code>c2</code> without calling <code>c2.moveTo(1, 1)</code> but by calling the code below.</p> <pre><code>p2.moveTo(1, 1);\n</code></pre> <p>Let's now see how immutability can help us resolve our problem.</p>"},{"location":"28-immutability.html#immutable-points-and-circles","title":"Immutable Points and Circles","text":""},{"location":"28-immutability.html#immutable-points","title":"Immutable Points","text":"<p>Let's start by making our <code>Point</code> class immutable.  We start by making the fields <code>final</code> to signal our intention that we do not intend to assign another value to them.  Now that the <code>x</code> and <code>y</code> cannot be re-assigned (a new value or even the same value), to move a point, we shouldn't re-assign to the fields <code>x</code> and <code>y</code> anymore.  Instead, we return a new <code>Point</code> instance to prevent mutating the current instance, as follows:</p> Immutable Point<pre><code>public final class Point {\n  private final double x;\n  private final double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public Point moveTo(double x, double y) {\n    return new Point(x, y);\n  }\n\n    :\n\n  @Override\n  public String toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\n</code></pre> <p>Note that, to avoid (likely malicious or ignorant) subclasses of <code>Point</code> overriding the methods to make it appears that the point has mutated, it is necessary that we declare immutable classes as <code>final</code> to disallow inheritance.</p> <p>Analysis of Points</p> <p>It is always good to check if the <code>Point</code> class above are really immutable.  Assume that the public methods available are:</p> <ul> <li><code>Point Point::moveTo(double, double)</code></li> <li><code>String Point::toString()</code></li> <li><code>double Point::getX()</code></li> <li><code>double Point::getY()</code></li> </ul> <p>To see why <code>Point</code> is indeed is immutable, we look at the following code snippet.</p> <pre><code>Point p = new Point(1.0, 1.0);\np.getX(); // 1.0\n  :       // any sequence of invocation of methods in Point`\np.getX(); // 1.0\n</code></pre> <p>No methods in <code>Point</code> can actually change the field <code>x</code> or <code>y</code>.  First, notice that <code>x</code> and <code>y</code> are <code>double</code>.  So the only way they can be changed is by assignment to the fields.  But the fields are declared <code>final</code>, so there can be no assignment done on them.</p> <p>The keyword <code>final</code> on the fields are not necessary because there is no assignment at all to the fields.  However, it is still a good practice to have them.  Just in case someone in the future try to perform an assignment on the field and change the <code>Point</code> class from immutable to mutable.</p>"},{"location":"28-immutability.html#immutable-circle","title":"Immutable Circle","text":"<p>Now, let's make <code>Circle</code> immutable:</p> Immutable Circle<pre><code>public final class Circle {\n  private final Point c;\n  private final double r;\n\n  public Circle (Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n    :\n\n  public Circle moveTo(double x, double y) {\n    return new Circle(c.moveTo(x, y), this.r);\n  }\n}\n</code></pre> <p>With <code>Point</code> being immutable, we can be sure that the only way for the field <code>c</code> to be changed is by assigning a new value to <code>c</code>.  However, this is again prevented by the keyword <code>final</code> in the field <code>c</code>.  And again, even without such keyword, there is still no assignment on it.  So we can be sure that <code>Circle</code> is also immutable.</p> <p>In other words, once an instance is created, it remains unchanged (outside the abstraction barrier).</p> <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\nc1.moveTo(1, 1); // c1 remains unchanged\n</code></pre> <p>To update the variable <code>c1</code>, we need to explicitly reassign it.</p> <pre><code>c1 = c1.moveTo(1, 1);\n</code></pre> <p>Now, <code>c1</code> moves to a new location, but <code>c2</code> remains unchanged.</p>"},{"location":"28-immutability.html#comparison-with-mutable-version","title":"Comparison with Mutable Version","text":"<p>Compare our new immutable approach to the two approaches above. The first shares all the references and is bug-prone.  The second creates a new copy of the instance every time and is resource-intensive.  Our third approach, using immutable classes, allows us to share all the references until we need to modify the instance, in which case we make a copy.  Such a copy-on-write semantic allows us to avoid aliasing bugs without creating excessive copies of objects.</p> <p>Note that the <code>final</code> keyword prevents assigning new value to the field.  Unfortunately, it does not prevent the field from being mutated.  So, to ensure that the classes we create are immutable, we have to ensure that the fields are themselves immutable.</p>"},{"location":"28-immutability.html#necessity-of-final-keyword-on-class","title":"Necessity of Final Keyword on Class","text":"<p>We mentioned that it is necessary that we declare immutable classes as <code>final</code> to disallow inheritance.  So let us elaborate this further.  Consider the immutable <code>Point</code> from above.  However, consider the case that the we do not declare the class as <code>final</code>.  Now let us create a subclass of it.</p> Subclass Violation<pre><code>public class MutablePoint extends Point {\n  private double x;\n  private double y;\n\n  public MutablePoint(double x, double y) {\n    super(x, y);\n    this.x = x;\n    this.y = y;\n  }\n\n  @Override\n  public Point moveTo(double x, double y) {\n    this.x = x;\n    this.y = y;\n    return super.moveTo(x, y);\n  }\n\n    :\n\n  @Override\n  public String toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\n</code></pre> <p>You can see that we kept a duplicate of the internals of <code>Point</code> in <code>MutablePoint</code>, which is a bad practice.  But it also shows that if we allow inheritance, we may end up with the following behavior that shows the mutability of <code>Point</code>.</p> <pre><code>Point p = new MutablePoint(1, 1); // at (1, 1)\np.moveTo(2, 2); // now it is at (2, 2)\n</code></pre> <p>Although <code>Point</code> is immutable, its subclass <code>MutablePoint</code> is actually mutable.  This also breaks LSP because the subclass breaks the expectation that the superclass is immutable.</p>"},{"location":"28-immutability.html#advantages-of-being-immutable","title":"Advantages of Being Immutable","text":"<p>We have seen how making our classes immutable helps us remove the risk of potential bugs when we use composition and aliasing.  Immutability has other advantages as well.  </p>"},{"location":"28-immutability.html#ease-of-understanding","title":"Ease of Understanding","text":"<p>Code written with immutable objects is easier to reason with and easier to understand.  Suppose we create a <code>Circle</code> and assign it to a local variable:</p> <pre><code>Circle c = new Circle(new Point(0, 0), 8);\n</code></pre> <p>We pass <code>c</code> around to many other methods.  These other methods may invoke <code>c</code>'s methods; we may invoke <code>c</code>'s methods locally as well.  But, despite putting <code>c</code> through so much, unless we have explicitly re-assigned <code>c</code>, we can guarantee that <code>c</code> is still a circle centered at (0,0) with a radius of 8.  This immutable property makes it significantly easier to read, understand, and debug our code.</p> <p>Without this property, we have to trace through all the methods that we pass <code>c</code> to, and each call of <code>c</code>'s methods to make sure that none of these codes modifies <code>c</code>.</p>"},{"location":"28-immutability.html#enabling-safe-sharing-of-objects","title":"Enabling Safe Sharing of Objects","text":"<p>Making a class immutable allows us to safely share instances of the class and therefore reducing the need to create multiple copies of the same object.  For instance, the origin (0, 0) is commonly used.  If the instance is immutable, we can just create and cache a single copy of the origin, and always return this copy when the origin is required.</p> <p>Let modify our <code>Point</code> class so that it creates a single copy of the origin and returns the same copy every time the origin is required.</p> Immutable Point<pre><code>public final class Point {\n  private final double x;\n  private final double y;\n  private final static Point ORIGIN = new Point(0, 0);\n\n  private Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public static Point of(double x, double y) {\n    if (x == 0 &amp;&amp; y == 0) {\n      return ORIGIN;\n    }\n    return new Point(x, y);\n  }\n\n    :\n}\n</code></pre> <p>We made a few changes in the above:</p> <ul> <li>We made the constructor for <code>Point</code> private so that one cannot call the constructor directly.</li> <li>We provide a class factory method named <code>of</code> for the client to create a <code>Point</code> instance.  The <code>of</code> method returns the same instance <code>ORIGIN</code> every time <code>Point.of(0, 0)</code> is called.</li> </ul> <p>Such a design pattern is only safe when the class is immutable.  Consider the mutable version of <code>Point</code> -- calling <code>Point.of(0, 0).moveTo(1, 1)</code> would change every reference to the origin to (1, 1), causing chaos in the code!</p>"},{"location":"28-immutability.html#enabling-safe-sharing-of-internals","title":"Enabling Safe Sharing of Internals","text":"<p>Immutable instances can also share their internals freely.  Consider an immutable implementation of our <code>Seq&lt;T&gt;</code>, called <code>ImmutableSeq&lt;T&gt;</code>.  Let's start with a simple version first.</p> ImmutableSeq v0.1<pre><code>public final class ImmutableSeq&lt;T&gt; {\n  private final T[] array;\n\n  // Only items of type T goes into the array.\n  @SafeVarargs\n  public static &lt;T&gt; ImmutableSeq&lt;T&gt; of(T... items) {\n    return new ImmutableSeq&lt;&gt;(items);\n  }\n\n  private ImmutableSeq(T[] a) {\n    this.array = a;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n}\n</code></pre> <p>There are a few things to note here.</p> <p>Varargs. \u00a0\u00a0 The parameter to the class factory method <code>of</code> has the form <code>T... items</code>.  The triple <code>.</code> notation is a Java syntax for a variable number of arguments of the same type (<code>T</code>).  Often called varargs, this is just syntactic sugar for passing in an array of items to a method.  The method is called variadic method as it can take in a variable number of arguments.  We can then call <code>of</code> with a variable number of arguments, such as:</p> <pre><code>ImmutableSeq&lt;Integer&gt; a;\na = ImmutableSeq.of();\na = ImmutableSeq.of(1, 2, 3);\na = ImmutableSeq.of(1, 2, 3, 4, 5);\n</code></pre> <p>We can also call <code>of</code> with a single array as an argument!</p> <pre><code>ImmutableSeq&lt;Integer&gt; a;\na = ImmutableSeq.of(new Integer[] { 1, 2, 3 });\n</code></pre> <p>Another Main Function</p> <p>Now that we have learnt about vargargs, we can write a different version of the main function.  In this version, instead of having a parameter of an array of <code>String</code> written as <code>String[]</code>, we have a parameter of an array of <code>String</code> written as <code>String...</code>.</p> <pre><code>public static void main(String... args) {\n    :\n}\n</code></pre> <p>@SafeVarargs. \u00a0\u00a0 Since the varargs is just an array, and array and generics do not mix well in Java, the compiler would throw us an unchecked warning.  In this instance, however, we know that our code is safe because we never put anything other than items of type <code>T</code> into the array.  We can use the <code>@SafeVarargs</code> annotation to tell the compiler that we know what we are doing and this varargs is safe.</p> <p>Notice that we removed the <code>set</code> method and there is no other way an external client can modify the array once it is created.  This, of course, assumes that we will only be inserting an immutable object into our immutable sequence.  Unfortunately, this cannot be enforced by the compiler as the generic type <code>T</code> can be anything.</p> <p>Now, suppose that we wish to support a <code>slice</code> method, that returns a new sequence containing only a range of elements in the original sequence.  It behaves as follows:</p> <pre><code>ImmutableSeq&lt;Integer&gt; a = ImmutableSeq.of(10, 20, 30, 40, 50, 60);\nImmutableSeq&lt;Integer&gt; b = a.slice(2, 4); // b is [30, 40, 50]\nb.get(0) // returns 30\nImmutableSeq&lt;Integer&gt; c = b.slice(1, 2); // c is [40, 50]\nc.get(1) // returns 50\n</code></pre> <p>A typical way to implement <code>slice</code> is to allocate a new <code>T[]</code> and copy the elements over.  This operation can be expensive if our <code>ImmutableSeq</code> has millions of elements.  But, since our class is immutable and the internal field <code>array</code> is guaranteed not to mutate, we can safely let <code>b</code> and <code>c</code> refer to the same <code>array</code> from <code>a</code>, and only store the starting and ending index.</p> ImmutableSeq v0.2<pre><code>public final class ImmutableSeq&lt;T&gt; {\n  private final int start;\n  private final int end;\n  private final T[] array;\n\n  @SafeVarargs\n  public static &lt;T&gt; ImmutableSeq&lt;T&gt; of(T... items) {\n    return new ImmutableSeq&lt;&gt;(items, 0, items.length-1);\n  }\n\n  private ImmutableSeq(T[] a, int start, int end) {\n    this.start = start;\n    this.end = end;\n    this.array = a;\n  }\n\n  public T get(int index) {\n    if (index &lt; 0 || this.start + index &gt; this.end) {\n      throw new IllegalArgumentException(\"Index out of bound\");\n    }\n    return this.array[this.start + index];\n  }\n\n  public ImmutableSeq&lt;T&gt; slice(int start, int end) {\n     return new ImmutableSeq&lt;&gt;(this.array, this.start + start, this.start + end);\n  }\n}\n</code></pre>"},{"location":"28-immutability.html#copy-the-input-array","title":"Copy the Input Array","text":"<p><code>ImmutableSeq</code> v0.2 is still not quite immutable even if it contains only immutable elements of type <code>T</code>.  The reason is because an array is also a reference type.  The factory method <code>of</code> may accept an array as an input.  Since we are passing this array as an argument to the constructor, the references are all shared and aliased.  This leads to the following usage that breaks immutability.</p> <pre><code>Integer[] intArr = new Integer[] { 1, 2, 3 };\nImmutableSeq&lt;Integer&gt; a = ImmutableSeq.of(intArr);\na.get(0); // returns 0 because intArr is { 1, 2, 3 }\nintArr[0] = 9;\na.get(0); // returns 0 because intArr is { 9, 2, 3 }\n</code></pre> <p>So we need to remove this aliasing and one way to do that is to explicitly copy the array. We may copy in the constructor of <code>ImmutableSeq</code> but that means the <code>slice</code> method no longer shares the underlying array. To minimize the amount of copying, we copy in the factory method <code>of</code>.</p> ImmutableSeq v0.3<pre><code>public final class ImmutableSeq&lt;T&gt; {\n  private final int start;\n  private final int end;\n  private final T[] array;\n\n  @SafeVarargs\n  public static &lt;T&gt; ImmutableSeq&lt;T&gt; of(T... items) {\n    /**\n     * Prevent aliasing between `array` and `items`\n     * \n     * This suppress warnings is safe because we cannot\n     * even modify the element in `this.array`.\n     */\n    @SuppressWarnings(\"unchecked\");\n    T[] arr = (T[]) new Object[items.length];\n    for (int i=0; i&lt;items.length; i++) {\n      arr[i] = items[i];\n    }\n    return new ImmutableSeq&lt;&gt;(arr, 0, items.length-1);\n  }\n\n  private ImmutableSeq(T[] a, int start, int end) {\n    this.start = start;\n    this.end = end;\n    this.array = a;\n  }\n\n  public T get(int index) {\n    if (index &lt; 0 || this.start + index &gt; this.end) {\n      throw new IllegalArgumentException(\"Index out of bound\");\n    }\n    return this.array[this.start + index];\n  }\n\n  public ImmutableSeq&lt;T&gt; slice(int start, int end) {\n     return new ImmutableSeq&lt;&gt;(this.array, this.start + start, this.start + end);\n  }\n}\n</code></pre>"},{"location":"28-immutability.html#enabling-safe-concurrent-execution","title":"Enabling Safe Concurrent Execution","text":"<p>We will explore concurrent execution of code towards the end of the module, but making our classes immutable goes a long way in reducing bugs related to concurrent execution.  Without going into details here (you will learn the details later), concurrent programming allows multiple threads of code to run in an interleaved fashion, in an arbitrary interleaving order.   If we have complex code that is difficult to debug to begin with, imagine having code where we have to ensure its correctness regardless of how the execution interleaves!  Immutability helps us ensure that regardless of how the code interleaves, our objects remain unchanged.</p>"},{"location":"28-immutability.html#final-immutable","title":"Final \u2260 Immutable","text":"<p>When creating an immutable class, we need to be careful to distinguish between the keywords that helps us avoid accidentally making things easily mutable and the actual concept of immutable class.  For instance, it is insufficient to simply declare all fields with <code>final</code> keywords.  Just because we cannot accidentally update the field, does not mean that the field is immutable.  Consider the same <code>Circle</code> above but with a getter for the center point and now imagine that the <code>Point</code> is mutable.</p> <pre><code>public final class Circle {\n  private final Point c;\n  private final double r;\n\n  public Circle (Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n    :\n\n  public Point getCenter() {\n    return this.c;\n  }\n\n  public Circle moveTo(double x, double y) {\n    return new Circle(c.moveTo(x, y), r);\n  }\n}\n</code></pre> <p>We can then simply retrieve the center point and mutate it externally.</p> <pre><code>Circle c = new Circle(new Point(0, 0), 1);\nc.getCenter().moveTo(1, 1); // assume mutable Point\n</code></pre> <p>On the other hand, it is not even necessary to use the <code>final</code> keyword to make an immutable class.  We simply have to have a class that prevents any and all kinds of sharing by copying all the parameters before assigning them into the fields and copying all return value.  Assume that all classes has a correctly implemented <code>clone()</code> method.  Then the following <code>Circle</code> is immutable even with getter and no <code>final</code> keyword on the fields.  We still need the <code>final</code> keyword on the class to disallow inheritance.</p> <pre><code>public final class Circle {\n  private Point c;\n  private double r;\n\n  public Circle (Point c, double r) {\n    this.c = c.clone();\n    this.r = r; // primitive, no need cloning\n  }\n\n    :\n\n  public Point getCenter() {\n    return this.c.clone();\n  }\n\n  public Circle moveTo(double x, double y) {\n    return new Circle(c.moveTo(x, y), r);\n  }\n}\n</code></pre> <p>That is not to say that the <code>final</code> keyword is not important.  It helps accidental re-assignment and in some cases that is sufficient especially if the fields are of primitive type.  Once we have created one immutable class, we can then create other larger immutable classes by only using immutable classes as fields.</p>"},{"location":"28-immutability.html#trivially-immutable-class","title":"Trivially Immutable Class","text":"<p>We can even have trivially immutable classes.  Consider our old <code>Pair&lt;S, T&gt;</code> class.</p> <pre><code>class Pair&lt;S,T&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>Assuming that <code>S</code> and <code>T</code> are immutable, the generic class <code>Pair&lt;S, T&gt;</code> is also immutable.  This is achieved by simply having no mutator.  Additionally, there is no <code>String toString()</code> method that exposes the internal state!</p> <p>Another way to have a trivially immutable class with mutator is to have no accessor to the mutated state.  If we never expose the mutated internal state, then there is no way to have any visible changes outside of its abstraction barrier.  The following <code>Counter</code> is an example.</p> <pre><code>class Counter {\n  private int val;\n  private int ctx;\n\n  public Counter(int val) {\n    this.val = val;\n    this.ctx = 0;\n  }\n\n  public int get() {\n    this.ctx += 1;\n    return this.val;\n  }\n\n  @Override\n  public String toString() {\n    return \"{\" + this.val + \"}\";\n  }\n}\n</code></pre> <p>Note that the internal state <code>ctx</code> changed but there is no way for us to expose this externally.  So using only its abstraction barrier (i.e., the methods <code>get()</code> and <code>toString()</code>), we can never see any visible changes.</p> <p>Checklist for Immutability</p> <p>The following is a general guide to help you create immutable class.  Some of the items in the checklist may not be necessary but they are good to have.</p> <ol> <li>Ensure that all fields have the <code>final</code> modifier (not necessary but good to have).</li> <li>Ensure that the types of all the fields are immutable classes.</li> <li>Ensure that arrays are copied before assigning to a field.</li> <li>Ensure that there is no mutator.<ul> <li>If there was a mutator and you are modifying the class to be immutable, then you need to return a new instance instead.</li> </ul> </li> <li>Ensure that the class has the <code>final</code> modifier to prevent inheritance.</li> </ol>"},{"location":"29-nested-classes.html","title":"Unit 29: Nested Class","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the need for nested class.</li> <li>understand the behavior of the different kinds of nested class.</li> <li>be able to write nested classes.</li> </ul>"},{"location":"29-nested-classes.html#matryoshka-doll","title":"Matryoshka Doll","text":"<p>So far, we have defined a class only at the \"top-level\" of our program.  Java allows us to define a class within another class, or within a method.</p> <p>A nested class is a class defined within another containing class.  For example, the following declaration declares a private nested class named <code>B</code> within the class <code>A</code>.</p> <pre><code>public class A {\n  private class B {\n      :\n  }\n}\n</code></pre> <p>Nested classes are used to group logically relevant classes together.  Typically, a nested class is tightly coupled with the container class and would have no use outside of the container class.  Nested classes can be used to encapsulate information within a container class, for instance, when the implementation of the container class becomes too complex.  As such, it is useful for \"helper\" classes that serve specific purposes.</p> <p>A nested class is a field of the containing class and can access fields and methods of the container class, including those declared as <code>private</code>.  We can keep the nested class within the abstraction barrier by declaring the nested class as <code>private</code> if there is no need for it to be exposed to the client outside the barrier.  </p> <p>Since the nested class can access the private fields of the container class, we should introduce a nested class only if the nested class belongs to the same encapsulation as the container class.  Otherwise, the container class would leak its implementation details to the nested class.</p> <p>Take the <code>HashMap&lt;K,V&gt;</code> class for instance.  The implementation of <code>HashMap&lt;K,V&gt;</code> contains one top-level class <code>HashMap&lt;K,V&gt;</code> (at Line 124) and several nested classes, including the <code>HashIterator&lt;E&gt;</code> abstract class (at Line 178), which implement an <code>Iterator&lt;E&gt;</code> interface for iterating through the key and value pairs in the map, and a static <code>Entry&lt;K,V&gt;</code> class (at Line 687), which encapsulates a key-value pair in the map.  Some of these classes are declared <code>private</code> if they are only used within the <code>HashMap&lt;K,V&gt;</code> class.</p> <p>Example from CS2030S This Semester</p> <p>We can take another example from your labs on coffee shop simulation.  In one of many possible designs, the subclasses of <code>Event</code>: <code>ArrivalEvent</code>, <code>DepartureEvent</code>, etc. are not used anywhere outside of <code>CoffeeSimulation</code>.  They can be safely encapsulated within <code>CoffeeSimulation</code> as inner classes, so that these classes can access the fields within the <code>CoffeeSimulation</code> class, simplifying their implementation.</p> <p>A nested class can be either static or non-static.  Just like static fields and static methods, a static nested class is associated with the containing class, NOT an instance.  So, it can only access static fields and static methods of the containing class.  A non-static nested class, on the other hand, can access all fields and methods of the containing class.  A non-static nested class is also known as an inner class.</p> <p>Static vs Non-Static</p> <p>Recap the following access behavior:</p> From access Static access Non-Static Static Non-Static <p>The example below shows a container class <code>A</code> with two nested classes, a non-static inner class <code>B</code>, and a static nested class <code>C</code>.  <code>B</code> can access instance fields, instance methods, class fields, and class methods in <code>A</code>.  <code>C</code> can only access the class fields and class methods in <code>A</code>.</p> <pre><code>class A {\n  private int x;\n  static int y;\n\n  class B {\n    void foo() {\n      x = 1; // accessing x in A is OK\n      y = 1; // accessing y in A is OK\n    }\n  }\n\n  static class C {\n    void bar() {\n      x = 1; // accessing x in A is not OK since C is static\n      y = 1; // accessing y is OK\n    }\n  }\n}\n</code></pre> <p>Recall that we recommend that all access to instance fields be done through the <code>this</code> reference.  In the example above, however, we can't access <code>this.x</code> from within <code>B</code>.</p> <pre><code>class A {\n private int x;\n\n class B {\n   void foo() {\n     this.x = 1; // error, but x = 1 is fine!\n   }\n }\n}\n</code></pre> <p>Since <code>this.x</code> is called within a method of <code>B</code>, <code>this</code> would refer to the instance of <code>B</code>, rather than the instance of <code>A</code>.  Java has a piece of syntax called qualified <code>this</code> to resolve this.  A qualified <code>this</code> reference is prefixed with the enclosing class name, to differentiate between the <code>this</code> of the inner class and the <code>this</code> of the enclosing class.  In the example above, we can access <code>x</code> from <code>A</code> through the <code>A.this</code> reference.</p> <pre><code>class A {\n private int x;\n\n class B {\n   void foo() {\n     A.this.x = 1; // ok\n   }\n }\n}\n</code></pre>"},{"location":"29-nested-classes.html#hiding-nested-classes","title":"Hiding Nested Classes","text":"<p>When we use nested classes for encapsulating the implementation details of the enclosing class, it is better to declare them as <code>private</code> nested classes, so that they are not exposed across the abstract barrier, adhering to the information hiding principle. For example, consider the following</p> <pre><code>class A {\n  private class B {\n    public void bar() { \n    }\n  }\n  private static class C {\n  }\n}\n</code></pre> <p>We cannot access <code>A.B</code> or <code>A.C</code>.</p> <pre><code>A.B b; // compilation error\nA.C c; // compilation error\n</code></pre> <p>Note that it is still possible to expose instances of private nested classes outside the enclosing class. For example, let's say we have:</p> <pre><code>class A {\n  private class B {\n    public void bar() { \n    }\n  }\n  B foo() {\n    return new B();\n  }\n}\n</code></pre> <p>We are allowed to call <code>A::foo</code> and obtain a reference to an instance of <code>B</code>, as long as the type <code>B</code> (or rather, <code>A.B</code>) is not used directly.</p> <pre><code>A a = new A();\na.foo();         // return an instance of A.B is OK\nA.B b = a.foo(); // still not allowed since the type A.B is private\n</code></pre> <p>Since the type <code>A.B</code> is private to within <code>A</code>, we cannot call methods of <code>B</code> outside of <code>A</code> as well.</p> <pre><code>A a = new A();\na.foo().bar();  // error since `bar` is defined in a private nested class\n</code></pre> <p>We can still expose the method in the <code>private</code> nested class if the class is a subtype of a non-<code>private</code> type.  Let us illustrate this with an interface.  Instead of returning <code>B</code>, our method <code>foo</code> now returns <code>I</code>.</p> <pre><code>interface I {\n  void bar();\n}\nclass A {\n  private class B implements I {\n    public void bar() { \n    }\n  }\n  I foo() {\n    return new B();\n  }\n}\n</code></pre>"},{"location":"29-nested-classes.html#more-on-static-nested-class","title":"More on Static Nested Class","text":"<p>Recap that from static context we cannot access non-static elements.  As the instance fields of the outer class is a non-static element, we cannot access them.  But also recap that to access the instance field <code>x</code> of the outer class where there is a conflicting name <code>x</code> with a field of the inner class, we require the use of qualified name <code>A.this.x</code>.</p> <p>The two implies that <code>A.this</code> is not going to be used at all by the static nested class.  As such, we should omit them from the stack and heap diagram as well.  To illustrate this difference, consider the following class reproduced from above.</p> <pre><code>class A {\n  private int x = 0;\n  static int y = 1;\n\n  class B {\n    void foo() {\n      x = 1; // accessing x in A is OK (equivalent to A.this.x)\n      y = 1; // accessing y in A is OK (equivalent to A.y)\n    }\n  }\n\n  static class C {\n    void bar() {\n      // x = 1; // removed because we cannot access this\n      y = 1; // accessing y is OK (equivalent to A.y)\n    }\n  }\n\n  void baz() {\n    B b = new B();\n    C c = new C();\n    // Line A\n  }\n}\n</code></pre> <p>Now consider the following code snippet.</p> <pre><code>A a = new A();\na.baz();\n</code></pre> <p>The stack and heap diagram at the line marked Line A is shown below.  The diagram below also illustrates the use of meta space to store the class field <code>A.y</code>. Also, <code>A.this</code> is always captured, so <code>A.this</code> is added to the bottom of the dashed line.</p> <p></p>"},{"location":"29-nested-classes.html#local-class","title":"Local Class","text":"<p>We can also declare a class within a function, just like a local variable.  </p> <p>To motivate this, let's consider how one would use the <code>java.util.Comparator</code> interface.   The <code>Comparator</code> interface allows us to specify how to compare two elements, by implementing this interface with a customized <code>compare()</code> method.  <code>compare(o1,o2)</code> should return</p> Return Value Meaning A negative integer <code>o1</code> is \"less than\" <code>o2</code> The integer <code>0</code> <code>o1</code> is \"equal\" <code>o2</code> A positive integer <code>o1</code> is \"greater than\" <code>o2</code> <p>Suppose we have a list of strings, and we want to sort them in the order of their length, we can write the following method:</p> <pre><code>void sortNames(List&lt;String&gt; names) {\n\n  class NameComparator implements Comparator&lt;String&gt; {\n    public int compare(String s1, String s2) {\n      return s1.length() - s2.length();\n    }\n  }\n\n  names.sort(new NameComparator());\n}\n</code></pre> <p>This makes the code easier to read since we keep the definition of the class and its usage closer together.</p> <p>Classes like <code>NameComparator</code> that are declared inside a method (or to be more precise, inside a block of code between <code>{</code> and <code>}</code>, but not directly inside a class) is called a local class.  Just like a local variable, a local class is scoped within the method.  Like a nested class, a local class has access to the variables of the enclosing class through the qualified <code>this</code> reference.  Further, it can access the local variables of the enclosing method.</p> <p>For example,</p> <pre><code>class A {\n  int x = 1;\n\n  void f() {\n    int y = 1;\n\n    class B {\n      void g() {\n        x = y; // accessing x and y is OK.\n      }\n    }\n\n    new B().g();\n  }\n}\n</code></pre> <p>Here, <code>B</code> is a local class defined in method <code>f()</code>.  It has access to all the local variables accessible from within <code>f</code>, as well as the fields of its enclosing class.</p>"},{"location":"29-nested-classes.html#variable-capture","title":"Variable Capture","text":"<p>Recall that when a method returns, all local variables of the methods are removed from the stack.  But, an instance of that local class might still exist.  Consider the following example:</p> <pre><code>interface C {\n  void g();\n}\n\nclass A {\n  int x = 1;\n\n  C f() {\n    int y = 1;\n\n    class B implements C {\n      void g() {\n        x = y; // accessing x and y is OK.\n      }\n    }\n\n    B b = new B();\n    return b;\n  }\n}\n</code></pre> <p>Calling <pre><code>A a = new A();\nC b = a.f();\nb.g();\n</code></pre></p> <p>will give us a reference to an object of type <code>B</code> now.  But, if we call <code>b.g()</code>, what is the value of <code>y</code>?  Without variable capture, the stack and heap diagram is something like the following.  Notice how we have no access to <code>y</code> anymore!</p> After <code>A a = new A()</code>Invoking <code>a.f()</code>After <code>int y = 1</code>After <code>B b = new B()</code>After <code>C b = a.f()</code>Invoking <code>b.g()</code> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>For this reason, even though a local class can access the local variables in the enclosing method, the local class makes a copy of local variables inside itself.  We say that a local class captures the local variables.   Note that local variables are variables declared within a method.  These variables are local to the method.  Fields can always be accessed and need not be captured through this means.</p> <p>Visually, we will include the captured variables after the fields in the stack and heap diagram.  We will use a dashed line to separate the fields and captured variables.  Note that captured variables are NOT part of the fields, so it cannot be accessed with the dot operator (e.g., <code>this.y</code>).</p> After <code>A a = new A()</code>Invoking <code>a.f()</code>After <code>int y = 1</code>After <code>B b = new B()</code>After <code>C b = a.f()</code>Invoking <code>b.g()</code> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Variables are only captured when they are (i) local to the method and (ii) used in local class.  Consider the following modification to the previous example:</p> <pre><code>interface C {\n  void g();\n}\n\nclass A {\n  int x = 1;\n\n  C f() {\n    int y = 1;\n    int z = 2;\n\n    class B implements C {\n      void g() {\n        x = y; // accessing x and y is OK.\n      }\n    }\n\n    B b = new B();\n    return b;\n  }\n}\n</code></pre> <p>We have added another local variable <code>z</code>.  However, this variable is not used within the local class <code>B</code>.  As such, the instance of <code>B</code> does not capture the variable <code>z</code> and only captures the variable <code>y</code>.  This capture can only be shown after we have discussed the next subsection on effectively <code>final</code>.</p>"},{"location":"29-nested-classes.html#effectively-final","title":"Effectively <code>final</code>","text":"<p>Variable captures can be confusing.  Consider the following code:</p> <pre><code>void sortNames(List&lt;String&gt; names) {\n  boolean ascendingOrder = true;\n  class NameComparator implements Comparator&lt;String&gt; {\n    public int compare(String s1, String s2) {\n      if (ascendingOrder)\n        return s1.length() - s2.length();\n      else\n        return s2.length() - s1.length();\n    }\n  }\n\n  ascendingOrder = false;\n  names.sort(new NameComparator());\n}\n</code></pre> <p>Will <code>sort</code> sorts in ascending order (i.e., use the value of <code>ascendingOrder</code> when the class is declared) or descending order (i.e., use the value of <code>ascendingOrder</code> when the class is instantiated)?</p> <p>To complicate matter further, in the example above, we are only creating a single instance of <code>NameComparator</code>.  What if we have a thousand of those?  Should the statement <code>ascendingOrder = false</code> modify all thousand variables that are captured?  What if there are no instance of <code>NameComparator</code>?</p> <p>To avoid confusing code like this, Java only allows a local class to access variables that are explicitly declared <code>final</code> or implicitly final (a.k.a. effectively final).  An implicitly final variable cannot be re-assigned after initialization.  Therefore, Java saves us from such a hair-pulling situation above and disallows such code -- <code>ascendingOrder</code> is effectively final so the assignment <code>ascendingOrder = false</code> will cause compilation error.</p> <p>Breaking the Limitation of Effectively <code>final</code>. \u00a0\u00a0 The limitation of effectively final only happen because the value is of a primitive type.  So, if we captures the value and forbids re-assigning the value, there is nothing we can do to change primitive value.</p> <p>On the other hand, reference type can be mutated without assignment statement! So if we use our own implementation of <code>Bool</code> class below instead of <code>boolean</code> primitive type, we can modify the code above to allow the \"value\" in variable <code>ascendingOrder</code> to be changed. However, this change is via mutation and not re-assignment to the variable.</p> <p>This also saves us the problem of figuring out what will happen if we have a thousand instances of <code>NameComparator</code>.  In the previous case, because the variables are captured, we need to dynamically add a thousand different assignment statements to assign the new value to all thousand different instances.</p> <p>On the other hand, using reference type <code>Bool</code>, the value of the captured variable is a reference to a memory location in the heap.  Therefore, all thousand instances of <code>NameComparator</code> captures this reference.  This is where aliasing helps us.  The thousand instances has the same alias to this memory location.  So, changes in this memory location can have effect on the instance.</p> <pre><code>void sortNames(List&lt;String&gt; names) {\n  Bool ascendingOrder = new Bool(true);\n  class NameComparator implements Comparator&lt;String&gt; {\n    public int compare(String s1, String s2) {\n      if (ascendingOrder.val)\n        return s1.length() - s2.length();\n      else\n        return s2.length() - s1.length();\n    }\n  }\n\n  ascendingOrder.val = false;\n  names.sort(new NameComparator());\n}\nclass Bool {\n  boolean val;\n}\n</code></pre> <p>The code above does compile but now we are no longer save from such a hair-pulling situation.  So please exercise this with extreme caution.</p> <p>Variable Capture in Javascript</p> <p>Those of you who did CS1101S or otherwise familiar with Javascript might want to note that this is different from Javascript, which does not enforce the final/effectively final restriction in variable captures.  This is because there is no concept of primitive value in Javascript.</p> <p>Every single primitive type is automatically boxed in Javascript. The unboxed variant is not available to the programmer directly.  So, if we write <code>x = 1</code> in Javascript, the value <code>1</code> is boxed and put into the heap.  Then, the variable <code>x</code> in the stack points to this box in the heap unlike Java primitive type.</p>"},{"location":"29-nested-classes.html#anonymous-class","title":"Anonymous Class","text":"<p>An anonymous class is one where you declare a local class and instantiate it in a single statement. This is a syntactic sugar to allow programmers to declare quickly a \"single-use\" class -- a class that we use only once and never need again. We don't even need to give the class a name (hence, anonymous).</p> <pre><code>names.sort(new Comparator&lt;String&gt;() {\n  public int compare(String s1, String s2) {\n    return s1.length() - s2.length();\n }\n});\n</code></pre> <p>The example above removes the need to declare a class just to compare two strings.  </p> <p>An anonymous class has the following format: <code>new X (arguments) { body }</code>, where:</p> <ul> <li>X is a class that the anonymous class extends or an interface that the anonymous class implements.  X cannot be empty.  This syntax also implies an anonymous class cannot extend another class and implement an interface at the same time.  Furthermore, an anonymous class cannot implement more than one interface.  Put it simply, you cannot have <code>extends</code> and <code>implements</code> keyword in between <code>X</code> and <code>(arguments)</code>.</li> <li>arguments are the arguments that you want to pass into the constructor of the anonymous class.  If the anonymous class is extending an interface, then there is no constructor, but we still need <code>()</code>.</li> <li>body is the body of the class as per normal, except that we cannot have a constructor for an anonymous class.</li> </ul> <p>The syntax might look overwhelming at the beginning, but we can also write it as:</p> <pre><code>Comparator&lt;String&gt; cmp = new Comparator&lt;String&gt;() {\n  public int compare(String s1, String s2) {\n    return s1.length() - s2.length();\n  }\n};\nnames.sort(cmp);\n</code></pre> <p>Line 1 above looks just like what we do when we instantiate a class, except that we are instantiating an interface with a <code>{ .. }</code> body.</p> <p>An anonymous class is just like a local class, it captures the variables of the enclosing scope as well -- the same rules to variable access as local classes applies.</p>"},{"location":"30-functions.html","title":"Unit 30: Side Effect-Free Programming","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>appreciate the concept of functions as side-effect-free programming constructs and its relation to functions in mathematics.</li> <li>understand the importance of writing code that is free of side effects.</li> <li>understand how functions can be first-class citizens in Java through using local anonymous class.</li> <li>understand how we can succinctly use a lambda expression or a method reference in place of using local anonymous class.</li> <li>understand how we can use currying to generalize to functions with higher arity.</li> <li>understand how we can create a closure with lambda and environment capture.</li> </ul>"},{"location":"30-functions.html#functions","title":"Functions","text":"<p>Recall that, a function, in mathematics, refers to a mapping from a set of inputs (domain) \\(X\\) to a set of output values (codomain) \\(Y\\).  We write \\(f: X \\rightarrow Y\\).  Every input in the domain must map to exactly one output but multiple inputs can map to the same output.  Not all values in the codomain need to be mapped<sup>1</sup>.</p> <p>Let us illustrate this.  We can represent the <code>abs</code> function as a mapping from <code>int</code> to <code>int</code>.  So the domain is <code>int</code> and the codomain is <code>int</code>.  If the value is negative, we map the value to its positive value.  On the other hand, if the value is already positive, we map the value to itself.  This shows that not all values in the codomain are mapped.  However, all values in the domain must be mapped and, in fact, they are mapped to exactly one value in the codomain.</p> <p></p> <p>We know how to deal with mathematical functions very well.  There are certain rules that we follow when we reason about functions.  For instance, suppose we have an unknown \\(x\\) and a function \\(f\\), we know that applying \\(f\\) on \\(x\\), i.e., \\(f(x)\\) does not change the value of \\(x\\), or any other unknowns \\(y\\), \\(z\\), etc.  We say that mathematical functions have no side effects.  It simply computes and returns the value.</p> <p>Why Side-Effect?</p> <p>The term side-effect should be compared with the main-effect (or primary effect) of a function.  Mathematically, a function is a transformation from one value to another value.  So the main-effect is to return that value without modifying any of the input.  Anything else is a side-effect.  Side-effects include:</p> <ul> <li>Printing to the screen or other I/O write operation.</li> <li>Modify the value of a field.</li> <li>Mutating the input arguments.</li> <li>Invoking other functions with side-effects.</li> <li>Throwing exceptions.</li> <li>etc.</li> </ul> <p>Also note that observable behavior caused by the time taken for an operation to execute are ignored.</p> <p>Another property of mathematical function is referential transparency.  Let \\(f(x) = a\\).  Then in every formula that \\(f(x)\\) appears in, we can safely replace occurences of \\(f(x)\\) with \\(a\\).  Conversely, everywhere \\(a\\) appears, we can replace it with \\(f(x)\\).  We can be guarantee that the resulting formulas are still equivalent.</p> <p>Note that absence of side-effect does not guarantee referential transparency.  The function that returns the current time has no side-effect (i.e., it does not change the time, does not print on the screen, etc) but it is still not referentially transparent.  Invoking the same function at two different time produces different values.  To be referentially transparent, a function must also be deterministic.</p> <p>These two fundamental properties of mathematical functions allow us to solve equations, prove theorems, and reason about mathematical objects rigorously.  We call functions that are both side-effect free and referentially transparent as pure functions.</p> <p>Unfortunately, we can't always reason about our program the same way as we reason about mathematical functions.  For instance, consider the line:</p> <pre><code>seq.get(0)\n</code></pre> <p>where <code>seq</code> is an instance of <code>Seq&lt;T&gt;</code>.  Suppose we know that <code>seq.get(0)</code> is 5 for some <code>seq</code>.  When we reason about the behavior of our code, we cannot replace (mentally) every invocation of <code>seq.get(0)</code> with the value 5.  This is because the seq <code>seq</code> may not be immutable and therefore <code>seq.get(0)</code> cannot be guaranteed to be the same.</p> Can <code>seq.get(0)</code> be Replaced with 5?No! <pre><code>seq.get(0); // 5\n  :\nseq.get(0); // is it 5?\n</code></pre> <pre><code>seq.get(0); // 5\nseq.set(0, 10);\nseq.get(0); // is it 5? NO, it's 10!\n</code></pre> <p>The reverse should be true as well.  Suppose we have a variable</p> <pre><code>T elem = seq.get(0);\n</code></pre> <p>Then everywhere in our code where we use <code>elem</code>, we should be able to replace it with <code>seq.get(0)</code>, and the behavior of the code should still be the same. This behavior is only guaranteed if <code>seq.get(0)</code> has no side effects (such as modifying a field or print something to the standard output).</p> <p>Since our <code>Seq&lt;T&gt;</code> code is written rather well, we will illustrate it with the following example.</p> <pre><code>class Counter {\n  private int count;\n  private int value;\n\n  public Counter(int value) {\n    this.value = value;\n  }\n\n  public int getValue() {\n    this.count++;\n    return this.value;\n  }\n\n  public int getCount() {\n    return this.count;\n  }\n}\n</code></pre> <p>Now suppose we have the following variable.</p> <pre><code>Counter ctx = new Counter(10);\nint val = ctx.getValue();\n</code></pre> <p>The question now is can we replace <code>val</code> with <code>ctx.getValue()</code> everywhere?  See the effect below.</p> Using <code>val</code>Using <code>ctx.getValue()</code> <pre><code>Counter ctx = new Counter(10);\nint val = ctx.getValue();\nint tmp1 = val;\nint tmp2 = val;\nint tmp3 = val;\nint end = tmp1 + tmp2 + tmp3 + ctx.getCount(); // 31\n</code></pre> <pre><code>Counter ctx = new Counter(10);\nint val = ctx.getValue();\nint tmp1 = ctx.getValue();\nint tmp2 = ctx.getValue();\nint tmp3 = ctx.getValue();\nint end = tmp1 + tmp2 + tmp3 + ctx.getCount(); // 34\n</code></pre> <p>To be able to reason about our code using the mathematical reasoning techniques we are familiar with, it is important to write our code as if we are writing mathematical functions -- our methods should be free of side effects and our code should be referentially transparent.  Our program is then just a sequence of functions, chained and composed together.  To achieve this, functions need to be a first class citizen in our program, so that we can assign functions to a variable, pass it as parameters, return a function from another function, etc, just like any other variable.</p>"},{"location":"30-functions.html#pure-functions","title":"Pure Functions","text":"<p>Ideally, methods in our programs should behave the same as functions in mathematics.  Given an input, the function computes and returns an output.  A pure function does nothing else -- it does not print to the screen, write to files, throw exceptions, change other variables, modify the values of the arguments, etc.  That is, a pure function does not cause any side effect and is referentially transparent.</p> <p>Here are two examples of pure functions:</p> Pure Functions<pre><code>int square(int i) {\n  return i * i;\n}\n\nint add(int i, int j) {\n  return i + j;  // believe it or not, an overflow is\n                 // not an error in Java\n}\n</code></pre> <p>and some examples of non-pure functions: Non-Pure Functions<pre><code>int div(int i, int j) {\n  return i / j;  // may throw an exception\n}\n\nint incrCount(int i) {\n  return this.count + i; // assume that count is not final.\n                         // this may give diff results for the same i.\n}\n\nvoid incrCount(int i) {\n  this.count += i; // does not return a value\n                   // and has side effects on count\n}\n\nint addToQueue(Queue&lt;Integer&gt; queue, int i) {\n  queue.enq(i);  // has side effects on queue\n}\n</code></pre></p> <p>A pure function must also be deterministic.  Given the same input, the function must produce the same output, every single time.  As we said before, this deterministic property ensures referential transparency.</p> <p>In the OO paradigm, we commonly need to write methods that update the fields of an instance or compute values using the fields of an instance.  Such methods are not pure functions.  On the other hand, if our class is immutable, then its methods must not have side effects and thus is pure.</p> <p>In computer science, we refer to the style of programming where we build a program from pure functions as functional programming (FP). Examples of functional programming languages include Haskell, OCaml, Erlang, Clojure, F#, and Elixir.</p> <p>Many modern programming languages including Java, C++, Python, Rust, and Swift support this style of programming.  As these languages are not designed to be functional, we cannot build a program from only pure functions.  Java, for instance, is still an OO language at its core.  As such, we will refer to this style as functional-style programming.  We won't be able to write code consists of only pure functions in Java, but we can write methods that has no side effects and objects that are immutable, as much as possible.</p>"},{"location":"30-functions.html#function-as-first-class-citizen-in-java","title":"Function as First-Class Citizen in Java","text":"<p>Let's explore functions as a first-class citizen in Java.  We have seen some examples of this when we use the <code>Comparator</code> interface.</p> Using Local Class<pre><code>void sortNames(List&lt;String&gt; names) {\n  Comparator&lt;String&gt; cmp = new Comparator&lt;String&gt;() {\n    public int compare(String s1, String s2) {\n    return s1.length() - s2.length();\n    }\n  };\n  names.sort(cmp);\n}\n</code></pre> <p>First, let's take a moment to appreciate the beauty of the <code>List::sort</code> method.  We can use this method to sort items of any type, in any defined order.  We achieve the generality of types with generics, and the generality of sorting order through passing in the comparison function as a parameter.  The latter is needed to write one sorting method for every possible sorting order for a list of strings, (<code>sortAlphabeticallyIncreasing</code>, <code>sortByLengthDecreasing</code>, etc)</p> <p>The comparison function here is implemented as a method in an anonymous class that implements an interface.  We can think of an instance of this anonymous class as the function.  Since a function is now just an instance of an object in Java, we can pass it around, return it from a function, and assign it to a variable, just like any other reference type.</p> <p>Let's look at another example.  Consider the following interface: Transformer Interface<pre><code>interface Transformer&lt;T, R&gt; {\n  R transform(T t);\n}\n</code></pre></p> <p><code>Transformer&lt;T, R&gt;</code> is a generic interface with two type parameters: <code>T</code> is the type of the input, <code>R</code> is the type of the result.  It has one abstract method <code>R transform(T t)</code> that applies the function to a given argument.</p> <p>We can use this interface to write any function that takes in a value and return another value.  (Java has a similar interface called, unsurprisingly, <code>java.util.function.Function&lt;T, R&gt;</code>). For instance, a function that computes the square of an integer can be written as: Using Anonymous Class<pre><code>new Transformer&lt;Integer, Integer&gt;() {\n  @Override\n  public Integer transform(Integer x) {\n    return x * x;\n  }\n};\n</code></pre></p> <p>We can write a method <code>chain</code> that composes two given computations together and return the new computation: Chaining Function<pre><code>// Use of PECS left as an exercise to the reader\n&lt;T, R, S&gt; Transformer&lt;T,R&gt; chain(Transformer&lt;T,S&gt; t1, Transformer&lt;S,R&gt; t2) {\n  return new Transformer&lt;T,R&gt;() {\n    public R transform(T value) {\n      return t2.transform(t1.transform(value));\n      // in mathematical notation, this is t2(t1(v))\n    }\n  }\n}\n</code></pre></p> <p>Note that the use of local class above is necessary in the method <code>chain</code> above.  This is because we need to be able to invoke both <code>t1</code> and <code>t2</code>.  Since this local class is only used to connect both <code>t1</code> and <code>t2</code>, we do not need to give it a name.  Hence, anonymous class is suitable for this.</p>"},{"location":"30-functions.html#lambda-expression","title":"Lambda Expression","text":"<p>While we have achieved functions as first-class citizens in Java, the code is verbose and ugly.  Fortunately, there is a much cleaner syntax to write functions that applies to interfaces with a single abstract method.</p> <p>An interface in Java with exactly one abstract method (either declared in the interface or inherited) is called a functional interface.  Both <code>Comparator</code><sup>2</sup> and <code>Transformer</code> are functional interfaces.  It is recommended that, if a programmer intends an interface to be a functional interface, they should annotate the interface with the <code>@FunctionalInterface</code> annotation.</p> <pre><code>@FunctionalInterface\ninterface Transformer&lt;T, R&gt; {\n  R transform(T t);\n}\n</code></pre> <p>A key advantage of a functional interface is that there is no ambiguity about which method is being overridden by an implementing subclass.</p> <p>For instance, consider: <pre><code>Transformer&lt;Integer, Integer&gt; square = new Transformer&lt;&gt;() {\n  @Override\n  public Integer transform(Integer x) {\n    return x * x;\n  }\n};\nTransformer&lt;Integer, Integer&gt; incr = new Transformer&lt;&gt;() {\n  @Override\n  public Integer transform(Integer x) {\n    return x + 1;\n  }\n};\n</code></pre></p> <p>You can see that there is much boilerplate code in the two functions above that we can remove.  Since we are assigning it to a variable of type <code>Transformer</code> interface, we don't have to write <code>new Transformer&lt;&gt;() { .. }</code>.  And since <code>Transformer</code> is an interface, there is no constructor.  Since there is only one abstract method to overwrite (remember, this is a functional interface), there is no ambiguity in which method we are trying to override and we don't have to write <code>@Override public Integer transform(..) { .. }</code>.</p> <p>What remain after we eliminate the obvious boilerplate code are (i) the parameter <code>Integer x</code> and (ii) the body of <code>transform</code>, which is <code>{ return x * x; }</code>.    We can use the Java arrow notation <code>-&gt;</code> to now link the parameter and the body:</p> <pre><code>Transformer&lt;Integer, Integer&gt; square = (Integer x) -&gt; { return x * x; };\nTransformer&lt;Integer, Integer&gt; incr = (Integer x) -&gt; { return x + 1; };\n</code></pre> <p>You might notice that the type of the parameter is redundant as well since the type argument to <code>Transformer</code> already tells us this function takes in an <code>Integer</code>. We can further simplify it to: <pre><code>Transformer&lt;Integer, Integer&gt; square = (x) -&gt; { return x * x; };\nTransformer&lt;Integer, Integer&gt; incr = (x) -&gt; { return x + 1; };\n</code></pre></p> <p>or simply: <pre><code>Transformer&lt;Integer, Integer&gt; square = x -&gt; { return x * x; };\nTransformer&lt;Integer, Integer&gt; incr = x -&gt; { return x + 1; };\n</code></pre></p> <p>where there is only one parameter.</p> <p>Since the body has only a single return statement, we can simplify it further: <pre><code>Transformer&lt;Integer, Integer&gt; square = x -&gt; x * x;\nTransformer&lt;Integer, Integer&gt; incr = x -&gt; x + 1;\n</code></pre></p> <p>Now, that's much better!</p> <p>The expressions above, including <code>x -&gt; x * x</code>, are called lambda expressions.  You can recognize one by the use of <code>-&gt;</code>.   The left-hand side lists the parameters (use <code>()</code> if there is no parameter), while the right-hand side is the computation.  We do not need the type in cases where Java can infer the type, nor need the return keyword and the curly brackets when there is only a single return statement.</p> <p>lambda</p> <p>Alonzo Church invented lambda calculus (\\(\\lambda\\)-calculus) in 1936, before electronic computers, as a way to express computation.  In \\(\\lambda\\)-calculus, all functions are anonymous.  The term lambda expression originated from there.</p>"},{"location":"30-functions.html#method-reference","title":"Method Reference","text":"<p>Lambda expression is useful for specifying a new anonymous method.  Sometimes, we want to use an existing method as a first-class citizen instead.</p> <p>Recall the <code>distanceTo</code> method in <code>Point</code>, which takes in another point as a parameter and returns the distance between this point and the given point.</p> <pre><code>class Point {\n    :\n\n  public double distanceTo(Point p) {\n      :\n  }\n}\n</code></pre> <p>We can write our <code>Transformer</code> like this using an anonymous class: <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = new Transformer&lt;&gt;() {\n  @Override\n  public Double transform(Point p) {\n    return origin.distanceTo(p);\n  }\n}\n</code></pre></p> <p>or using a lambda expression: <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = p -&gt; origin.distanceTo(p);\n</code></pre></p> <p>but since <code>distanceTo</code> takes in one parameter and returns a value, it already fits as a transformer, and we can write it as: <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = origin::distanceTo;\n</code></pre></p> <p>The double-colon notation <code>::</code> is used to specify a method reference.  We can use method references to refer to a (i) static method in a class, (ii) instance method of a class or interface, (iii) constructor of a class.  Here are some examples of the double-colon notation and their equivalent lambda expression.</p> <pre><code>Maybe::of     // x -&gt; Maybe.of(x)       (i) static method   (Maybe is a class)\nx::compareTo  // y -&gt; x.compareTo(y)   (ii) instance method (x is a variable)\nSome::new     // x -&gt; new Some(x)     (iii) constructor     (Some is a class)\n</code></pre> <p>So far, the example above takes in one parameter.  But the scheme can be extended easily to multiple parameters.  For instance, the following is a constructor of <code>Point</code> that takes in two parameters.</p> <pre><code>Point::new    // (x, y) -&gt; new Point(x, y)\n</code></pre> <p>In the example above, the usage are non-ambiguous.  If the method is a static method, we should use the class name (e.g., <code>Maybe::of</code>).  On the other hand, if the method is an instance method, we should use the variable name (e.g., <code>x::compareTo</code>).</p> <p>Unfortunately there is another usage that may cause quite a lot of confusion.  This is because we may actually use a class name while referring to instance method.</p> <pre><code>A::h    // 2 parameters    (x, y) -&gt; x.h(y)    or    (x, y) -&gt; A.h(x, y)\n        // 3 parameters (x, y, z) -&gt; x.h(y, z) or (x, y, z) -&gt; A.h(x, y, z)\n</code></pre> <p>This last example shows that the same method reference expression can be interpreted in two different ways.  The actual interpretation depends on how many parameters <code>h</code> takes and whether <code>h</code> is a class method or an instance method.  When compiling, Java searches for the matching method, performing type inferences to find the method that matches the given method reference.  A compilation error will be thrown if there are multiple matches or if there is ambiguity in which method matches.</p> <p>Not Effectively Final</p> <p>Consider the two examples above again, reproduced below.</p> LambdaMethod Reference <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = p -&gt; origin.distanceTo(p);\n</code></pre> <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = origin::distanceTo;\n</code></pre> <p>In the case of lambda, the variable <code>origin</code> is effectively final.  On the other hand, the variable <code>origin</code> is not effectively final when using method reference.  In fact, the following is allowed.</p> <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = origin::distanceTo;\norigin = new Point(1, 1);\ndouble diagonal = dist.transform(new Point(3, 4)); // 5.0\n</code></pre> <p>Note that Line 4 is computing the distance with respect to the original <code>origin</code> at (0, 0).  This is the famous Pythagorean triple 3, 4, 5.  The distance between the point (0, 0) and the point (3, 4) is exactly 5.  So although <code>origin</code> is not effectively final, the method reference <code>origin::distanceTo</code> is pointing to exactly the method <code>distanceTo</code> within this particular instance.  So even if the variable <code>origin</code> is reassigned to another value, the method reference is still pointing to the old method.</p> Test Yourself <p>Check your understanding of method reference by trying out the following.  We will be using the interface <code>Transformer&lt;T, R&gt;</code> from the notes and we will define the following class.</p> <pre><code>class C {\n  static C f1(C x) { return null; }\n  C f2() { return null; }\n  C f3(C x) { return null; }\n  C f4() { return null; }\n}\n</code></pre> <p>Which of the following will compile without error assuming we have the following variables.</p> <pre><code>Transformer&lt;C, C&gt; fn;\nC obj = new C();\n</code></pre> QuestionAnswer Code Compile? <code>fn = C::f1</code> <code>fn = C::f2</code> <code>fn = C::f3</code> <code>fn = C::f4</code> <code>fn = obj::f1</code> <code>fn = obj::f2</code> <code>fn = obj::f3</code> <code>fn = obj::f4</code> Code Compile? <code>fn = C::f1</code> <code>fn = C::f2</code> <code>fn = C::f3</code> <code>fn = C::f4</code> <code>fn = obj::f1</code> <code>fn = obj::f2</code> <code>fn = obj::f3</code> <code>fn = obj::f4</code>"},{"location":"30-functions.html#lexical-this","title":"Lexical This","text":"<p>In our discussion above -- as well as our mental model -- we think of lambda as a syntactic sugar for anonymous class.  Which makes the explanation neat because we implement anonymous function (i.e., lambda) using something else that is anonymous.</p> <p>Unfortunately, the reality is not so clean and tidy because Java compiler performs quite a number of optimizations that may cause such mental model to breakdown.  The following is an example of when such mental model breakdown for a good reason.</p> <p>Consider the following code:</p> <pre><code>class A {\n  private int x;\n\n  public A(int x) {\n    this.x = x;\n  }\n\n  public int getX() {\n    Transformer&lt;Integer, Integer&gt; f = y -&gt; this.x;\n    return f.transform(0);\n  }\n}\n</code></pre> <p>It is reasonable to assume that the following code compiles.</p> <pre><code>A a = new A(2);\na.getX(); // 2\n</code></pre> <p>And indeed, the code above compiles and the result of <code>a.getX()</code> is indeed 2.  However, this is a violation of our mental model where lambda is converted into an anonymomus class.  The rewriting of the code above using anonymous class will be the following:</p> <pre><code>class A {\n  private int x;\n\n  public A(int x) {\n    this.x = x;\n  }\n\n  public int getX() {\n    Transformer&lt;Integer, Integer&gt; f = new Transformer&lt;&gt;() {\n      @Override\n      public Integer transform(Integer y) {\n        return this.x;\n      }\n    };\n    return f.transform(0);\n  }\n}\n</code></pre> <p>Unfortunately this code does not compile.  In fact, we will get the following error</p> <pre><code>_.java:_: error: cannot find symbol\n        return this.x;\n                   ^\n  symbol: variable x\n1 error\n</code></pre> <p>The problem here is that the keyword <code>this</code> is referring to two different instances.  In the case of lambda, it is referring to the instance of class <code>A</code>.  On the other hand, in the case of anonymous class, <code>this</code> is referring to the instance of the anonymous class.  So it causes the error because the anonymous class has no field called <code>x</code>.</p> <p>However, in a way, it is reasonable when using lambda not to think about the presence of the anonymous class.  This is what we meant by lexical <code>this</code>.  So now we are faced with a slight conundrum because the mental model of having lambda as a syntactic sugar of anonymous class is useful but unfortunately wrong.</p> <p>Due to its usefulness, we will keep using the mental model of lambda being a syntactic sugar for anonymous class when tracing using stack and heap diagram.  However, the keyword <code>this</code> should be referring to the correct instance as per lexical <code>this</code>.</p>"},{"location":"30-functions.html#curried-functions","title":"Curried Functions","text":"<p>Mathematically, a function takes in only one value and returns one value (e.g., <code>square</code> above).  In programming, we often need to write functions that take in more than one argument (e.g., <code>add</code> above). Even though <code>Transformer</code> only supports function with a single parameter, we can build functions that take in multiple arguments.  Let's look at this mathematically first.  Consider a binary function \\(f: (X, Y) \\rightarrow Z\\).  We can introduce \\(F\\) as a set of all functions \\(f': Y \\rightarrow Z\\), and rewrite \\(f\\) as \\(f: X \\rightarrow F\\), or \\(f: X \\rightarrow Y \\rightarrow Z\\).</p> <p>The arrow \\(\\rightarrow\\) is to be read from right-to-left.  So \\(f: X \\rightarrow Y \\rightarrow Z\\) is equivalent to \\(f: X \\rightarrow (Y \\rightarrow Z)\\).  But what does it actually mean?  It means that instead of having a function that takes in two arguments, we can instead have a function that takes in one argument (typically the first argument) and return another function to accept the second argument.</p> <p>A trivial example of this is the <code>add</code> method that adds two <code>int</code> values. <pre><code>int add(int x, int y) {\n  return x + y;\n}\n</code></pre></p> <p>This can be written as <pre><code>Transformer&lt;Integer, Transformer&lt;Integer, Integer&gt;&gt; add = x -&gt; y -&gt; (x + y);\n</code></pre></p> <p>The way we read <code>x -&gt; y -&gt; (x + y)</code> is actually from right-to-left.  So, it is equivalent to <code>x -&gt; (y -&gt; (x + y))</code>.  We can then reason about this from innermost to outermost:</p> <ul> <li>Innermost: <code>y -&gt; (x + y)</code> is a function that takes in a single argument <code>y</code> and returns the sum of <code>(x + y)</code>.  Let us call this function <code>f_inner</code>.</li> <li>Outermost: <code>x -&gt; f_inner</code> is a function that takes in a single argument <code>x</code> and returns the innermost function <code>f_inner</code>.</li> </ul> <p>Combining the two, we can read it as follows:</p> <p><code>x -&gt; y -&gt; (x + y)</code> is a function that takes in a single argument <code>x</code> and returns another function.  The returned function takes in a single argument <code>y</code> and returns the result of adding <code>x</code> (the argument accepted by the outer function) with <code>y</code> (the argument accepted by the inner function).</p> <p>To calculate 1 + 1, we call <pre><code>add.transform(1).transform(1);\n</code></pre></p> <p>Let's break it down again, <code>add</code> is a function that takes in an <code>Integer</code> object and returns a unary <code>Function</code> over <code>Integer</code>.  So <code>add.transform(1)</code> returns the function <code>y -&gt; 1 + y</code>.  We could assign this to a variable: <pre><code>Transformer&lt;Integer,Integer&gt; incr = add.transform(1);\n</code></pre></p> <p>Note that <code>add</code> is no longer a function that takes two arguments and returns a value.  It is a higher-order function that takes in a single argument and returns another function.</p> <p>The technique that translates a general \\(n\\)-ary function to a sequence of \\(n\\) unary functions is called currying.  After currying, we have a sequence of curried functions.  </p> <p>Curry</p> <p>Currying is not related to food but rather is named after computer scientist Haskell Curry, who popularized the technique.</p> <p>How is currying useful?  Consider <code>add(1, 1)</code> -- we have to have both arguments available at the same time to compute the function.  With currying, we no longer have to.  We can evaluate the different arguments at a different time (as <code>incr</code> example above).  This feature is useful in cases where some arguments are not available until later.  We can partially apply a function first<sup>3</sup>.  This is also useful if one of the arguments does not change often, or is expensive to compute.  We can save the partial results as a function and continue applying later.  We can dynamically create functions as needed, save them, and invoke them later.</p> <p>Instance Method as Partially Applied Class Method</p> <p>One popular point of view is that an instance method is a partially applied static method with an additional first parameter called <code>this</code>.  Take for instance an instance method <code>C::f(A1, A2)</code> in class <code>C</code> that takes in two parameters of type <code>A1</code> and <code>A2</code>.  This can also be viewed as a class method (i.e., with <code>static</code> keyword) of the form <code>C::f(C, A1, A2)</code>.  So instead of taking in two parameters, it takes in three parameters.  We assume that the first parameter <code>C</code> is called <code>this</code>.</p> <p>Of course, this view is just an approximation but it is a useful one.</p>"},{"location":"30-functions.html#lambda-as-closure","title":"Lambda as Closure","text":"<p>In the example, we showed earlier,</p> <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = p -&gt; origin.distanceTo(p);\n</code></pre> <p>the variable <code>origin</code> is captured by the lambda expression <code>dist</code>.  Just like in local and anonymous classes, a captured variable must be either explicitly declared as <code>final</code> or is effectively final.</p> <p>A lambda expression stores more than just the function to invoke -- it also stores the data from the environment where it is defined.  We call such a construct that stores a function together with the enclosing environment a closure.</p> <p>Being able to save the current execution environment, and then continue to compute it later, adds new power to how we can write our program.  We can make our code cleaner with fewer parameters to pass around and less duplicated code.  We can separate the logic to do different tasks in a different part of our program easier.  Unfortunately, as the captured variables are effectively final, we cannot modify them so the power we gain is more restricted.</p> <p>We will see more examples of this later.</p> <ol> <li> <p>The exact set values that the domains are mapped into are called the range.  It is unlikely we will be using this terminology.\u00a0\u21a9</p> </li> <li> <p><code>Comparator</code> only has a single abstract method <code>compare(T, T)</code> while the rest are either <code>static</code> non-<code>abstract</code> method or <code>default</code> method\u00a0\u21a9</p> </li> <li> <p>A function that is partially applied is often called partial function.  However, the term partial function may refer to another kind of function which is a function that is not defined for all its domain (e.g., square root function is not defined for negative input if the output is real number).\u00a0\u21a9</p> </li> </ol>"},{"location":"31-box-maybe.html","title":"Unit 31: Box and Maybe","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>appreciate the generality of the class <code>Box&lt;T&gt;</code> and <code>Maybe&lt;T&gt;</code></li> <li>appreciate how passing in functions as parameter can lead to highly general abstractions</li> <li>appreciate how <code>Maybe&lt;T&gt;</code> preserves the \"maybe null\" semantics over a reference type by internalizing checks for <code>null</code></li> </ul>"},{"location":"31-box-maybe.html#lambda-as-a-cross-barrier-state-manipulator","title":"Lambda as a Cross-Barrier State Manipulator","text":"<p>Recall that every class has an abstraction barrier between the client and the implementer.  The internal states of the class are heavily protected and hidden.   The implementer selectively provides a set of methods to access and manipulate the internal states of instances.  This approach allows the implementer to control what the client can and cannot do to the internal states.  This is good if we want to build abstractions over specific entities such as shapes or data structures such as a stack, but it is not flexible enough to build general abstraction.</p> <p>Let's consider the following class:</p> Box v0.0.1<pre><code>class Box&lt;T&gt; {\n  private T item;\n}\n</code></pre> <p>It is a box containing a single item of type <code>T</code>.  Suppose that we want to keep the <code>item</code> hidden and we want to have certain rules and maintain some semantics about the use of the <code>item</code>.  As such, we don't want to provide any setter or getter, so that the client may not break our rules.  What are some ways we can still operate on this <code>item</code>?</p> <p>One way is to clearly define what we can do with the <code>item</code>.  Since the <code>item</code> has a type <code>T</code>, what can be done on <code>item</code> must be whatever can be done on <code>Object</code>.  Clearly there are not that many things we can do to <code>Object</code>.  But one possibility is to convert <code>item</code> from type <code>T</code> into a <code>String</code>.  We can add the method <code>mapToString()</code> as follows.</p> Box v0.1<pre><code>class Box&lt;T&gt; {\n  private T item;\n    :\n\n  public Box&lt;String&gt; mapToString() {\n    return new Box&lt;String&gt;(this.item.toString());\n  }\n}\n</code></pre> <p>But if we do this, for each new operation we want to support we need to add a new method.  For instance, if we want to convert to an integer using <code>this.item.toString().length()</code>, then we need to add a new method <code>mapToInteger</code>.  Is there a better way?</p> <p>Another way we can do this is to provide methods that accept a lambda expression, apply the lambda expression on the item, and return the new box with the new value.  This is a more extensible design.  For instance,</p> Box v0.2<pre><code>class Box&lt;T&gt; {\n  private T item;\n    :\n\n  public &lt;U&gt; Box&lt;U&gt; map(Transformer&lt;? super T, ? extends U&gt; transformer) {\n    if (!isPresent()) {\n      return empty();\n    }\n    return Box.of(transformer.transform(this.item));\n  }\n    :\n\n  public Box&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; condition) {\n    if (!isPresent() || !(condition.test(this.item)) {\n      return emptyBox();\n    }\n    return this;\n  }\n    :\n}\n</code></pre> <p>The method <code>map</code> takes in a lambda expression and allows us to arbitrarily apply a function to the item, while the method <code>filter</code> allows us to perform an arbitrary check on the property of the item.</p> <p>Methods such as these, which accept a function as a parameter, allow the client to manipulate the data behind the abstraction barrier without knowing the internals of the object.  Here, we are treating lambda expressions as \"manipulators\" that we can pass in behind the abstraction barrier and modify the internals arbitrarily for us, while the container or the box tries to maintain the semantics for us.</p>"},{"location":"31-box-maybe.html#maybe","title":"Maybe","text":"<p>Let's now look at <code>Box&lt;T&gt;</code> in a slightly different light.  Let's rename it to <code>Maybe&lt;T&gt;</code>.  <code>Maybe&lt;T&gt;</code> is an option type, a common abstraction in programming languages (<code>java.util.Optional</code> in Java, <code>option</code> in Scala, <code>Maybe</code> in Haskell, <code>Nullable&lt;T&gt;</code> in C#, etc) that is a wrapper around a value that is either there or is <code>null</code>.  The <code>Maybe&lt;T&gt;</code> abstraction allows us to write code without mostly not worrying about the possibility that our value is missing.  When we call <code>map</code> on a value that is missing, nothing happens.</p> <p>Recall that we wish to write a program that is as close to pure mathematical functions as possible, a mathematical function always has a well-defined domain and codomain.  If we have a method that looks like this:</p> <pre><code>Barista b = coffee.findBarista();\n</code></pre> <p>Then <code>findBarista</code> is mapping from the domain on coffee shop to the codomain of baristas.  However, if we implement <code>findBarista</code> such that it returns <code>null</code> if no counter is available, then <code>findBarista</code> is not a pure function anymore.  The return value <code>null</code> is not a barista, as we cannot do things that we can normally do on barista to it.  So <code>findBarista</code> now maps to a value outside its codomain! This violation of the purity of function adds complications to our code, as we now have to specifically filter out <code>null</code> value, and is a common source of bugs.</p> <p>One way to fix this is to have a special barista (say, <code>class BaristaOrNull</code> extends <code>Barista</code>) that is returned whenever no barista is available. This way, our <code>findCounter</code> remains a pure function. But this is not a general solution. If we adopt this solution, everywhere we return <code>null</code> in place of a non-<code>null</code> instance we have to create a special subclass.  We have to do this for all classes that we want to support.  Luckily, we have learnt generics in CS2030S.</p> <p>A more general way to expand a domain or codomain to include <code>null</code> is to create a generic class that does the check.  We can call this class <code>Maybe&lt;T&gt;</code>.  So now, we can wrap both <code>null</code> and <code>Barista</code> under a type called <code>Maybe&lt;Barista&gt;</code>.  We only need to ensure that <code>Maybe&lt;Barista&gt;</code> never points to <code>null</code> (i.e., we should not have <code>Maybe&lt;Barista&gt; maybe = null</code>) but it may contain <code>null</code> value (e.g. <code>Maybe&lt;Barista&gt; maybe = Maybe.some(null)</code>).  Then, we can make <code>findBarista</code> return <code>Maybe&lt;Barista&gt;</code>.</p> <pre><code>Maybe&lt;Barista&gt; barista = coffee.findBarista();\n</code></pre> <p>Another way to view the <code>Maybe&lt;T&gt;</code> class is that it internalizes all the checks for <code>null</code> on the client's behalf.  <code>Maybe&lt;T&gt;</code> ensures that if <code>null</code> represents a missing value, then the semantics of this missing value is preserved throughout the chain of <code>map</code> and <code>filter</code> operations.  Within its implementation, <code>Maybe&lt;T&gt;</code> do the right thing when the value is missing to prevent us from encountering <code>NullPointerException</code>.  There is a check for <code>null</code> when needed, internally, within <code>Maybe&lt;T&gt;</code>.  This internalization removes the burden of checking for <code>null</code> on the programmer and removes the possibility of run-time crashes due to missing <code>null</code> checks.</p>"},{"location":"32-lazy.html","title":"Unit 32: Lazy Evaluation","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand what is lazy evaluation and how lambda expression allows us to delay the execution of a computation</li> <li>understand how memoization and the <code>Lazy&lt;T&gt;</code> abstraction allows us to evaluate an expression exactly once.</li> </ul>"},{"location":"32-lazy.html#lambda-as-delayed-data","title":"Lambda as Delayed Data","text":"<p>When we write a lambda expression like this:</p> <pre><code>Transformer&lt;Integer, Integer&gt; f = x -&gt; x + 1;\n</code></pre> <p>we are just defining an expression.  We are not invoking the function <code>x + 1</code>.  This is perhaps clear to most students since to invoke the function, we need an argument for <code>x</code>, and no argument is supplied when we define <code>f</code>.</p> <p>Consider the following functional interfaces instead:</p> <pre><code>@FunctionalInterface\ninterface Producer&lt;T&gt; {\n  T produce();\n}\n\n@FunctionalInterface\ninterface Task {\n  void run();\n}\n</code></pre> <p>These functional interfaces have a method that does not take in a parameter.  So, we would be using them like such:</p> <pre><code>i = 4;\nTask print = () -&gt; System.out.println(i);\nProducer&lt;String&gt; toStr = () -&gt; Integer.toString(i);\n</code></pre> <p>Keep in mind that these are still lambda expressions and nothing is executed by simply declaring them.  We are just saving them to be executed later.</p> <p>Lambda expression, therefore, allows us to delay the execution of code, saving them until we need it later.  This enables another powerful mechanism called lazy evaluation.  We can build up a sequence of complex computations, without actually executing them, until we need to.  Expressions are evaluated on demand when needed.</p> <p>Consider the following class:</p> Logger v0.1<pre><code>class Logger {\n  enum LogLevel { INFO, WARNING, ERROR };\n\n  public static LogLevel currLogLevel = LogLevel.WARNING;\n\n  static void log(LogLevel level, String msg) {\n    if (level.compareTo(Logger.currLogLevel) &gt;= 0) {\n      System.out.println(\" [\" + level + \"] \" + msg);\n    }\n  }\n}\n</code></pre> <p>The <code>log</code> method checks the seriousness level of the message against the current log level, and only prints the message if the level of the message is the same or higher.  For instance, if the current log level is <code>WARNING</code>, then</p> <pre><code>Logger.log(Logger.LogLevel.INFO, \n    \"User \" + System.getProperty(\"user.name\") + \" has logged in\");\n</code></pre> <p>will not get printed.</p> <p>However, regardless of whether the log message will be printed, the method <code>System.getProperty(\"user.name\")</code> will be evaluated, which is wasteful.</p> <p>A better design for this case is to wrap the message <code>msg</code> within a lambda expression, so that it does not get evaluated eagerly when we pass it in as a parameter.  We can wrap the message with a <code>Producer&lt;String&gt;</code>.  The new <code>lazyLog</code> method would look like this:</p> Logger v0.2<pre><code>class Logger {\n  enum LogLevel { INFO, WARNING, ERROR };\n\n  public static LogLevel currLogLevel = LogLevel.WARNING;\n\n  static void lazyLog(LogLevel level, Producer&lt;String&gt; msg) {\n    if (level.compareTo(Logger.currLogLevel) &gt;= 0) {\n      System.out.println(\" [\" + level + \"] \" + msg.produce());\n    }\n  }\n}\n</code></pre> <p>and is invoked like this: <pre><code>Logger.lazyLog(Logger.LogLevel.INFO, \n    () -&gt; \"User \" + System.getProperty(\"user.name\") + \" has logged in\");\n</code></pre></p> <p>The method <code>System.getProperty(\"user.name\")</code> is now lazily called, only if the message is going to be printed.</p>"},{"location":"32-lazy.html#memoization","title":"Memoization","text":"<p>We have so far seen one way of being lazy (i.e., procrastinating our computation until we really need the data).  If we want to be lazier, we should not even repeat ourselves.  If we have computed the value of a function before, we can cache (or memoize) the value, keep it somewhere, so that we don't need to compute it again.  This is useful, of course, only if the function is pure -- regardless of how many times we invoke the function, it always returns the same value, and invoking it has no side effects on the execution of the program.  Here, we see another important advantage of keeping our code pure and free of side effects -- so that we can be lazy!</p> <p>While other languages such as Scala as native support for lazy variables, Java does not.  Haskell<sup>1</sup> is even lazy by default!  So let's build a simple one here.  (You will build a more sophisticated one in Programming Exercise 6).</p> Lazy v0.1<pre><code>class Lazy&lt;T&gt; {\n  private T value;\n  private boolean isAvailable;\n  private Producer&lt;T&gt; producer;\n\n  public Lazy(Producer&lt;T&gt; producer) {\n    this.isAvailable = false;\n    this.value = null;\n    this.producer = producer;\n  }\n\n  public T get() {\n    if (!isAvailable) {\n      this.value = producer.produce();\n      this.isAvailable = true;\n    }\n    return this.value;\n  }\n}\n</code></pre> <p>We can now rewrite our <code>Logger</code> as</p> Logger v0.3<pre><code>class Logger {\n  enum LogLevel { INFO, WARNING, ERROR };\n\n  public static LogLevel currLogLevel = LogLevel.WARNING;\n\n  static void lazyLog(LogLevel level, Lazy&lt;String&gt; msg) {\n    if (level.compareTo(Logger.currLogLevel) &gt;= 0) {\n      System.out.println(\" [\" + level + \"] \" + msg.get());\n    }\n  }\n}\n</code></pre> <p>and call it with: <pre><code>Lazy&lt;String&gt; loginMessage = new Lazy(\n    () -&gt; \"User \" + System.getProperty(\"user.name\") + \" has logged in\");\nLogger.lazyLog(Logger.LogLevel.INFO, loginMessage);\n</code></pre></p> <p>If <code>loginMessage</code> is used in multiple places, memoization ensures that <code>System.getProperty(\"user.name\")</code> and the concatenation of the strings are done only once.</p> <ol> <li> <p>Haskell from Glasgow Haskell Compiler is lazy by default.  There are other Haskell compiler that is non-lazy.\u00a0\u21a9</p> </li> </ol>"},{"location":"33-infinitelist.html","title":"Unit 33: Infinite List","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand how infinite lists can be constructed using a lazy evaluation.</li> </ul>"},{"location":"33-infinitelist.html#preliminary-an-eagerly-evaluated-list","title":"Preliminary: An Eagerly Evaluated List","text":"<p>Let's consider first how we can represent an eagerly evaluated, finite list, recursively.  A simple way is to treat the list as a recursive structure, containing a <code>head</code> and a <code>tail</code>, with the <code>tail</code> being a list itself.  We have a special terminating list called <code>Sentinel</code> that we use to terminate the <code>EagerList</code>.  This <code>Sentinel</code> is a subtype of <code>EagerList</code> so that we can use polymorphism.</p> EagerList<pre><code>class EagerList&lt;T&gt; {\n  private final T head;\n  private final EagerList&lt;T&gt; tail;\n  private static EagerList&lt;?&gt; EMPTY = new Sentinel(); \n\n  public EagerList(T head, EagerList&lt;T&gt; tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  public T head() {    // be careful, the method name\n    return this.head;  // is the same as the field name\n  }\n\n  public EagerList&lt;T&gt; tail() { // same here, method name\n    return this.tail;          // is the same as field name\n  }\n\n  public T get(int n) {\n    if (n == 0) {\n      return this.head();          // be careful!\n    }                              //   use the methods\n    return this.tail().get(n - 1); //   instead of fields\n  }\n\n  public static &lt;T&gt; EagerList&lt;T&gt; empty() {\n    @SuppressWarnings(\"unchecked\")\n    EagerList&lt;T&gt; temp = (EagerList&lt;T&gt;) EMPTY;\n    return temp;\n  }\n\n  private static class Sentinel extends EagerList&lt;Object&gt; {\n    Sentinel() {\n      super(null, null);\n    }\n\n    @Override\n    public Object head() {\n      throw new java.util.NoSuchElementException();\n    }\n\n    @Override\n    public EagerList&lt;Object&gt; tail() {\n      throw new java.util.NoSuchElementException();\n    }\n\n    @Override\n    public Object get(int n) {\n      throw new java.util.NoSuchElementException();\n    }\n  }\n}\n</code></pre> <p>Let's provide two factory methods called <code>generate</code> and <code>iterate</code>, that will populate our EagerList for us.</p> <pre><code>  public static &lt;T&gt; EagerList&lt;T&gt; generate(T t, int size) {\n    if (size == 0) {\n      return empty();\n    }\n    return new EagerList&lt;&gt;(t, generate(t, size - 1));\n  }\n\n  public static &lt;T&gt; EagerList&lt;T&gt; iterate(T init, BooleanCondition&lt;? super T&gt; cond, Transformer&lt;? super T, ? extends T&gt; op) {\n    if (!cond.test(init)) {\n      return empty();\n    }\n    return new EagerList&lt;&gt;(init, iterate(op.transform(init), cond, op));\n  }\n</code></pre> <p>Let's now provide the standard operation <code>map</code> so that we can transform the items in the list. The <code>map</code> method takes a lambda expression as the parameter, applies it recursively to every element in the list, and returns the resulting new list. </p> <pre><code>  public &lt;R&gt; EagerList&lt;R&gt; map(Transformer&lt;? super T, ? extends R&gt; mapper) {\n    return new EagerList&lt;&gt;(mapper.transform(this.head()), this.tail().map(mapper));\n  }\n</code></pre> <p>We can also provide the <code>filter</code> method, that takes in lambda expression as a parameter and tests if each element in the list passes the test.  We return the list containing only the elements that pass the given test.</p> <pre><code>  public EagerList&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; cond) {\n    if (cond.test(this.head())) {\n      return new EagerList&lt;&gt;(this.head(), this.tail().filter(cond));\n    }\n    return this.tail().filter(cond);\n  }\n</code></pre> <p>We have the special <code>Sentinel</code> cases,</p> <pre><code>  @Override\n  public &lt;R&gt; EagerList&lt;R&gt; map(Transformer&lt;? super Object, ? extends R&gt; mapper) {\n    return empty();\n  }\n\n  @Override\n  public EagerList&lt;Object&gt; filter(BooleanCondition&lt;? super Object&gt; cond) {\n    return empty();\n  }\n</code></pre> <p>The resulting list can be used this way:</p> <pre><code>EagerList&lt;Integer&gt; l = EagerList.iterate(1, i -&gt; i &lt; 10, i -&gt; i + 1) // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    .filter(i -&gt; i % 3 == 0)                                         // [      3,       6,       9]\n    .map(i -&gt; i * 2);                                                // [      6,      12,      18]\nl.head();        // 6\nl.tail().head(); // 12\nl.tail().tail().head(); // 18\nl.get(2);               // 18\n</code></pre>"},{"location":"33-infinitelist.html#an-infinite-list","title":"An Infinite List","text":"<p>Lazy evaluation allows us to delay the computation that produces data until the data is needed.  This powerful concept enables us to build computationally-efficient data structures.  We will focus on building a list with a possibly infinite number of elements -- something that couldn't be done without lazy evaluation.  Any eager-evaluation-based solution will just run in an infinite loop if the list is infinitely long.  For instance,</p> <pre><code>EagerList.iterate(\"\", s -&gt; s.length() &gt;= 0, s -&gt; s + \"a\"); // infinite loop\n</code></pre> <p>Just as we saw in the previous unit, we can delay a computation by using the <code>Producer</code> functional interface (or anything equivalent).  Instead of doing <code>compute()</code> which is immediately evaluated when executed, we replace it with a <code>Producer</code> instantiated with lambda expression <code>() -&gt; compute()</code>, which \"stores\" the computation in an instance of <code>Producer</code>, and we only call it when we invoke the <code>produce()</code> method.</p> <p>Instead of storing the head and tail of the list, we can think of an infinite list as consisting of two functions, the first is a function that generates head, and the second is a function that generates the tail.  Our <code>InfiniteList</code> looks like this:</p> InfiniteList v0.1<pre><code>class InfiniteList&lt;T&gt; {\n  private final Producer&lt;T&gt; head;\n  private final Producer&lt;InfiniteList&lt;T&gt;&gt; tail;\n\n  public InfiniteList(Producer&lt;T&gt; head, Producer&lt;InfiniteList&lt;T&gt;&gt; tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  public T head() {             // be careful, the method name\n    return this.head.produce(); // is the same as the field name\n  }\n\n  public InfiniteList&lt;T&gt; tail() { // same here, method name\n    return this.tail.produce();   // is the same as field name\n  }\n\n  public T get(int n) {\n    if (n == 0) {\n      return this.head();          // be careful!\n    }                              //   use the methods\n    return this.tail().get(n - 1); //   instead of fields\n  }\n}\n</code></pre> <p>Note that we don't need a <code>Sentinel</code> for now.  We will need it if we have operations that truncate the list to a finite one, but let's not worry about it yet.</p> <p>We now change the <code>generate</code> method to be lazy, by passing in a producer instead.  We no longer need to pass in the size, since the list can be infinitely long!</p> <pre><code>  public static &lt;T&gt; InfiniteList&lt;T&gt; generate(Producer&lt;T&gt; producer) {\n    return new InfiniteList&lt;T&gt;(producer,\n        () -&gt; generate(producer));\n  }\n</code></pre> <p>We can change <code>iterate</code> as well to only iterate through and generate the next element when we need it.  Note that we no longer need to provide the terminating condition <code>cond</code>.</p> <pre><code>  public static &lt;T&gt; InfiniteList&lt;T&gt; iterate(T init, Transformer&lt;T, T&gt; next) {\n    return new InfiniteList&lt;T&gt;(() -&gt; init,\n        () -&gt; iterate(next.transform(init), next));\n  }\n</code></pre> <p>Here are some examples of how to use the two methods above:</p> <pre><code>InfiniteList&lt;Integer&gt; ones = InfiniteList.generate(() -&gt; 1);       // [1, 1, 1, 1, ... ]\nInfiniteList&lt;Integer&gt; evens = InfiniteList.iterate(0, x -&gt; x + 2); // [0, 2, 4, 6, ... ]\nevens.head(); // -&gt; 0\nevens.get(5); // -&gt; 10\nevens = evens.tail(); \nevens.head(); // -&gt; 2\nevens.get(6); // -&gt; 14\n</code></pre> <p>Both the lists <code>ones</code> and <code>evens</code> are infinitely long, but due to lazy evaluation, we do not generate all the elements in advance, but only when an element is needed.  </p>"},{"location":"33-infinitelist.html#map","title":"Map","text":"<p>Let's now write the lazy version of <code>map</code> as well:</p> <pre><code>public &lt;R&gt; InfiniteList&lt;R&gt; map(Transformer&lt;? super T, ? extends R&gt; mapper) {\n  return new InfiniteList&lt;&gt;(\n      () -&gt; mapper.transform(this.head()),\n      () -&gt; this.tail().map(mapper));\n}\n</code></pre> <p>The <code>map</code> method is lazy. All it does is create a new list initialized with a new lambda expression that applies the given lambda expression <code>mapper</code> to the head and the tail.</p> <p>When we run: <pre><code>evens.map(x -&gt; x + 1);\nevens.map(x -&gt; x + 1).map(x -&gt; x * 2);\n</code></pre></p> <p>We get an infinite list with elements 1, 3, 5, 7, etc, but the values in the list are not realized until they are needed, just like before.  Only when we call <code>head()</code> will we evaluate the lambda expressions and obtain the results:</p> <pre><code>evens.map(x -&gt; x + 1).map(x -&gt; x * 2).head(); // 2\n</code></pre>"},{"location":"33-infinitelist.html#under-the-hood","title":"Under The Hood","text":"<p>It is worthwhile to trace through the code and understand how <code>head()</code> works.  For simplicity, let's put all our code together for easy reference.</p> InfiniteList v0.2<pre><code>class InfiniteList&lt;T&gt; {\n  private final Producer&lt;T&gt; head;\n  private final Producer&lt;InfiniteList&lt;T&gt;&gt; tail;\n\n  public static &lt;T&gt; InfiniteList&lt;T&gt; generate(Producer&lt;T&gt; producer) {\n    return new InfiniteList&lt;T&gt;(producer,\n        () -&gt; InfiniteList.generate(producer));\n  }\n\n  public static &lt;T&gt; InfiniteList&lt;T&gt; iterate(T init, Transformer&lt;T, T&gt; next) {\n      return new InfiniteList&lt;T&gt;(() -&gt; init,\n      () -&gt; InfiniteList.iterate(next.transform(init), next));\n  }\n\n  public InfiniteList(Producer&lt;T&gt; head, Producer&lt;InfiniteList&lt;T&gt;&gt; tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  public T head() {             // be careful, the method name\n    return this.head.produce(); // is the same as the field name\n  }\n\n  public InfiniteList&lt;T&gt; tail() { // same here, method name\n    return this.tail.produce();   // is the same as field name\n  }\n\n  public T get(int n) {\n    if (n == 0) {\n      return this.head();          // be careful!\n    }                              //   use the methods\n    return this.tail().get(n - 1); //   instead of fields\n  }\n\n  public &lt;R&gt; InfiniteList&lt;R&gt; map(Transformer&lt;? super T, ? extends R&gt; mapper) {\n    return new InfiniteList&lt;&gt;(\n        () -&gt; mapper.transform(this.head()),\n        () -&gt; this.tail().map(mapper));\n  }\n}\n</code></pre> <p>Let's rewrite the statement <pre><code>evens.map(x -&gt; x + 1).map(x -&gt; x * 2).head(); // 2\n</code></pre></p> <p>into something uglier and more verbose, but with intermediate variables to help us explain what happens when the statement above is invoked.</p> <pre><code>InfiniteList&lt;Integer&gt; evens = InfiniteList.iterate(0, x -&gt; x + 2); // [0, 2, 4 , 6 , ... ]\nInfiniteList&lt;Integer&gt; odds = evens.map(x -&gt; x + 1);                // [1, 3, 5 , 7 , ... ]\nInfiniteList&lt;Integer&gt; altEvens = odds.map(x -&gt; x * 2);             // [2, 6, 10, 14, ... ] \naltEvens.head();\n</code></pre> <p>Let's look at what gets created on the heap when we run</p> <pre><code>InfiniteList&lt;Integer&gt; evens = InfiniteList.iterate(0, x -&gt; x + 2); // [0, 2, 4 , 6 , ... ]\n</code></pre> <p></p> <p>The figure above shows the objects created.  <code>evens</code> is an instance of <code>InfiniteList</code>, with two fields, <code>head</code> and <code>tail</code>, each pointing to an instance of <code>Producer&lt;T&gt;</code>.  The two instances of <code>Producer&lt;T&gt;</code> capture the variable <code>init</code>.  The <code>tail</code> additionally captures the variable <code>next</code>, which itself is an instance of <code>Transformer&lt;T,T&gt;</code>. </p> <p>Next, let's look at what gets created on the heap when we run</p> <pre><code>InfiniteList&lt;Integer&gt; odds = evens.map(x -&gt; x + 1);                // [1, 3, 5 , 7 , ... ]\n</code></pre> <p></p> <p>The figure above shows the objects added.  <code>odds</code> is an instance of <code>InfiniteList</code>, with two fields, <code>head</code> and <code>tail</code>, each pointing to an instance of <code>Producer&lt;T&gt;</code>.  The two instances of <code>Producer&lt;T&gt;</code> capture the local variable <code>this</code> and <code>mapper</code> of the method <code>map</code>.  <code>mapper</code> refers to an instance of <code>Transformer&lt;T, T&gt;</code>.  Since the method <code>map</code> of <code>evens</code> is called, the <code>this</code> reference refers to the object <code>evens</code>. </p> <p>After calling  <pre><code>InfiniteList&lt;Integer&gt; altEvens = odds.map(x -&gt; x * 2);             // [2, 6, 10, 14, ... ] \n</code></pre></p> <p>We have the following objects set up.</p> <p></p> <p>Let's now trace through what happens when we call <code>altEvens.head()</code>.  This method leads to the call <code>this.head().produce()</code>, where <code>this</code> refers to <code>altEvens</code>.  The call to <code>produce</code> invoked <code>mapper.transform(this.head.produce())</code> of the producer labelled 1 in the figure below.  This leads to <code>this.head.produce()</code> of this producer being called.  Within this producer, <code>this</code> refers to <code>odds</code>, and so <code>this.head.produce()</code> invoked <code>mapper.transform(this.head.produce())</code> of the producer labelled 2.   Now, <code>this</code> refers to <code>evens</code>, and <code>this.head.produce()</code> causes the producer <code>() -&gt; init</code> (labelled 3) to produce 0.</p> <p></p> <p>The execution now returns to the invocation of <code>mapper.transform(this.head.produce())</code> and call <code>mapper.transform(0)</code> (labelled 4).  This returns the value 1, which we pass into the <code>mapper.transform(1)</code> (labelled 5).  The <code>mapper</code> is <code>x -&gt; x * 2</code> so we have the result 2, which we return from <code>altEvens.head()</code>.</p> <p>This process shows a very different order of execution than <code>EagerList</code>. If we run,  <pre><code>EagerList.iterate(0, x -&gt; x &lt; 10, x -&gt; x + 2)\n    .map(x -&gt; x + 1)\n    .map(x -&gt; x * 2)\n    .head();\n</code></pre></p> <p>The method <code>iterate</code> generates all the elements first, then all the elements gets <code>map</code>-ed with <code>x -&gt; x + 1</code>, then with <code>x -&gt; x + 2</code>, and then the first element is retrieved.  </p> <p>When we run,  <pre><code>InfiniteList.iterate(0, x -&gt; x + 2)\n    .map(x -&gt; x + 1)\n    .map(x -&gt; x * 2)\n    .head();\n</code></pre></p> <p>The method calls <code>iterate</code> and <code>map</code> only set up the producers that call other producers.  The call to <code>head()</code> is the trigger that causes the chain of producers to produce a value.</p>"},{"location":"33-infinitelist.html#filtering-a-lazy-list","title":"Filtering A Lazy List","text":"<p>Now, let's consider how we would filter an <code>InfiniteList</code>.  This is a bit trickier.  The following naive version does not work. <pre><code>  // wrong\n  public InfiniteList&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; cond) {\n    if (cond.test(this.head())) {\n      return new InfiniteList&lt;&gt;(this.head, () -&gt; this.tail().filter(cond));\n    }\n    return this.tail().filter(cond);\n  }\n</code></pre></p> <p>There are two things wrong with this.  First,  Line 3 <code>cond.test(this.head())</code> is actually eager.  It computes the head to test if it passes the given condition.  Second, Line 6 is eager, it produces the tail to recursively filter it.</p> <p>To make <code>filter</code> lazy, we have to perform the test in the producer that produces the head. But if the test fails, we have to mark the head as filtered.</p> <pre><code>  public InfiniteList&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; cond) {\n    Producer&lt;T&gt; newHead = () -&gt; cond.test(this.head()) ? this.head() : null;\n    return new InfiniteList&lt;&gt;(newHead, () -&gt; this.tail().filter(cond));\n  }\n</code></pre> <p>In the code above, we use <code>null</code> to indicate that the <code>head</code> is filtered for simplicity.  It is not a good practice, however since <code>null</code> could be a valid value in an infinite list.</p> <p>Putting the abuse of <code>null</code> aside, the possibility that the head produces a value that is filtered affects other methods. The methods <code>head</code> and <code>tail</code> have to be changed to: <pre><code>  public T head() {\n    T h = this.head.produce();\n    return h == null ? this.tail.produce().head() : h;  \n  }\n\n  public InfiniteList&lt;T&gt; tail() {\n    T h = this.head.produce();\n    return h == null ? this.tail.produce().tail() : this.tail.produce();  \n  }\n</code></pre></p>"},{"location":"33-infinitelist.html#further-improvements","title":"Further Improvements","text":"<p>We have seen <code>Maybe&lt;T&gt;</code> as an abstraction that encapsulates a value that is either there or is missing.  Instead of using <code>null</code> to present a value that is not there, it is better to use <code>Maybe&lt;T&gt;</code> to encapsulate the value of the head.</p> <p>Further, our implementation of <code>InfiniteList&lt;T&gt;</code> so far does not make use of memoization.  The same value keeps getting produced repeatedly.  We have built the class <code>Lazy&lt;T&gt;</code> that encapsulates a value that is produced on-demand with memoization to guarantee that it is produced at most once.  It is better to use <code>Lazy&lt;T&gt;</code> to encapsulate the value of the head as well.</p> <p>We leave the construction of an <code>InfiniteList&lt;T&gt;</code> that uses <code>Lazy&lt;Maybe&lt;T&gt;&gt;</code> for its head as an exercise.</p>"},{"location":"34-stream.html","title":"Unit 34: Streams in Java","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand how to use Java <code>Stream</code>.</li> <li>understand the difference between Java <code>Stream</code> and <code>InfiniteList</code>.</li> </ul>"},{"location":"34-stream.html#java-api","title":"Java API","text":"<p>We have been building and using our own functional interfaces and abstractions. </p> <p>Java provides its own version of functional interfaces that are comparable to ours, in the <code>java.util.function</code> package.  The table below shows some commonly used ones:</p> CS2030S java.util.function <code>BooleanCondition&lt;T&gt;::test</code> <code>Predicate&lt;T&gt;::test</code> <code>Producer&lt;T&gt;::produce</code> <code>Supplier&lt;T&gt;::get</code> <code>Consumer&lt;T&gt;::consume</code> <code>Consumer&lt;T&gt;::accept</code> <code>Transformer&lt;T,R&gt;::transform</code> <code>Function&lt;T,R&gt;::apply</code> <code>Transformer&lt;T,T&gt;::transform</code> <code>UnaryOp&lt;T&gt;::apply</code> <code>Combiner&lt;S, T, R&gt;::combine</code> <code>BiFunction&lt;S, T, R&gt;::apply</code> <p>Besides, some of the abstractions we have built have similar counterparts in Java as well:</p> CS2030S Java version <code>Some&lt;T&gt;</code>(before <code>Maybe&lt;T&gt;</code>) N/A <code>Maybe&lt;T&gt;</code> <code>java.util.Optional&lt;T&gt;</code> <code>Lazy&lt;T&gt;</code> N/A <code>InfiniteList&lt;T&gt;</code> <code>java.util.stream.Stream&lt;T&gt;</code> <p>We will focus this unit on <code>Stream</code> since the Java implementation of <code>Stream</code> is an infinite list with much more functionalities, some of which (such as parallel streams) are beyond what we can build ourselves in CS2030S.</p>"},{"location":"34-stream.html#building-a-stream","title":"Building a Stream","text":"<p>To start, let's see how we can build a stream object:</p> <ul> <li>We can use the static factory method <code>of</code> (e.g., <code>Stream.of(1, 2, 3)</code>)</li> <li>We can use the <code>generate</code> and <code>iterate</code> methods (similar to our <code>InfiniteList</code>)</li> <li>We can convert an array into a <code>Stream</code> using <code>Arrays::stream</code></li> <li>We can convert a <code>List</code> instance (or any <code>Collection</code> instance) into a <code>Stream</code> using <code>List::stream</code></li> </ul> <p>Many other APIs in Java return a <code>Stream</code> instance (e.g., <code>Files::lines</code>)</p>"},{"location":"34-stream.html#terminal-operations","title":"Terminal Operations","text":"<p>A <code>Stream</code> is lazy, just like <code>InfiniteList</code>.</p> <p>A terminal operation is an operation on the stream that triggers the evaluation of the stream.  A typical way of writing code that operates on streams is to chain a series of intermediate operations together, ending with a terminal operation.  </p> <p>The <code>forEach</code> method is a terminal operation that takes in a stream and applies a lambda expression to each element. The lambda expression to apply does not return any value.  Java provides the <code>Consumer&lt;T&gt;</code> functional interface for this.   Typical use is <pre><code>Stream.of(1, 2, 3).forEach(System.out::println);\nStream.generate(() -&gt; 1).forEach(System.out::println); // infinite loop\n</code></pre></p>"},{"location":"34-stream.html#intermediate-stream-operations","title":"Intermediate Stream Operations","text":"<p>An intermediate operation on stream returns another <code>Stream</code>.  Java provides <code>map</code>, <code>filter</code>, <code>flatMap</code>, and other intermediate operations.  Intermediate operations are lazy and do not cause the stream to be evaluated.  </p>"},{"location":"34-stream.html#flatmapping-a-stream","title":"FlatMapping a Stream","text":"<p>You have seen <code>flatMap</code> for <code>Maybe&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code>.  The method <code>flatMap</code> in <code>Stream</code> behaves similarly -- it takes a lambda expression that transforms every element in the stream into another stream.  The resulting stream of streams is then flattened and concatenated together.  </p> <p>For instance, <pre><code>Stream.of(\"hello\\nworld\", \"ciao\\nmondo\", \"Bonjour\\nle monde\", \"Hai\\ndunia\")\n    .map(x -&gt; x.lines()) // returns a stream of streams\n</code></pre></p> <pre><code>Stream.of(\"hello\\nworld\", \"ciao\\nmondo\", \"Bonjour\\nle monde\", \"Hai\\ndunia\")\n    .flatMap(x -&gt; x.lines()) // return a stream of strings\n</code></pre>"},{"location":"34-stream.html#stateful-and-bounded-operations","title":"Stateful and Bounded Operations","text":"<p>Some intermediate operations are stateful -- they need to keep track of some states to operate.  Two examples are <code>sorted</code> and <code>distinct</code>.</p> <p><code>sorted</code> returns a stream with the elements in the stream sorted.  Without argument, it sorts according to the natural order as defined by implementing the <code>Comparable</code> interface.  You can also pass in a <code>Comparator</code> to tell <code>sorted</code> how to sort.</p> <p><code>distinct</code> returns a stream with only distinct elements in the stream. </p> <p><code>distinct</code> and <code>sorted</code> are also known as <code>bounded</code> operations, since they should only be called on a finite stream -- calling them on an infinite stream is a bad idea!</p>"},{"location":"34-stream.html#truncating-an-infinite-list","title":"Truncating an Infinite List","text":"<p>There are several intermediate operations that convert from infinite stream to finite stream: </p> <ul> <li><code>limit</code> takes in an <code>int</code> \\(n\\) and returns a stream containing the first \\(n\\) elements of the stream;</li> <li><code>takeWhile</code> takes in a predicate and returns a stream containing the elements of the stream, until the predicate becomes false.  The resulting stream might still be infinite if the predicate never becomes false.</li> </ul> <p>For instance, </p> <pre><code>Stream.iterate(0, x -&gt; x + 1).takeWhile(x -&gt; x &lt; 5); \n</code></pre> <p>create a (lazy) finite stream of elements 0 to 4.</p>"},{"location":"34-stream.html#peeking-with-a-consumer","title":"Peeking with a <code>Consumer</code>","text":"<p>A particularly useful intermediate operation of <code>Stream</code> is <code>peek</code>.  <code>peek</code> takes in a <code>Consumer</code>, allowing us to apply a lambda on a \"fork\" of the stream.  For instance,</p> <pre><code>Stream.iterate(0, x -&gt; x + 1).peek(System.out::println).takeWhile(x -&gt; x &lt; 5).forEach(x -&gt; {});\n</code></pre>"},{"location":"34-stream.html#reducing-a-stream","title":"Reducing a Stream","text":"<p>One of the more powerful terminal operations in <code>Stream</code> is <code>reduce</code>, also known as <code>fold</code> or <code>accumulate</code> elsewhere, the <code>reduce</code> operation applies a lambda repeatedly on the elements of the stream to reduce it into a single value.  </p> <p>For instance, <pre><code>Stream.of(1, 2, 3).reduce(0, (x, y) -&gt; x + y);\n</code></pre> returns the sum of all elements in the stream.</p> <p>The method <code>reduce</code> takes in an identity value (<code>0</code> in the example above) and an accumulation function (<code>(x, y) -&gt; x + y</code> above) and returns the reduced value.  The process of reduction is equivalent to the following pseudocode:</p> <pre><code>result = identity\nfor each element in the stream\n     result = accumulator.apply(result, element)\nreturn result\n</code></pre> <p>Note that there are constraints on the identity and accumulation function, which are placed due to the potential parallelization of <code>reduce</code>.   We will revisit this operation later.</p> <p>Java also overloaded <code>reduce</code> with two other versions -- a simpler one (with <code>null</code> identity) and a more complex one, which supports a different returned type than the type of the elements in the stream.   You can read the java API for details.</p>"},{"location":"34-stream.html#element-matching","title":"Element Matching","text":"<p>Stream also provides terminal operations for testing if the elements pass a given predicate:</p> <ul> <li><code>noneMatch</code> returns true if none of the elements pass the given predicate.</li> <li><code>allMatch</code> returns true if every element passes the given predicate.</li> <li><code>anyMatch</code> returns true if at least one element passes the given predicate.</li> </ul>"},{"location":"34-stream.html#consumed-once","title":"Consumed Once","text":"<p>One of the greatest limitations of <code>Stream</code>, which does not apply to our <code>InfiniteList</code>, is that a stream can only be operated on once.  We cannot iterate through a stream multiple times.  Doing so would lead to an <code>IllegalStateException</code> being thrown.  We have to recreate the stream if we want to operate on the stream more than once.</p> <p>Example, <pre><code>Stream&lt;Integer&gt; s = Stream.of(1,2,3);\ns.count();\ns.count(); // &lt;- error\n</code></pre></p>"},{"location":"34-stream.html#example-is-this-a-prime","title":"Example: Is this a prime?","text":"<p>Consider the method below, which checks if a given <code>int</code> is a prime:</p> <pre><code>boolean isPrime(int x) {\n  for (int i = 2; i &lt;= x-1; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n</code></pre> <p>Let's see how we can rewrite this with <code>Stream</code>.  Due to the overhead of wrapper classes, Java provides specialized streams on primitives: <code>IntStream</code>, <code>LongStream</code>, and <code>DoubleStream</code>, with similar set of methods provided.  Since we are dealing with <code>int</code> here, we will use <code>IntStream</code>.  The code above can be rewritten as:</p> <pre><code>boolean isPrime(int x) {\n  return IntStream.range(2, x)\n      .noneMatch(i -&gt; x % i == 0);\n}\n</code></pre> <p>The <code>IntStream::range(x,y)</code> method generates a stream of <code>int</code> from <code>x</code> to <code>y-1</code>.</p>"},{"location":"34-stream.html#example-first-500-primes","title":"Example: First 500 primes","text":"<p>What if we want to print out the first 500 prime numbers, starting from 2?  Normally, we would do the following: <pre><code>void fiveHundredPrime() {\n  int count = 0;\n  int i = 2;\n  while (count &lt; 500) {\n    if (isPrime(i)) {\n      System.out.println(i);\n      count++;\n    }\n    i++;\n  }\n}\n</code></pre></p> <p>The code is still considered simple, and understandable for many, but I am sure some of us will encounter a bug the first time we write this (either forgot to increment the counter or put the increment in the wrong place).  If you look at the code, there are a couple of components:</p> <ul> <li>Lines 3 and 9 deal with iterating through different numbers for primality testing</li> <li>Line 5 is the test of whether a number is prime</li> <li>Lines 2, 4, and 7, deal with limiting the output to 500 primes</li> <li>Line 6 is the action to perform on the prime</li> </ul> <p>With streams, we can write it like the following: <pre><code>IntStream.iterate(2, x -&gt; x+1)\n    .filter(x -&gt; isPrime(x))\n    .limit(500)\n    .forEach(System.out::println);\n</code></pre></p> <p>Notice how each of the four components matches neatly with one operation on stream!  </p> <p>With a stream, we no longer have to write loops, we have moved the iterations to within each operation in the stream.  We no longer need to maintain states and counters, they are done within each operation as needed as well.  This has another powerful implication: our code becomes more declarative, we only need to concern about what we want at each step, much less about how to do it.  Doing so makes our code more succinct and less bug-prone.</p>"},{"location":"34-stream.html#caution-avoid-overusing-streams","title":"Caution: Avoid Overusing Streams","text":"<p>We will end this unit with a note of caution.</p> <p>Using stream in place of loops should make our code simpler, more elegant, and less bug-prone.  One should note that not all loops can be translated into stream elegantly.  A double-nested loop, for instance, stretches the elegance of streams.  A triple-nested loop should perhaps be best written as a loop with appropriate inner components written with lambdas and streams.</p> <p>As you go through exercises in using streams, you will find more examples of the limitations of streams.</p>"},{"location":"35-logger.html","title":"Unit 35: Loggable","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand why we need the <code>flatMap</code> method.</li> </ul>"},{"location":"35-logger.html#the-story-so-far","title":"The Story So Far","text":"<p>So far in the class, we have seen very general abstractions that support the <code>flatMap</code> operation.  But, it is not clear where this operation comes from, why is it fundamental, nor why is it useful<sup>1</sup></p> <p>In this unit, we are going to build a general abstraction step-by-step, get stuck at some point, and see how <code>flatMap</code> comes to our rescue, and hopefully, through this exercise, you will get some appreciation of <code>flatMap</code>.</p>"},{"location":"35-logger.html#function-composition","title":"Function Composition","text":"<p>Let's start with some methods that we wish to operate over <code>int</code>.  Let's use some trivial functions so that we don't get distracted by its details.</p> <pre><code>int incr(int x) {\n  return x + 1;\n}\n\nint abs(int x) {\n  return x &gt; 0 ? x : -x;\n}\n</code></pre> <p>These methods are pure functions without side effects, they take in one argument and produce a result. </p> <p>Just like mathematical functions, we can compose them together in arbitrary order to form more complex operations.</p> <pre><code>incr(abs(-4));\nabs(incr(incr(5)));\n</code></pre> OOP Function Composition <p>If we are following OOP, we may compose the method by returning an instance containing the method we want to compose. Since there can only be one return value, a typical approach is to mutate our own instance. Consider a class containing a single integer value below with <code>incr</code> and <code>abs</code>.</p> <pre><code>class MyInt {\n  private int val;\n\n  public MyInt(int val) {\n    this.val = val;\n  }\n\n  public MyInt incr() {\n    this.val += 1;\n    return this;\n  }\n\n  public MyInt abs() {\n    if (this.val &lt; 0) {\n      this.val = -this.val;\n    }\n    return this;\n  }\n}\n</code></pre> <p>Then the composition example above can be rewritten as follows.</p> <pre><code>MyInt x = new MyInt(-4);\nx = x.abs().incr();\n\nMyInt y = new MyInt(5);\ny = y.incr().incr().abs();\n</code></pre> <p>The better solution is of course to make it immutable.</p>"},{"location":"35-logger.html#loggable-with-pair","title":"<code>Loggable</code> with <code>Pair</code>","text":"<p>Suppose now we want to return not only an <code>int</code>, but some additional information related to the operation on <code>int</code>.  For instance, let's suppose we want to return a string describing the operation (for logging).  Java does not support returning multiple values, so let's return a <code>Pair</code>.</p> <pre><code>Pair&lt;Integer,String&gt; incrWithLog(int x) {\n  return Pair.of(incr(x), \"; incr \" + x);\n}\n\nPair&lt;Integer,String&gt; absWithLog(int x) {\n  return Pair.of(abs(x), \"; abs \" + x);\n}\n</code></pre> <p>Now, we can't compose the methods as cleanly as before.  This is because the return value of <code>absWithLog</code> is a <code>Pair&lt;Integer,String&gt;</code> but <code>incrWithLog</code> accepts an <code>int</code> as its parameter.</p> <pre><code>incrWithLog(absWithLog(-4));  // error\n</code></pre> <p>We will need to change our methods to take in <code>Pair&lt;Integer,String&gt;</code> as the argument.</p> <pre><code>Pair&lt;Integer,String&gt; incrWithLog(Pair&lt;Integer,String&gt; p) {\n  return Pair.of(incr(p.first), p.second + \"; incr \" + p.first);\n}\n\nPair&lt;Integer,String&gt; absWithLog(Pair&lt;Integer,String&gt; p) {\n  return Pair.of(abs(p.first), p.second + \"; abs \" + p.first);\n}\n</code></pre> <p>We can now compose the methods.</p> <pre><code>incrWithLog(absWithLog(Pair.of(-4, \"\"))); \n</code></pre>"},{"location":"35-logger.html#loggable-class","title":"<code>Loggable</code> Class","text":"<p>Let's do it in a more OO-way by writing a class to replace <code>Pair</code>.</p> Loggable v0.1<pre><code>class Loggable {\n  private final int value;\n  private final String log;\n\n  private Loggable(int value, String log) {\n    this.value = value;\n    this.log = log;\n  }\n\n  public static Loggable of(int value) {\n    return new Loggable(value, \"\");\n  }\n\n  Loggable incrWithLog() {\n    return new Loggable(incr(this.value), this.log + \"; incr \" + this.value);\n  }\n\n  Loggable absWithLog() {\n    return new Loggable(abs(this.value), this.log + \"; abs \" + this.value);\n  }\n\n  public String toString() {\n    return \"value: \" + this.value + \", log: \" + this.log;\n  }\n}\n</code></pre> <p>We can use the class above as:</p> <pre><code>Loggable x = Loggable.of(4);\nLoggable z = x.incrWithLog().absWithLog();\n</code></pre> <p>Note that we can now chain the methods together to compose them.  Additionally, the log messages get passed from one call to another and get \"composed\" as well.</p>"},{"location":"35-logger.html#making-loggable-general","title":"Making <code>Loggable</code> general","text":"<p>There are many possible operations on <code>int</code>, and we do not want to add a method <code>fooWithLog</code> for every function <code>foo</code>.  One way to make <code>Loggable</code> general is to abstract out the <code>int</code> operation and provide that as a lambda expression to <code>Loggable</code>.  This is what the <code>map</code> method does. </p> <pre><code>  Loggable map(Transformer&lt;Integer,Integer&gt; transformer) {\n    return new Loggable(transformer.transform(this.value), this.log); \n  }\n</code></pre> <p>We can use it like:</p> <pre><code>Loggable.of(4).map(x -&gt; incr(x)).map(x -&gt; abs(x))\n</code></pre> <p>We can still chain the methods together to compose them.</p> <p>But, <code>map</code> allows us to only apply the function to the value.  What should we do to the log messages?  Since the given lambda returns an int, it is not sufficient to tell us what message we want to add to the log.</p> <p>To fix this, we will need to pass in a lambda expression that takes in an integer, but return us a pair of integer and a string, in other words, return us a <code>Loggable</code>.  We call our new method <code>flatMap</code>.</p> <pre><code>  Loggable flatMap(Transformer&lt;Integer,Loggable&gt; transformer) {\n    Loggable l = transformer.transform(this.value);\n    return new Loggable(l.value, l.log + this.log); \n  }\n</code></pre> <p>By making <code>flatMap</code> takes in a lambda that returns a pair of integer and string, <code>Loggable</code> can rely on these lambda to tell it how to update the log messages.  Now, if we have methods like this:</p> <pre><code>Loggable incrWithLog(int x) {\n  return new Loggable(incr(x), \"; incr \" + x);\n}\n\nLoggable absWithLog(int x) {\n  return new Loggable(abs(x), \"; abs \" + x);\n}\n</code></pre> <p>We can write: <pre><code>Loggable.of(4)\n        .flatMap(x -&gt; incrWithLog(x))\n        .flatMap(x -&gt; absWithLog(x))\n</code></pre></p> <p>to now compose the methods <code>incr</code> and <code>abs</code> together, along with the log messages!</p>"},{"location":"35-logger.html#making-loggable-more-general","title":"Making <code>Loggable</code> More General","text":"<p>We started with an operation on <code>int</code>, but our <code>Loggable</code> class is fairly general and should be able to add a log message to any operation of any type.  We can make it so by making <code>Loggable</code> a generic class.</p> Loggable v0.2<pre><code>class Loggable&lt;T&gt; {\n  private final T value;\n  private final String log;\n\n  private Loggable(T value, String log) {\n    this.value = value;\n    this.log = log;\n  }\n\n  public static &lt;T&gt; Loggable&lt;T&gt; of(T value) {\n    return new Loggable&lt;&gt;(value, \"\");\n  }\n\n  public &lt;R&gt; Loggable&lt;R&gt; flatMap(Transformer&lt;? super T, ? extends Loggable&lt;? extends R&gt;&gt; transformer) {\n    Loggable&lt;? extends R&gt; l = transformer.transform(this.value);\n    return new Loggable&lt;&gt;(l.value, l.log + this.log);\n  }\n\n  public String toString() {\n    return \"value: \" + this.value + \", log: \" + this.log;\n  }\n}\n</code></pre> <ol> <li> <p>This note is inspired by The Best Introduction to Monad. Another excellent notes on category theory is by Bartosz Milewski \u21a9</p> </li> </ol>"},{"location":"36-monad.html","title":"Unit 36: Monad","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand what are functors and monads</li> <li>understand the laws that a functor and monad must obey and be able to verify them</li> </ul>"},{"location":"36-monad.html#generalizing-loggablet","title":"Generalizing <code>Loggable&lt;T&gt;</code>","text":"<p>We have just created a class <code>Loggable&lt;T&gt;</code> with a <code>flatMap</code> method that allows us to operate on the value encapsulated inside, along with some \"side information\".  <code>Loggable&lt;T&gt;</code> follows a pattern that we have seen many times before.  We have seen this in <code>Maybe&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code>, and <code>InfiniteList&lt;T&gt;</code>.  Each of these classes has:</p> <ul> <li>an <code>of</code> method to initialize the value and side information.</li> <li>have a <code>map</code> method to update the value.</li> <li>have a <code>flatMap</code> method to update the value and side information<sup>1</sup>.</li> </ul> <p>Different classes above have different side information that is initialized, stored, and updated when we use the <code>of</code> and <code>flatMap</code> operations.  The class may also have other methods besides the two above.  Additionally, the methods may have different name.</p> Container Side-Information <code>Maybe&lt;T&gt;</code> The value might be there (i.e., <code>Some&lt;T&gt;</code>) or might not be there (i.e., <code>None</code>) <code>Lazy&lt;T&gt;</code> The value has been evaluated or not <code>Loggable&lt;T&gt;</code> The log describing the operations done on the value <p>These classes that we wrote follow certain patterns that make them well behaved when we create them with <code>of</code> and chain them with <code>flatMap</code>.  Such classes that are \"well behaved\" are examples of a programming construct called monads.  A monad must follow three laws, to behave well.  We will examine them later.</p> <p>For now, note that we can further generalize <code>Loggable&lt;T&gt;</code> by abstracting the <code>log</code> into a generic type.  Previously, the <code>log</code> is always a <code>String</code>.  In this generalization, the <code>log</code> will be named as <code>context</code> with the type becoming a generic type <code>S</code>.  We can then call this abstraction a <code>Monad&lt;T,S&gt;</code>.</p> <pre><code>class Monad&lt;T, S&gt; {\n  private final T content; // the content (value to be operated on)\n  private final S context; // the context (side-information)\n\n    :\n\n  public &lt;U&gt; Monad&lt;U, S&gt; map(Transformer&lt;? super T, ? extends U&gt; transformer) {\n    U content = transformer.transform(this.content);\n    return new Monad(content, this.context); // preserve context\n  }\n\n  public &lt;U&gt; Monad&lt;U, S&gt; flatMap(Transformer&lt;? super T, ? extends Monad&lt;? extends U, ? extends S&gt;&gt; transformer) {\n    Monad&lt;? extends U, ? extends S&gt;&gt; next = transformer.transform(this.content);\n    return Monad.compose(this, next);\n  }\n\n  private static &lt;T, U, S&gt; Monad&lt;U, S&gt; compose(Monad&lt;T, S&gt; prev, Monad&lt;? extends U, ? extends S&gt;&gt; next) {\n      : // code omitted\n  }\n}\n</code></pre> <p>Note a few things, the <code>map</code> method should preserve the context while the <code>flatMap</code> method should compose the context (by invoking <code>compose</code> static method).  The composition of the context should follow the three laws of Monad and the behavior of <code>map</code> should satisfy the two laws of Functor.</p> <code>flatMap</code> using <code>map</code> <p>A more appropriate way to define <code>flatMap</code> is to invoke <code>map</code>.  The origin of these terms is in Category Theory where the definition of a Monad is a Functor with additional properties.  So in theory, for something to be a Monad, it has to first be a Functor and must have satisfied the properties for <code>map</code>.</p> <p>Unfortunately, no programming language can check these properties.  So, we may actually have a structure that satisfy the three laws of Monad but does not satisfy all the laws of Functor.</p> <p>If our <code>flatMap</code> invoke <code>map</code>, then we have to make changes in our definition of <code>flatMap</code>.</p> <pre><code>public &lt;U&gt; Monad&lt;U, S&gt; flatMap(Transformer&lt;? super T, ? extends Monad&lt;? extends U, ? extends S&gt;&gt; fn) {\n  Monad&lt;Monad&lt;? extends U, ? extends S&gt;, S&gt; monad = this.map(fn);\n  return Monad.combine(monad);\n}\n\nprivate static &lt;T, U, S&gt; Monad&lt;U, S&gt; combine(Monad&lt;Monad&lt;? extends U, ? extends S&gt;, S&gt; monad) {\n  U content = monad.content.content;\n  S prev = monad.context;\n  S next = monad.content.context;\n\n  return new Monad&lt;&gt;(content, Monad.compose(prev, next));\n}\n</code></pre> <p>Now we are invoking <code>combine</code> which takes in a nested monad!  But this is a special monad because the two contexts are there.  Recap that <code>map</code> preserves the context so <code>monad.context</code> is the old context.  Additionally, the content is now another Monad which has additional content and context.</p> <p>If things are confusing, do not worry, you are not expected to understand the entire details (especially not with that horrible type).  You just need to understand the three laws (and how to check for them) as well as the two laws (and how to check for them).</p>"},{"location":"36-monad.html#three-laws-of-monad","title":"Three Laws of Monad","text":"<p>The three laws below are all related to the context.  In particular, we need to ensure that the <code>compose</code> method (i.e., the composition of <code>context</code>) is associative.  In particular, we want the <code>of</code> method to add \"identity\" context and we want <code>flatMap</code> to be associative with respect to the context.</p> <p>So, the <code>of</code> method in a monad should create a new monad by initializing our monad with a value and its side information should be whatever is considered an \"empty\" side-information (more formally, this is the identity element).   For instance, in our <code>Loggable&lt;T&gt;</code>,</p> <pre><code>public static &lt;T&gt; Loggable&lt;T&gt; of(T value) {\n  return new Loggable&lt;&gt;(value, \"\");\n}\n</code></pre> <p>Now, we can look at this in more details.</p>"},{"location":"36-monad.html#identity-laws","title":"Identity Laws","text":"<p>Let's consider the lambda that we wish to pass into <code>flatMap</code>  -- such a lambda takes in a value, compute it, and wrap it in a \"new\" monad, together with the correponding side information.  For instance,</p> <pre><code>Loggable&lt;Integer&gt; incrWithLog(int x) {\n  return new Loggable&lt;&gt;(incr(x), \"incr \" + x + \"; \");\n}\n</code></pre> <p>What should we expect when we take a fresh new monad <code>Loggable.of(4)</code> and call <code>flatMap</code> with a function <code>incrWithLog</code>?  Since <code>Loggable.of(4)</code> is new with no operation performed on it yet, calling  <pre><code>Loggable.of(4).flatMap(x -&gt; incrWithLog(x)) \n</code></pre></p> <p>should just result in the same value exactly as calling <code>incrWithLog(4)</code>.  So, we expect that, after calling the above, we have a <code>Loggable</code> with a value 5 and a log message of <code>\"incr 4\"</code>.</p> <p>Our <code>of</code> method should not do anything extra to the value and side information -- it should simply wrap the value 4 into the <code>Loggable</code>.  Our <code>flatMap</code> method should not do anything extra to the value and the side information, it should simply apply the given lambda expression to the value.</p> <p>Now, suppose we take an instance of <code>Loggable</code>, called <code>logger</code>, that has already been operated on one or more times with <code>flatMap</code>, and contain some side information.  What should we expect when we call: <pre><code>logger.flatMap(x -&gt; Loggable.of(x))\n</code></pre></p> <p>Since <code>of</code> should behave like an identity, it should not change the value or add extra side information.  The <code>flatMap</code> above should do nothing and the expression above should be the same as <code>logger</code>.</p> <p>What we have just described above is called the left identity law and the right identity law of monads.  To be more general, let <code>Monad</code> be a type that is a monad and <code>monad</code> be an instance of it.</p> <p>The left identity law says:</p> <ul> <li><code>Monad.of(x).flatMap(x -&gt; f(x))</code> must be the same as <code>f(x)</code></li> </ul> <p>The right identity law says:</p> <ul> <li><code>monad.flatMap(x -&gt; Monad.of(x))</code> must be the same as <code>monad</code></li> </ul> <p>So the identity laws is not just a single law, it is actually two laws.  A good thing about this is that if both left identity and right identity element exists, it must be the same value.</p>"},{"location":"36-monad.html#associative-law","title":"Associative Law","text":"<p>Let's now go back to the original <code>incr</code> and <code>abs</code> functions for a moment.  To compose the functions, we can write <code>abs(incr(x))</code>, explicitly one function after another.  Or we can compose them as another function:  <pre><code>int absIncr(int x) {\n  return abs(incr(x));\n}\n</code></pre></p> <p>and call it <code>absIncr(x)</code>.  The effects should be exactly the same.  It does not matter if we group the functions together into another function before applying it to a value x.</p> <p>Recall that after we build our <code>Loggable</code> class, we were able to compose the functions <code>incr</code> and <code>abs</code> by chaining the <code>flatMap</code>:</p> <pre><code>Loggable.of(4)\n        .flatMap(x -&gt; incrWithLog(x))\n        .flatMap(x -&gt; absWithLog(x))\n</code></pre> <p>We should get the resulting value as <code>abs(incr(4))</code>, along with the appropriate log messages.</p> <p>Another way to call <code>incr</code> and then <code>abs</code> is to write something like this: <pre><code>Loggable&lt;Integer&gt; absIncrWithLog(int x) {\n  return incrWithLog(x).flatMap(y -&gt; absWithLog(y));\n}\n</code></pre></p> <p>We have composed the methods <code>incrWithLog</code> and <code>absWithLog</code> and grouped them under another method.  Now, if we call: <pre><code>Loggable.of(4)\n    .flatMap(x -&gt; absIncrWithLog(x))\n</code></pre></p> <p>The two expressions must have exactly the same effect on the value and its log message.</p> <p>This example leads us to the third law of monads: regardless of how we group that calls to <code>flatMap</code>, their behaviour must be the same.  This law is called the associative law.  More formally, it says:</p> <ul> <li><code>monad.flatMap(x -&gt; f(x)).flatMap(x -&gt; g(x))</code> must be the same as <code>monad.flatMap(x -&gt; f(x).flatMap(y -&gt; g(y)))</code></li> </ul>"},{"location":"36-monad.html#a-counter-example","title":"A Counter Example","text":"<p>If our monads follow the laws above, we can safely write methods that receive a monad from others, operate on it, and return it to others.  We can also safely create a monad and pass it to the clients to operate on.  Our clients can then call our methods in any order and operate on the monads that we create, and the effect on its value and side information is as expected.</p> <p>Let's try to make our <code>Loggable</code> misbehave a little.  Suppose we change our <code>Loggable&lt;T&gt;</code> to be as follows:</p> Loggable v0.3 (NOT a Monad)<pre><code>class Loggable&lt;T&gt; {\n  private final T value;\n  private final String log;\n\n  private Loggable(T value, String log) {\n    this.value = value;\n    this.log = log;\n  }\n\n  public static &lt;T&gt; Loggable&lt;T&gt; of(T value) {\n    return new Loggable&lt;&gt;(value, \"Logging starts: \");\n  }\n\n  public &lt;R&gt; Loggable&lt;R&gt; flatMap(Transformer&lt;? super T, ? extends Loggable&lt;? extends R&gt;&gt; transformer) {\n    Loggable&lt;? extends R&gt; logger = transformer.transform(this.value);\n    return new Loggable(logger.value, logger.log + this.log + \"\\n\");\n  }\n\n  public String toString() {\n    return \"value: \" + this.value + \", log: \" + this.log;\n  }\n}\n</code></pre> <p>Our <code>of</code> adds a little initialization message.  Our <code>flatMap</code> adds a little new line before appending with the given log message.  Now, our <code>Loggable&lt;T&gt;</code> is not that well behaved anymore.</p> <p>Suppose we have two methods <code>foo</code> and <code>bar</code>, both take in an <code>x</code> and perform a series of operations on <code>x</code>.  Both returns us a <code>Loggable</code> instance on the final value and its log.</p> <pre><code>Loggable&lt;Integer&gt; foo(int x) {\n  return Loggable.of(x)\n                 .flatMap(...)\n                 .flatMap(...)\n                   :\n  ;\n}\nLoggable&lt;Integer&gt; bar(int x) {\n  return Loggable.of(x)\n                 .flatMap(...)\n                 .flatMap(...)\n                   :\n  ;\n}\n</code></pre> <p>Now, we want to perform the sequence of operations done in <code>foo</code>, followed by the sequence of operations done in <code>bar</code>.  So we called: <pre><code>foo(4).flatMap(x -&gt; bar(x))\n</code></pre></p> <p>We will find that the string <code>\"Logging starts\"</code> appears twice in our logs and there is now an extra blank line in the log file!</p>"},{"location":"36-monad.html#two-laws-of-functors","title":"Two Laws of Functors","text":"<p>We will end this unit with a brief discussion on functors, another common abstraction in functional-style programming.  A functor is a simpler construction than a monad in that it only ensures lambdas can be applied sequentially to the value, without worrying about side information.</p> <p>Recall that when we build our <code>Loggable&lt;T&gt;</code> abstraction, we add a <code>map</code> that only updates the value but changes nothing to the side information.  One can think of a functor as an abstraction that supports <code>map</code>.</p> <p>A functor needs to adhere to two laws:</p> <ul> <li>preserving identity: <code>functor.map(x -&gt; x)</code> is the same as <code>functor</code></li> <li>preserving composition: <code>functor.map(x -&gt; f(x)).map(x -&gt; g(x))</code> is the same as <code>functor.map(x -&gt; g(f(x))</code>. </li> </ul> <p>Note that we can also infer what they should do to the context (if any).  If the <code>map</code> method actually modifies the context, then applying the identity function <code>x -&gt; x</code> would have modified the context.  So it would no longer be the same as the original <code>functor</code>.  So we know that <code>map</code> cannot modify context.  This also means that <code>map</code> should not even change the context into the identity context created using the <code>of</code> method.</p> <p>Our classes from <code>cs2030s.fp</code>, <code>Lazy&lt;T&gt;</code>, <code>Maybe&lt;T&gt;</code>, and <code>InfiniteList&lt;T&gt;</code> are functors as well.</p>"},{"location":"36-monad.html#monads-and-functors-in-other-languages","title":"Monads and Functors in Other Languages","text":"<p>Such abstractions are common in other languages.  In Scala, for instance, the collections (list, set, map, etc.) are monads.  In pure functional languages like Haskell, monads are one of the fundamental building blocks.</p> <ol> <li> <p>Unfortunately our <code>InfiniteList&lt;T&gt;</code> has no <code>flatMap</code> method.\u00a0\u21a9</p> </li> </ol>"},{"location":"37-parallel.html","title":"Unit 37: Parallel Streams","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be aware that a program can be broken into subtasks to run parallelly and/or concurrently </li> <li>be aware of the issues caused by running subtasks parallelly and concurrently.</li> <li>be aware that there exist tradeoffs in the number of subtasks and the processing overhead.</li> <li>be familiar with how to process a stream parallelly and correctly.</li> </ul>"},{"location":"37-parallel.html#parallel-and-concurrent-programming","title":"Parallel and Concurrent Programming","text":"<p>So far, the programs that we have written in CS2030S run sequentially.  What this means is that at any one time, there is only one instruction of the program running on a processor.</p> <p></p>"},{"location":"37-parallel.html#what-is-concurrency","title":"What is Concurrency?","text":"<p>A single-core processor can only execute one instruction at one time -- this means that only one process (or less precisely speaking, one application) can run at any one time.  Yet, when we use the computer, it feels as if we are running multiple processes at the same time.  The operating system, behind the scenes, is switching between the different processes, to give the user the illusion that they are running at the same time.</p> <p></p> <p>We can write a program so that it runs concurrently -- by dividing the computation into subtasks called threads. Such multi-thread programs are useful in two ways: (i) it allows us, the programmers, to separate unrelated tasks into threads, and write each thread separately; (ii) it improves the utilization of the processor.  For instance, if I/O is in one thread, and UI rendering is in another, then when the processor is waiting for I/O to complete, it can switch to the rendering thread to make sure that the slow I/O does not affect the responsiveness of UI.</p>"},{"location":"37-parallel.html#what-is-parallelism","title":"What is Parallelism?","text":"<p>While concurrency gives the illusion of subtasks running at the same time, parallel computing refers to the scenario where multiple subtasks are truly running at the same time -- either we have a processor that is capable of running multiple instructions at the same time, or we have multiple cores/processors and dispatch the instructions to the cores/processors so that they are executed at the same time.</p> <p></p> <p>All parallel programs are concurrent, but not all concurrent programs are parallel.</p> <p>Modern computers have more than one core/processor<sup>1</sup>.  As such, the line between parallelism and concurrency is blurred.</p>"},{"location":"37-parallel.html#parallel-computing","title":"Parallel Computing","text":"<p>Parallel computing is one of the major topics in computer science.  One can teach a whole module (or a focus area) on this topic alone.  The goal of this lecture is not to cover it in-depth but is to expose students in CS2030S to the concept of parallel computing in relation to the Stream abstraction in Java.</p>"},{"location":"37-parallel.html#parallel-stream","title":"Parallel Stream","text":"<p>We have seen that the Java <code>Stream</code> class is a powerful and useful class for processing data in a declarative style.  But, we have not fully unleashed the power of <code>Stream</code>.  The neatest thing about <code>Stream</code> is that it allows parallel operations on the elements of the stream in one single line of code.</p> <p>Let's consider the following program that prints out all the prime numbers between 2,030,000 and 2,040,000.</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n         .filter(x -&gt; isPrime(x))\n         .forEach(System.out::println);\n</code></pre> <p>We can parallelize the code by adding the call <code>parallel()</code> into the stream.</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n         .filter(x -&gt; isPrime(x))\n         .parallel()\n         .forEach(System.out::println);\n</code></pre> <p>You may observe that the output has been reordered, although the same set of numbers are still being produced.  This is because <code>Stream</code> has broken down the numbers into subsequences, and run <code>filter</code> and <code>forEach</code> for each subsequence in parallel.  Since there is no coordination among the parallel tasks on the order of the printing, whichever parallel tasks that complete first will output the result to screen first, causing the sequence of numbers to be reordered.</p> <p>If you want to produce the output in the order of input, use <code>forEachOrdered</code> instead of <code>forEach</code>, we will lose some benefits of parallelization because of this.</p> <p>Suppose now that we want to compute the number of primes between 2,030,000 and 2,040,000.  We can run:</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n         .filter(x -&gt; isPrime(x))\n         .parallel()\n         .count();\n</code></pre> <p>The code above produces the same output regardless if it is being parallelized or not.</p> <p>Note that the task above is stateless and does not produce any side effects.  Furthermore, each element is processed individually without depending on other elements.  Such computation is sometimes known as embarrassingly parallel.  The only communication needed for each of the parallel subtasks is to combine the result of <code>count()</code> from the subtasks into the final count (which has been implemented in <code>Stream</code> for us).</p>"},{"location":"37-parallel.html#how-to-parallelize-a-stream","title":"How to Parallelize a Stream","text":"<p>You have seen that adding <code>parallel()</code> to the pipeline of calls in a stream enables parallel processing of the stream.  Note that <code>parallel()</code> is a lazy operation -- it merely marks the stream to be processed in parallel.  As such, you can insert the call to <code>parallel()</code> anywhere in the pipeline after the data source and before the terminal operation.</p> <p>sequential()</p> <p>There is a method <code>sequential()</code> which marks the stream to be process sequentially.  If you call both <code>parallel()</code> and <code>sequential()</code> in a stream, the last call \"wins\".  The example below processes the stream  sequentially: <pre><code>s.parallel().filter(x -&gt; x &lt; 0).sequential().forEach(..); \n</code></pre></p> <p>Another way to create a parallel stream is to call the method <code>parallelStream()</code> instead of <code>stream()</code> of the <code>Collector</code> class.  Doing so would create a stream that will be processed in parallel from the collection.</p>"},{"location":"37-parallel.html#what-can-be-parallelized","title":"What Can be Parallelized?","text":"<p>To ensure that the output of the parallel execution is correct, the stream operations must not interfere with the stream data, and most of the time must be stateless.  Side-effects should be kept to a minimum.</p>"},{"location":"37-parallel.html#interference","title":"Interference","text":"<p>Interference means that one of the stream operations modifies the source of the stream during the execution of the terminal operation.  For instance:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"Luke\", \"Leia\", \"Han\"));\nlist.stream()\n    .peek(name -&gt; {\n         if (name.equals(\"Han\")) {\n           list.add(\"Chewie\"); // they belong together\n         }\n      })\n    .forEach(i -&gt; {});\n</code></pre> <p>would cause <code>ConcurrentModificationException</code> to be thrown.  Note that this non-interference rule applies even if we are using <code>stream()</code> instead of <code>parallelStream()</code>.</p>"},{"location":"37-parallel.html#stateful-vs-stateless","title":"Stateful vs. Stateless","text":"<p>A stateful lambda is one where the result depends on any state that might change during the execution of the stream.</p> <p>For instance, the <code>generate</code> and <code>map</code> operations below are stateful, since they depend on the state of the standard input. Parallelizing this may lead to incorrect output.  To ensure that the output is correct, additional work needs to be done to ensure that state updates are visible to all parallel subtasks.</p> <pre><code>Stream.generate(scanner::nextInt)\n    .map(i -&gt; i + scanner.nextInt())\n    .forEach(System.out::println)\n</code></pre>"},{"location":"37-parallel.html#side-effects","title":"Side Effects","text":"<p>Side-effects can lead to incorrect results in parallel execution.  Consider the following code:</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(\n    Arrays.asList(1,3,5,7,9,11,13,15,17,19));\nList&lt;Integer&gt; result = new ArrayList&lt;&gt;();\nlist.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .forEach(x -&gt; result.add(x));\n</code></pre> <p>The <code>forEach</code> lambda generates a side effect -- it modifies <code>result</code>.  <code>ArrayList</code> is what we call a non-thread-safe data structure.  If two threads manipulate it at the same time, an incorrect result may result.</p> <p>There are three ways to resolve this.  One, we can use the <code>.collect</code> method.</p> <pre><code>list.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .collect(Collectors.toList())\n</code></pre> <p>Second, we can use a thread-safe data structure.  Java provides several in <code>java.util.concurrent</code> package, including <code>CopyOnWriteArrayList</code>.</p> <pre><code>List&lt;Integer&gt; result = new CopyOnWriteArrayList&lt;&gt;();\nlist.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .forEach(x -&gt; result.add(x));\n</code></pre> <p>Lastly, in Java 21, there is a <code>.toList</code> method that simply returns a list in the same order as the stream. <pre><code>list.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .toList()\n</code></pre></p>"},{"location":"37-parallel.html#associativity","title":"Associativity","text":"<p>The <code>reduce</code> operation is inherently parallelizable, as we can easily reduce each sub-stream and then use the <code>combiner</code> to combine the results.  Consider this example:</p> <pre><code>Stream.of(1,2,3,4).reduce(1, (x, y) -&gt; x * y, (x, y) -&gt; x * y);\n</code></pre> <p>To allow us to run <code>reduce</code> in parallel, however, there are several rules that the <code>identity</code>, the <code>accumulator</code>, and the <code>combiner</code> must follow:</p> <ul> <li><code>combiner.apply(identity, i)</code> must be equal to <code>i</code>.</li> <li>The <code>combiner</code> and the <code>accumulator</code> must be associative -- the order of applying must not matter<sup>2</sup>.</li> <li>The <code>combiner</code> and the <code>accumulator</code> must be compatible -- <code>combiner.apply(u, accumulator.apply(identity, t))</code> must equal to <code>accumulator.apply(u, t)</code></li> </ul> <p>The multiplication example above meetings the three rules:</p> <ul> <li><code>i * 1</code> equals <code>i</code></li> <li><code>(x * y) * z</code> equals <code>x * (y * z)</code></li> <li><code>u * (1 * t)</code> equals <code>u * t</code></li> </ul>"},{"location":"37-parallel.html#performance-of-parallel-stream","title":"Performance of Parallel Stream","text":"<p>Let's go back to:</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n    .filter(x -&gt; isPrime(x))\n    .parallel()\n    .count();\n</code></pre> <p>How much time can we save by parallelizing the code above?</p> <p>Let's use the <code>Instant</code> and <code>Duration</code> class from Java to help us:</p> <pre><code>Instant start = Instant.now();\nlong howMany = IntStream.range(2_000_000, 3_000_000)\n                        .filter(x -&gt; isPrime(x))\n                        .parallel()\n                        .count();\nInstant stop = Instant.now();\nSystem.out.println(howMany + \" \" + Duration.between(start,stop).toMillis() + \" ms\");\n</code></pre> <p>The code above measures roughly the time it takes to count the number of primes between 2 million and 3 million.  On my iMac, it takes 450-550 ms.  If I remove <code>parallel()</code>, it takes slightly more than 1 second.  So with <code>parallel()</code> we gain about 50% performance.</p> <p>Can we parallelize some more?  Remember how we implement <code>isPrime</code><sup>3</sup></p> <pre><code>boolean isPrime(int n) {\n  return IntStream.range(2, (int)Math.sqrt(n) + 1)\n                  .noneMatch(x -&gt; n % x == 0);\n}\n</code></pre> <p>Let's parallelize this to make this even faster!</p> <pre><code>boolean isPrime(int n) {\n  return IntStream.range(2, (int)Math.sqrt(n) + 1)\n                  .parallel()\n                  .noneMatch(x -&gt; n % x == 0);\n}\n</code></pre> <p>If you run the code above, however, you will find that the code is not as fast as we expect. On my iMac, it takes about 18s, about 18 times slower!</p> <p>Parallelizing a stream does not always improve the performance.  Creating a thread to run a task incurs some overhead, and the overhead of creating too many threads might outweigh the benefits of parallelization.</p>"},{"location":"37-parallel.html#ordered-vs-unordered-source","title":"Ordered vs. Unordered Source","text":"<p>Whether or not the stream elements are ordered or unordered also plays a role in the performance of parallel stream operations.  A stream may define an encounter order.  Streams created from <code>iterate</code>, ordered collections (e.g., <code>List</code> or arrays), from <code>of</code>, are ordered.  Stream created from <code>generate</code> or unordered collections (e.g., <code>Set</code>) are unordered.</p> <p>Some stream operations respect the encounter order.  For instance, both <code>distinct</code> and <code>sorted</code> preserve the original order of elements (if ordering is preserved, we say that an operation is stable).</p> <p>The parallel version of <code>findFirst</code>, <code>limit</code>, and <code>skip</code> can be expensive on an ordered stream, since it needs to coordinate between the streams to maintain the order.</p> <p>If we have an ordered stream and respecting the original order is not important, we can call <code>unordered()</code> as part of the chain command to make the parallel operations much more efficient.</p> <p>The following, for example, takes about 700 ms on my iMac:</p> <pre><code>Stream.iterate(0, i -&gt; i + 7)\n      .parallel()\n      .limit(10_000_000)\n      .filter(i -&gt; i % 64 == 0)\n      .forEachOrdered(i -&gt; { });\n</code></pre> <p>But, with <code>unordered()</code> inserted, it takes about 350ms, a 2x speedup!</p> <pre><code>Stream.iterate(0, i -&gt; i + 7)\n      .parallel()\n      .unordered()\n      .limit(10_000_000)\n      .filter(i -&gt; i % 64 == 0)\n      .forEachOrdered(i -&gt; { });\n</code></pre> <ol> <li> <p>iPhone 12 comes with an A14 Bionic chip with six cores.  The fastest supercomputer in the world as of this writing, the Frontier, has 9,472 processors, each has 64 cores (total of 606,208 CPU cores) as well as 37,888 GPUs each has 220 cores (total of 8,335,360 GPU cores).\u00a0\u21a9</p> </li> <li> <p>It is actually NOT necessary for <code>accumulator</code> to be associative because the parallel reduce will first split the list into blocks.  Each block will actually be run in sequential order so the <code>accumulator</code> will be invoked in a specific order.  What this requirement says is that if the <code>accumulator</code> is associative (as well as other conditions), then we can sufficiently say that parallel reduce will produce the same result as sequential reduce.  So it is not a necessary but a sufficient condition.\u00a0\u21a9</p> </li> <li> <p>This is a more efficient version of the code you have seen since it stops testing after the square root of the \\(n\\).\u00a0\u21a9</p> </li> </ol>"},{"location":"38-thread.html","title":"Unit 38: Threads","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the behaviour of thread.</li> <li>be able to create a simple thread.</li> </ul>"},{"location":"38-thread.html#synchronous-programming","title":"Synchronous Programming","text":"<p>So far, when we invoke a method in Java, we expect the method to return us a value when it is done.  If the method is not done, the execution of our program stalls, waiting for the method to complete its execution.  Only after the method returns can the execution of our program continue.</p> <p>Or, if we use the lazy monad, the execution is only done when we really need the value.  But this will also stalls the execution of our program until the value is produced.</p> <p>We say that the method blocks until it returns.   Such a programming model is known as synchronous programming.</p> <p>Synchronous programming is not very efficient, especially when there are frequent method calls that block for a long period (such as methods that involve expensive computations or reading from a remote server over the Internet).</p> <p>What if we want our program to do something while we wait for the method to return?  For instance, refreshing the UI, or do other computations?</p>"},{"location":"38-thread.html#threads","title":"Threads","text":"<p>One way to achieve this is to use threads.  A thread is a single flow of execution in a program.  Since the beginning of this module, we have been writing single-thread programs, except for parallel streams in Unit 37.</p> <p>Java provides a class called <code>java.lang.Thread</code> that we can use to encapsulate a function to run in a separate thread.  The following example how we can create and run two threads:</p> <pre><code>new Thread(() -&gt; {\n  for (int i = 1; i &lt; 100; i += 1) {\n    System.out.print(\"_\");\n  }\n}).start();\n\nnew Thread(() -&gt; {\n  for (int i = 2; i &lt; 100; i += 1) {\n    System.out.print(\"*\");\n  }\n}).start();\n</code></pre> <p>The <code>new Thread(..)</code> is our usual constructor to create a <code>Thread</code> instance.  The constructor takes a <code>Runnable</code> instance as an argument.  A <code>Runnable</code> is a functional interface with a method <code>run()</code> that takes in no parameter and returns <code>void</code>.</p> All Kinds of Functional Abstraction <p>At this point, we have all possible functional abstraction if we only consider functions with at most one parameter and at most one return value.</p> Functional Abstraction Has Parameter? Has Return Value? <code>Function&lt;T, R&gt;</code> <code>Producer&lt;T&gt;</code> <code>Consumer&lt;T&gt;</code> <code>Runnable</code> <p>If we consider multiple parameters, then there are infinitely many of these.  But as we know from Currying, these are equivalent to a method with a single parameter.</p> <p>With each <code>Thread</code> instance, we run <code>start()</code>, which causes the given lambda expression to run.  Note that <code>start()</code> returns immediately.  It does not wait until after the given lambda expression completes its execution.  This property differs from what we are used to, where a method blocks until the task given completes.   This is known as asynchronous execution.</p> <p>The two threads above now run in two separate sequences of execution.  The operating system has a scheduler that decides which threads to run when, and on which core (or which processor).  You might see different interleaving of executions every time you run the same program.</p> <p>Java provides more than one way to create a thread.  The <code>Thread</code> class also contains methods that we can use to query and control, in a finer grain manner, how the thread could be executed.</p>"},{"location":"38-thread.html#names","title":"Names","text":"<p>Every thread in Java has a name, printing out its name is useful for peeking under the hood to see what is happening.  We can use the instance method <code>getName()</code> to find out the name of a thread, and the class method <code>Thread.currentThread()</code> to get the reference of the current running thread.</p> <pre><code>System.out.println(Thread.currentThread().getName()); // main\n\nnew Thread(() -&gt; {\n  System.out.print(Thread.currentThread().getName());\n  for (int i = 1; i &lt; 100; i += 1) {\n    System.out.print(\"_\");\n  }\n}).start();\n\nnew Thread(() -&gt; {\n  System.out.print(Thread.currentThread().getName());\n  for (int i = 2; i &lt; 100; i += 1) {\n    System.out.print(\"*\");\n  }\n}).start();\n</code></pre> <p>Note that the above will also print the name of the thread called <code>main</code>, which is a thread created automatically for us every time our program runs and the class method <code>main()</code> is invoked.</p> <p>With this method, you can now \"visualize\" how many parallel threads are created when you invoke a parallel stream.</p> <p>Try <pre><code>Stream.of(1, 2, 3, 4)\n      .parallel()\n      .reduce(0, (x, y) -&gt; { \n        System.out.println(Thread.currentThread().getName()); \n        return x + y; \n      });\n</code></pre></p> <p>and you will see something like this (may not be exactly this as it depends on the worker thread available):</p> <pre><code>main\nForkJoinPool.commonPool-worker-5\nForkJoinPool.commonPool-worker-5\nForkJoinPool.commonPool-worker-9\nForkJoinPool.commonPool-worker-3\nForkJoinPool.commonPool-worker-3\nForkJoinPool.commonPool-worker-3\n</code></pre> <p>being printed.  This shows four concurrent threads running to reduce the stream of 1, 2, 3, 4 (including <code>main</code>).</p> <p>If you remove the <code>parallel()</code> call as shown below</p> <pre><code>Stream.of(1, 2, 3, 4)\n      .reduce(0, (x, y) -&gt; { \n        System.out.println(Thread.currentThread().getName()); \n        return x + y; \n      });\n</code></pre> <p>then only <code>main</code> is printed, showing the reduction being done sequentially in a single thread.</p> <pre><code>main\nmain\nmain\nmain\n</code></pre>"},{"location":"38-thread.html#sleep","title":"Sleep","text":"<p>Another useful method in the <code>Thread</code> class is <code>Thread::sleep</code>.  You can cause the current execution thread to pause execution immediately for a given period (in milliseconds).   After the sleep timer is over, the thread is ready to be chosen by the scheduler to run again.</p> <p>The following code prints a <code>\".\"</code> on-screen every second while another expensive computation is running.</p> <pre><code>Thread findPrime = new Thread(() -&gt; {\n  System.out.println(\n      Stream.iterate(2, i -&gt; i + 1)\n            .filter(i -&gt; isPrime(i))\n            .limit(1_000_000L)\n            .reduce((x, y) -&gt; y)\n            .orElse(null));\n});\n\nfindPrime.start();\n\nwhile (findPrime.isAlive()) {\n  try {\n    Thread.sleep(1000);\n    System.out.print(\".\");\n  } catch (InterruptedException e) {\n    System.out.print(\"interrupted\");\n  }\n} \n</code></pre> <p>In our examples, we often use <code>Thread.sleep()</code> in our methods to pretend that we are working hard on expensive computation to keep our examples simple.</p> <p>Two more things to note:</p> <ul> <li>The example above shows how we use <code>isAlive()</code> to periodically check if another thread is still running.</li> <li>The program exits only after all the threads created run to their completion.</li> </ul>"},{"location":"39-async.html","title":"Unit 39: Asynchronous Programming","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the limitation of thread.</li> <li>understand and be able to use <code>CompletableFuture</code>.</li> </ul>"},{"location":"39-async.html#limitations-of-thread","title":"Limitations of <code>Thread</code>","text":"<p>Writing code directly with the <code>Thread</code> class gives us control on how many threads to create, what they do, how they communicate with each other, and some level of control on which thread gets executed when.  While Java's <code>Thread</code> is already a higher-level abstraction compared to, say, the <code>pthread</code> library in C and C++, it still takes a fair amount of effort to write complex multi-threaded programs in Java.</p> <p>Consider the situation where we have a series of tasks that we wish to execute concurrently and we want to organize them such that:</p> <ul> <li>Task A must start first.</li> <li>When Task A is done, we take the result from Task A, and pass it to Tasks B, C, and D.</li> <li>We want Task B and C to complete before we pass their results to Task E.  </li> </ul> <p>We also want to handle exceptions gracefully -- if one of the tasks encounters an exception, the other tasks not dependent on it should still be completed.</p> <p>Implementing the above using <code>Thread</code> requires careful coordination.  Firstly, there are no methods in <code>Thread</code> that return a value.  We need the threads to communicate through shared variables.  Secondly, there is no mechanism to specify the execution order and dependencies among them -- which thread to start after another thread completes.  Finally, we have to consider the possibility of exceptions in each of our tasks.</p> <p>Another drawback of using <code>Thread</code> is its overhead -- the creation of <code>Thread</code> instances takes up some resources in Java.  As much as possible, we should reuse our <code>Thread</code> instances to run multiple tasks.  For instance, the same <code>Thread</code> instance could have run Tasks A, B, and E in the example above.  Managing the <code>Thread</code> instances itself and deciding which <code>Thread</code> instance should run which <code>Thread</code> is a gigantic undertaking.</p>"},{"location":"39-async.html#a-higher-level-abstraction","title":"A Higher-Level Abstraction","text":"<p>What we need is a higher-level abstraction that allows programmers to focus on specifying the tasks and their dependencies, without worrying about the details.  Suppose we want to run the tasks in a single thread, we could do the following:</p> <pre><code>int foo(int x) {\n  int a = taskA(x);\n  int b = taskB(a);\n  int c = taskC(a);\n  int d = taskD(a);\n  int e = taskE(b, c)\n  return e;\n}\n</code></pre> <p>We could also use monads to chain up the computations.  Let's say that one of the tasks might not produce a value, then we can use the <code>Maybe&lt;T&gt;</code> monad:</p> <pre><code>Maybe&lt;Integer&gt; foo(int x) {\n  Maybe&lt;Integer&gt; a = Maybe.of(taskA(x));\n  Maybe&lt;Integer&gt; b = a.flatMap(i -&gt; taskB(i));\n  Maybe&lt;Integer&gt; c = a.flatMap(i -&gt; taskC(i));\n  Maybe&lt;Integer&gt; d = a.flatMap(i -&gt; taskD(i));\n  Maybe&lt;Integer&gt; e = b.combine(c, (i, j) -&gt; taskE(i, j));\n  return e;\n}\n</code></pre> <p>Assume there is such a <code>Maybe::combine</code> method to combine the result of two monads.  This can also be done using a nested <code>map</code>.  Now, if we want to perform the tasks lazily, then we can use the <code>Lazy&lt;T&gt;</code> monad:</p> <pre><code>Lazy&lt;Integer&gt; foo(int x) {\n  Lazy&lt;Integer&gt; a = Lazy.of(taskA(x));\n  Lazy&lt;Integer&gt; b = a.flatMap(i -&gt; taskB(i));\n  Lazy&lt;Integer&gt; c = a.flatMap(i -&gt; taskC(i));\n  Lazy&lt;Integer&gt; d = a.flatMap(i -&gt; taskD(i));\n  Lazy&lt;Integer&gt; e = b.combine(c, (i, j) -&gt; taskE(i, j));\n  return e;\n}\n</code></pre> <p>In fact, a monad is an abstraction of a computation!  It can be used to combine program fragments (e.g., a sequence of statements, which can also be written as functions) and we return a data with context (side information) such that we can perform additional computation (i.e., the monad!).  This kind of functions are called monadic functions.</p> <p>So, wouldn't it be nice if there is a monad that allows us to perform the tasks concurrently?  <code>java.util.concurrent.CompletableFuture</code> does just that!  Here is an example of how to use it:</p> <pre><code>CompletableFuture&lt;Integer&gt; foo(int x) {\n  CompletableFuture&lt;Integer&gt; a = CompletableFuture.completedFuture(taskA(x));\n  CompletableFuture&lt;Integer&gt; b = a.thenComposeAsync(i -&gt; taskB(i));\n  CompletableFuture&lt;Integer&gt; c = a.thenComposeAsync(i -&gt; taskC(i));\n  CompletableFuture&lt;Integer&gt; d = a.thenComposeAsync(i -&gt; taskD(i));\n  CompletableFuture&lt;Integer&gt; e = b.thenCombineAsync(c, (i, j) -&gt; taskE(i, j));\n  return e;\n}\n</code></pre> <p>We can then run <code>foo(x).get()</code> to wait for all the concurrent tasks to complete and return us the value.  <code>CompletableFuture&lt;T&gt;</code> is a monad that encapsulates a value that is either there or not there yet.  Such an abstraction is also known as a promise in other languages (e.g., <code>Promise</code> in JavaScript and <code>std::promise</code> in C++) -- it encapsulates the promise to produce a value.</p>"},{"location":"39-async.html#the-completablefuture-monad","title":"The <code>CompletableFuture</code> Monad","text":"<p>Let's now examine the <code>CompletableFuture</code> monad in more detail.  A key property of <code>CompletableFuture</code> is whether the value it promises is ready -- i.e., the tasks that it encapsulates has completed or not.</p>"},{"location":"39-async.html#creating-a-completablefuture","title":"Creating a <code>CompletableFuture</code>","text":"<p>There are several ways we can create a <code>CompletableFuture&lt;T&gt;</code> instance:</p> <ul> <li>Use the <code>completedFuture</code> method.  This method is equivalent to creating a task that is already completed and return us a value.  </li> <li>Use the <code>runAsync</code> method that takes in a <code>Runnable</code> lambda expression.  <code>runAsync</code> has the return type of <code>CompletableFuture&lt;Void&gt;</code>.  The returned <code>CompletableFuture</code> instance completes when the given lambda expression finishes.</li> <li>Use the <code>supplyAsync</code> method that takes in a <code>Supplier&lt;T&gt;</code> lambda expression.  <code>supplyAsync</code> has the return type of <code>CompletableFuture&lt;T&gt;</code>.  The returned <code>CompletableFuture</code> instance completes when the given lambda expression finishes.</li> </ul> <p>We can also create a <code>CompletableFuture</code> that relies on other <code>CompletableFuture</code> instances.  We can use <code>allOf</code> or <code>anyOf</code> methods for this.  Both of these methods take in a variable number of other <code>CompletableFuture</code> instances.  A new <code>CompletableFuture</code> created with <code>allOf</code> is completed only when all the given <code>CompletableFuture</code> completes.  On the other hand, a new <code>CompletableFuture</code> created with <code>anyOf</code> is completed when any one of the given <code>CompletableFuture</code> completes.</p> Void <p>The type <code>Void</code> in <code>CompletableFuture&lt;Void&gt;</code> is a representation of the more primitive <code>void</code>. This is quite an interesting type because how do you represent nothing-ness? Once you have a representation of it, is it truly \"nothing\"?</p> <p>The meaning of <code>CompletableFuture&lt;Void&gt;</code> is that it should not have a return value. Attempting to retrieve (see: \"Getting the Result\") the value should not be successful. In fact, you should not be able to instantiate <code>Void</code> (e.g., by making constructor throwing exceptions).</p>"},{"location":"39-async.html#chaining-completablefuture","title":"Chaining <code>CompletableFuture</code>","text":"<p>The usefulness of <code>CompletableFuture</code> comes from the ability to chain them up and specify a sequence of computations to be run.  We have the following methods:</p> <ul> <li><code>thenApply</code>, which is analogous to <code>map</code></li> <li><code>thenCompose</code>, which is analogous to <code>flatMap</code></li> <li><code>thenCombine</code>, which is analogous to <code>combine</code></li> </ul> <p>The methods above run the given lambda expression in the same thread as the caller.  There is also an asynchronous version (<code>thenApplyAsync</code>, <code>thenComposeAsync</code>, <code>thenCombineAsync</code>), which may cause the given lambda expression to run in a different thread (thus more concurrency).</p> <p><code>CompletableFuture</code> also has several methods that takes in <code>Runnable</code>.  These methods have no analogy in our lab but it is similar to <code>runAsync</code> above.</p> <ul> <li><code>thenRun</code> takes in a <code>Runnable</code>.  It executes the <code>Runnable</code> after the current stage is completed.</li> <li><code>runAfterBoth</code> takes in another <code>CompletableFuture</code><sup>1</sup> and a <code>Runnable</code>.  It executes the <code>Runnable</code> after the current stage completes and the input <code>CompletableFuture</code> are completed.</li> <li><code>runAfterEither</code> takes in another <code>CompletableFuture</code><sup>1</sup> and a <code>Runnable</code>.  It executes the <code>Runnable</code> after the current stage completes or the input <code>CompletableFuture</code> are completed.</li> </ul> <p>All of the methods that takes in <code>Runnable</code> return <code>CompletableFuture&lt;Void&gt;</code>.  Similarly, they also have the asynchronous version (<code>thenRunAsync</code>, <code>runAfterBothAsync</code>, <code>runAfterEitherAsync</code>).</p>"},{"location":"39-async.html#getting-the-result","title":"Getting the Result","text":"<p>After we have set up all the tasks to run asynchronously, we have to wait for them to complete.  We can call <code>get()</code> to get the result.  Since <code>get()</code> is a synchronous call, i.e., it blocks until the <code>CompletableFuture</code> completes, to maximize concurrency, we should only call <code>get()</code> as the final step in our code.</p> <p>The method <code>CompletableFuture::get</code> throws a couple of checked exceptions: <code>InterruptedException</code> and <code>ExecutionException</code>, which we need to catch and handle.  The former refers to the exception that the thread has been interrupted, while the latter refers to errors/exceptions during execution.</p> <p>An alternative to <code>get()</code> is <code>join()</code>.  <code>join()</code> behaves just like <code>get()</code> except that no checked exception is thrown. Instead <code>join()</code> may throw unchecked exception.</p>"},{"location":"39-async.html#example","title":"Example","text":"<p>Let's look at some examples.  Let's reuse our method that computes the i-th prime number.</p> <pre><code>int findIthPrime(int i) {\n  return Stream\n          .iterate(2, x -&gt; x + 1)\n          .filter(x -&gt; isPrime(x))\n          .limit(i)\n          .reduce((x, y) -&gt; y)\n          .orElse(0);\n}\n</code></pre> <p>Given two numbers i and j, we want to find the difference between the i-th prime number and the j-th prime number.  We can first do the following:</p> <pre><code>CompletableFuture&lt;Integer&gt; ith = CompletableFuture.supplyAsync(() -&gt; findIthPrime(i));\nCompletableFuture&lt;Integer&gt; jth = CompletableFuture.supplyAsync(() -&gt; findIthPrime(j));\n</code></pre> <p>These calls would launch two concurrent threads to compute the i-th and the j-th primes.   The method calls <code>supplyAsync</code> returns immediately without waiting for <code>findIthPrime</code> to complete.</p> <p>Next, we can say, that, when <code>ith</code> and <code>jth</code> complete, take the value computed by them, and take the difference.  We can use the <code>thenCombine</code> method: <pre><code>CompletableFuture&lt;Integer&gt; diff = ith.thenCombine(jth, (x, y) -&gt; x - y);\n</code></pre></p> <p>This statement creates another <code>CompletableFuture</code> which runs asynchronously that will compute the difference between the two prime numbers.  At this point, we can move on to run other tasks, or if we just want to wait until the result is ready, we call <pre><code>diff.join();\n</code></pre></p> <p>to get the difference between the two primes<sup>2</sup>.</p>"},{"location":"39-async.html#handling-exceptions","title":"Handling Exceptions","text":"<p>One of the advantages of using <code>CompletableFuture&lt;T&gt;</code> instead of <code>Thread</code> to handle concurrency is its ability to handle exceptions.  <code>CompletableFuture&lt;T&gt;</code> has three methods that deal with exceptions: <code>exceptionally</code>, <code>whenComplete</code>, and <code>handle</code>.   We will focus on <code>handle</code> since it is the most general.</p> <p>Suppose we have a computation inside a <code>CompletableFuture&lt;T&gt;</code> that might throw an exception.  Since the computation is asynchronous and could run in a different thread, the question of which thread should catch and handle the exception arises.  <code>CompletableFuture&lt;T&gt;</code> keeps things simpler by storing the exception and passing it down the chain of calls, until <code>join()</code> is called.  <code>join()</code> might throw <code>CompletionException</code> and whoever calls <code>join()</code> will be responsible for handling this exception.  The <code>CompletionException</code> contains information on the original exception.</p> <p>For instance, the code below would throw a <code>CompletionException</code> with a <code>NullPointerException</code> contains within it.</p> <pre><code>CompletableFuture.&lt;Integer&gt;supplyAsync(() -&gt; null)\n                 .thenApply(x -&gt; x + 1)\n                 .join();\n</code></pre> <p>Suppose we want to continue chaining our tasks despite exceptions.  We can use the <code>handle</code> method, to handle the exception.  The <code>handle</code> method takes in a <code>BiFunction</code> (imagine if we add a <code>cs2030s.fp.BiTransformer&lt;T, U, R&gt;</code>).  The first parameter to the <code>BiFunction</code> is the value, the second is the exception, the third is the return value.</p> <p>Only one of the first two parameters is meaningful.  If the exception is NOT <code>null</code>, this means that an exception has been thrown and we can use the exception (i.e., second parameter).  Otherwise, the exception is <code>null</code> and we can use the value (i.e., first parameter).</p> <p>Here is a simple example where we use <code>handle</code> to replace a default value. <pre><code>cf.thenApply(x -&gt; x + 1)\n  .handle((t, e) -&gt; (e == null) ? t : 0)\n  .join();\n</code></pre></p> <ol> <li> <p>Actually, this is a <code>CompletionStage</code> which is a supertype of <code>CompletableFuture</code>.\u00a0\u21a9\u21a9</p> </li> <li> <p>There is repeated computation in primality checks between the two calls to <code>findIthPrime</code> here, which one could optimize.  We don't do that here to keep the example simple.\u00a0\u21a9</p> </li> <li> <p>This is another instance where Java uses <code>null</code> to indicates a missing value.\u00a0\u21a9</p> </li> </ol>"},{"location":"40-forkjoin.html","title":"Unit 40: Fork and Join","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the task deque and work stealing.</li> <li>understand the behaviour of <code>fork</code> and <code>join</code> (and <code>compute</code>).</li> <li>be able to order <code>fork</code> and <code>join</code> efficiently.</li> <li>be able to use <code>RecursiveTask</code>.</li> </ul>"},{"location":"40-forkjoin.html#thread-pool","title":"Thread Pool","text":"<p>We now look under the hood of parallel <code>Stream</code> and <code>CompletableFuture&lt;T&gt;</code> to explore how Java manages its threads.  Recall that creating and destroying threads is not cheap, and as much as possible we should reuse existing threads to perform different tasks.  This goal can be achieved by using a thread pool. </p> <p>A thread pool consists of (i) a collection of threads, each waiting for a task to execute, and (ii) a collection of tasks to be executed.  Typically the tasks are put in a shared queue, and an idle thread picks up a task from the shared queue to execute.</p> <p>To illustrate this concept, here is a trivial thread pool with a single thread:</p> <pre><code>Queue&lt;Runnable&gt; queue;\nnew Thread(() -&gt; {\n  while (true) {\n    if (!queue.isEmpty()) {\n      Runnable r = queue.dequeue();\n      r.run();\n    }\n  }\n}).start();\n\nfor (int i = 0; i &lt; 100; i++) {\n  int count = i;\n  queue.add(() -&gt; System.out.println(count));\n}\n</code></pre> <p>We assume that <code>Queue&lt;T&gt;</code> can be safely modified concurrently (i.e., it is thread-safe) in the sample code above.  Otherwise, just like the example you have seen in parallel streams with <code>List</code>, items might be lost.</p>"},{"location":"40-forkjoin.html#fork-and-join","title":"Fork and Join","text":"<p>Java implements a thread pool called <code>ForkJoinPool</code> that is fine-tuned for the fork-join model of recursive parallel execution.  </p> <p>The Fork-join model is essentially a parallel divide-and-conquer model of computation.  The general idea for the fork-join model is to solve a problem by breaking up the problem into identical problems but with smaller size (fork), then solve the smaller version of the problem recursively, then combine the results (join).   This repeats recursively until the problem size is small enough -- we have reached the base case and so we just solve the problem sequentially without further parallelization.</p> <p>In Java, we can create a task that we can fork and join as an instance of abstract class <code>RecursiveTask&lt;T&gt;</code>.  <code>RecursiveTask&lt;T&gt;</code> supports the methods <code>fork()</code>, which submits a smaller version of the task for execution, and <code>join()</code> (which waits for the smaller tasks to complete and return).   <code>RecursiveTask&lt;T&gt;</code> has an abstract method <code>compute()</code>, which we, as the client, have to define to specify what computation we want to compute.</p> <p>Here is a simple <code>RecursiveTask&lt;T&gt;</code> that recursively sums up the content of an array: <pre><code>class Summer extends RecursiveTask&lt;Integer&gt; {\n  private static final int FORK_THRESHOLD = 2;\n  private int low;\n  private int high;\n  private int[] array;\n\n  public Summer(int low, int high, int[] array) {\n    this.low = low;\n    this.high = high;\n    this.array = array;\n  }\n\n  @Override\n  protected Integer compute() {\n    // stop splitting into subtask if array is already small.\n    if (high - low &lt; FORK_THRESHOLD) {\n      int sum = 0;\n      for (int i = low; i &lt; high; i++) {\n        sum += array[i];\n      }\n      return sum;\n    }\n\n    int middle = (low + high) / 2;\n    Summer left = new Summer(low, middle, array);\n    Summer right = new Summer(middle, high, array);\n    left.fork();\n    return right.compute() + left.join();\n  }\n}\n</code></pre></p> <p>To run this task, we run: <pre><code>Summer task = new Summer(0, array.length, array);\nint sum = task.compute();\n</code></pre></p> <p>The line <code>task.compute()</code> above is just like another method invocation.  It causes the method <code>compute()</code> to be invoked, and if the array is big enough, two new <code>Summer</code> instances, <code>left</code> and <code>right</code>, to be created.  <code>left</code>.  We then call <code>left.fork()</code>, which adds the tasks to a thread pool so that one of the threads can call its <code>compute()</code> method.  We subsequently call <code>right.compute()</code> (which is a normal method call).  Finally, we call <code>left.join()</code>, which blocks until the computation of the recursive sum is completed and returned.  We add the result from <code>left</code> and <code>right</code> together and return the sum.</p> <p>There are other ways we can combine and order the execution of <code>fork()</code>, <code>compute()</code>, and <code>join()</code>.  Some are better than others.  We will explore more in the exercises.</p>"},{"location":"40-forkjoin.html#forkjoinpool","title":"<code>ForkJoinPool</code>","text":"<p>Let's now explore the idea behind how Java manages the thread pool with fork-join tasks.  The details are beyond the scope of this module, but it would be interesting to note a few key points, as follows:</p> <ul> <li>Each thread has a deque<sup>1</sup> of tasks.  </li> <li>When a thread is idle, it checks its deque of tasks.  If the deque is not empty, it picks up a task at the head of the deque to execute (e.g., invoke its <code>compute()</code> method).  Otherwise, if the deque is empty, it picks up a task from the tail of the deque of another thread to run.  The latter is a mechanism called work stealing.</li> <li>When <code>fork()</code> is called, the caller adds itself to the head of the deque of the executing thread.  The method returns immediately and exeuction continues.  This may cause another <code>fork()</code> to be executed which adds another task into the head of the deque.  This is done so that the most recently forked task gets executed next, similar to how normal recursive calls.</li> <li>When <code>join()</code> is called, several cases might happen.  If the subtask to be joined hasn't been executed, its <code>compute()</code> method is called and the subtask is executed.  If the subtask to be joined has been completed (some other thread has stolen this and completed it), then the result is read, and <code>join()</code> returns.  If the subtask to be joined has been stolen and is being executed by another thread, then the current thread finds some other tasks to work on either in its local deque or steal another task from another deque.</li> </ul> <p>The beauty of the mechanism here is that the threads always look for something to do and they cooperate to get as much work done as possible.</p> <p>Note that task stealing is always done from the back.  In other words, an idle worker thread is always stealing a task from the tail of the deque of another worker thread.  This is because the order tasks are added is from the head of the deque.  So, tasks at the back is expected to have more unfinished computation compared to the tasks at the front of the deque.  This will then minimizes the number of task stealing needed<sup>2</sup>.</p> <p>The mechanism here is similar to that implemented in .NET and Rust.</p>"},{"location":"40-forkjoin.html#order-of-fork-and-join","title":"Order of <code>fork()</code> and <code>join()</code>","text":"<p>One implication of how <code>ForkJoinPool</code> adds and removes tasks from the deque is the order in which we call <code>fork()</code> and <code>join()</code>.  Since the most recently forked task is likely to be executed next, we should <code>join()</code> the most recent <code>fork()</code> task first.  In other words, the order of forking should be the reverse of the order of joining.</p> <p>In the class <code>Summer</code> above, <pre><code>left.fork();  // &gt;-----------+\nright.fork(); // &gt;--------+  | should have\nreturn right.join() // &lt;--+  | no crossing\n     + left.join(); // &lt;-----+\n</code></pre></p> <p>is more efficient than <pre><code>left.fork();  // &gt;-------------+\nright.fork(); // &gt;----------+  | there is crossing\nreturn left.join()   // &lt;---|--+\n      + right.join(); // &lt;---+\n</code></pre></p> <p>In other words, your <code>fork()</code>, <code>compute()</code>, <code>join()</code> order should form a palindrome and there should be no crossing.  Additionally, there should only be at most a single <code>compute</code> and it should be in the middle of the palindrome.</p> <p>For example, the following is ok. <pre><code>left.fork();  // &gt;-----------+\nreturn right.compute() //    | compute in middle\n     + left.join(); // &lt;-----+\n</code></pre></p> <p>But the following is not. <pre><code>return left.compute()   // this is practically\n     + right.compute(); // not even concurrent\n</code></pre></p> <p>There are a combination of reason for this efficiency.  Firstly, the operation on the deque has to be atomic.  In other words, when a thread \\(T_1\\) is operating on its deque \\(D_1\\), the thread \\(T_1\\) has to finish its operation before another thread \\(T_2\\) can operate on \\(D_1\\) (e.g., task stealing, etc).  Atomic operations are expensive by default so the more operation is being performed, the slower the program will be.</p> <p>This is coupled by the behavior of <code>join()</code> that when called, find and executes the subtask if it is not yet computed.  If this subtask is not at the front of the deque, then we require a search which is a combination of pop and push on a deque as opposed to just a single pop if the task is at the head of the deque.</p> <ol> <li> <p>A deque is a double-ended queue.  It behaves like both stack and queue.\u00a0\u21a9</p> </li> <li> <p>Of course we are assuming a \"typical\" program.  We can always create a program where the split is not equal 50%-50% of the workload but instead 90%-10%.  If the 10% of the workload is going to the task at the tail of the deque, then we actually need more stealing.\u00a0\u21a9</p> </li> </ol>"},{"location":"environments.html","title":"The CS2030S Programming Environment","text":""},{"location":"environments.html#java-version","title":"Java version","text":"<p>Java is a language that continues to evolve.  A new version is released every six months.  For CS2030S, we will only use Java 21, the most recent version with long-term support.  Specifically, we use <code>openjdk 21.0.4 2024-07-16</code> on Ubuntu 20.04.6.</p>"},{"location":"environments.html#pe-hosts","title":"PE Hosts","text":"<p>The school has provided a list of computing servers for you to use, with all the required software for CS2030S installed.  You can access them remotely via <code>ssh</code>, or Secure SHell.  The hosts are named <code>pe111</code>, <code>pe112</code>, ..., <code>pe120</code>.  (<code>pe</code> stands for \"programming environment\").  We will refer to these servers generally as the PE hosts.</p> <p>For this semester, the two servers <code>pe115</code> and <code>pe116</code> are not available.</p> <p>You can choose which of the eight hosts to use.  You share the same home directory across all the hosts (this home directory, however, is different from that of <code>stu1</code>).  If you notice that one host is crowded, you can use another host to spread out the load.</p> <p>While you can complete the programming assignments on your computers, the practical exams are done in a controlled environment using servers similar to the PE hosts.  It is therefore advisable for you to familiarize yourself with accessing the PE servers via <code>ssh</code> and edit your program with either <code>vim</code> or <code>emacs</code> (<code>vim</code> is recommended and supported).</p>"},{"location":"environments.html#accessing-the-pe-hosts","title":"Accessing the PE Hosts","text":""},{"location":"environments.html#basic-requirements","title":"Basic Requirements","text":"<ol> <li> <p>You should be familiar with the terms Unix, command-line interface, command prompt, terminal, and shell.  Read this background article if you don't.</p> </li> <li> <p>You need to have an SoC Unix account.  If you do not have one, you can apply for one online.</p> </li> <li> <p>Once you have an account, you need to activate your access to the PE hosts, which are part of the SoC computer clusters.</p> </li> <li> <p>You need a command line <code>ssh</code> client.  Windows 10, macOS, and Linux users should already have it installed by default.</p> </li> <li> <p>You need a good terminal emulator.  For Microsoft Windows users, you can use either PowerShell or Windows Terminal; Mac users can use the default Terminal or iTerm2.  </p> </li> </ol>"},{"location":"environments.html#the-command-to-ssh","title":"The Command to SSH","text":"<p>To connect to a remote host, run the following in your terminal on your local computer:</p> <pre><code>ssh &lt;username&gt;@&lt;hostname&gt;\n</code></pre> <p>Replace <code>&lt;username&gt;</code> with your SoC Unix username and <code>&lt;hostname&gt;</code> with the name of the host you want to connect to. For instance, I would do:</p> <pre><code>ssh ooiwt@pe112.comp.nus.edu.sg\n</code></pre> <p>if I want to connect to <code>pe112.comp.nus.edu.sg</code>.</p> <p>After the command above, follow the instructions on the screen.  The first time you ever connect to <code>pe112.comp.nus.edu.sg</code>, you will be warned that you are connecting to a previously unknown host.  Answer <code>yes</code>.  After that, you will be prompted with your SoC Unix password.  Note that nothing is shown on the screen when your password is entered.</p>"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","title":"Accessing The PE Hosts from Outside SoC","text":"<p>The PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside, you need to connect through SoC VPN.</p> <p>First, you need to set up a Virtual Private Network (VPN) (See instructions here).  The staff at the IT helpdesk in COM1, Level 1, will be able to help you with setting up if needed.</p> <p>SoC VPN vs NUS VPN</p> <p>Note that SoC VPN is different from NUS VPN.  Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network.</p> <p>FortiClient VPN vs FortiClient</p> <p>When you setup the SoC VPN client, please make sure that you download and install \"FortiClient VPN Only\", and not \"FortiClient\". The latter is a commercial product that would stop working after the free trial is over. On the other hand, \"FortiClient VPN\" is a free product.</p>"},{"location":"environments.html#troubleshooting","title":"Troubleshooting","text":"<p>Some common error messages and what they mean:</p> <ol> <li> <p><code>ssh: Could not resolve hostname pe1xx.comp.nus.edu.sg</code></p> <p><code>ssh</code> cannot recognize the name <code>pe1xx</code>. Likely, you tried to connect to the PE hosts directly from outside of the SoC network.</p> </li> <li> <p><code>Connection closed by 192.168.48.xxx port 22</code></p> <p>You have connected to the PE host, but you are kicked out because you have no permission to use the host.</p> <p>Make sure you have activated your access to \"SoC computer clusters\" here: https://mysoc.nus.edu.sg/~myacct/services.cgi.</p> </li> <li> <p><code>Permission denied, please try again</code></p> <p>You did not enter the correct password or username.  Please use the username and password  of your SoC Unix account which you have created here: https://mysoc.nus.edu.sg/~newacct/.</p> <p>Check that you have entered your username correctly.  It is case-sensitive.</p> <p>If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/resetpass.cgi</p> </li> <li> <p><code>Could not chdir to home directory /home/o/ooiwt: Permission denied</code></p> <p>This error means that you have successfully connected to the PE hosts, but you have no access to your home directory. </p> <p>This should not happen.  Please file a service request with SoC IT Unit at https://rt.comp.nus.edu.sg/. Include the error message, the PE hosts that you connected to, and your username.  The system administrator can reset the permission of your home directory for you.</p> </li> </ol>"},{"location":"environments.html#copying-files-between-pe-nodes-and-local-computer","title":"Copying Files between PE Nodes and Local Computer","text":"<p>Secure copy, or <code>scp</code>, is one way to transfer files between the programming environments and your local computer.  <code>scp</code> behaves just like <code>cp</code> (see Unix: Essentials).  The command takes in two arguments, the source, and the destination.  The difference is that we use the <code>&lt;username&gt;@&lt;hostname&gt;:&lt;filename&gt;</code> notation to specify a file on a remote host.</p> <p>Let's say you want to transfer a set of C files from the directory <code>lab01</code> to your local computer.  Then, on the local computer, run:</p> <pre><code>ooiwt@macbook:~$ scp ooiwt@pe111.comp.nus.edu.sg:~/lab01/*.java .\n</code></pre> <p>Warning</p> <p>If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to <code>scp</code>.  </p> <p>The expression <code>*.java</code> is a regular expression that means all files with a filename ending with <code>.java</code> (see Advanced Topics on Unix). You can copy specific files as well.  For instance, to copy the file <code>Hello.java</code> from your local computer to your <code>~/lab01</code> directory:</p> <pre><code>ooiwt@macbook:~$ scp Hello.java ooiwt@pe111.comp.nus.edu.sg:~/lab01\n</code></pre> <p><code>scp</code> supports <code>-r</code> (recursive copy) as well.</p> <p>Note that we always run <code>scp</code> on your local computer in the examples above, since the SSH server runs on the PE host.</p>"},{"location":"environments.html#setting-up-ssh-keys","title":"Setting up SSH Keys","text":"<p>The next step is not required but is a time-saver and a huge quality-of-life improvement.  You need to be familiar with basic Unix commands, including how to copy files to remote hosts (using <code>scp</code>) and how to check/change file permissions (using <code>ls -l</code> and <code>chmod</code>).  If you are still not comfortable with these commands, make sure you play with the basic Unix commands first.  You can come back and complete this step later. </p> <p>Our goal here is to set up a pair of public/private keys for authentication so that you do not need to type your password every time you log into a PE host.</p> <p>You can use the following command on your local computer to generate a pair of keys:</p> <pre><code>ssh-keygen -t rsa\n</code></pre> <p>IMPORTANT</p> <p>You will be prompted for a passphrase. This is the passphrase to protect your private key on your local computer. You can enter an empty passphrase (at the cost of weaker security) to avoid being prompted for the passphrase whenever you access the private key<sup>1</sup>.</p> <p>This command will generate two keys, a private key <code>id_rsa</code>, and a public key <code>id_rsa.pub</code>.  Keep the private key <code>id_rsa</code> on your local machine in the hidden <code>~/.ssh</code> directory and copy the public key <code>id_rsa.pub</code> to your account on PE <code>pe111</code>.  </p> <p>There are two methods to do this.  You only need to apply one of them.</p>"},{"location":"environments.html#method-1-using-ssh-copy-id","title":"Method 1: Using <code>ssh-copy-id</code>","text":"<p>If your local machine has <code>ssh-copy-id</code> installed, then, run:</p> <pre><code>ssh-copy-id &lt;username&gt;@pe111.comp.nus.edu.sg\n</code></pre> <p>You will be prompted to enter your password for the PE host.  After this step is completed, your public key will be copied to and configured for password-less login to the PE hosts.</p>"},{"location":"environments.html#method-2-using-scp","title":"Method 2: Using <code>scp</code>","text":"<p>First, use <code>scp</code> to copy the public key <code>id_rsa.pub</code> from your local machine to your home directory on PE <code>pe111</code>.  </p> <p>On <code>pe111</code>, run</p> <pre><code>cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys\n</code></pre> <p>Make sure that the permission for <code>.ssh</code> both on the local machine and on PE is set to <code>700</code> and the files <code>id_rsa</code> on the local machine and <code>authorized_keys</code> on the remote machine are set to <code>600</code>.  See the guide on using <code>ls</code> and <code>chmod</code> if you are unsure how to do this.</p> <p>Once set up, you need not enter your password every time you run <code>ssh</code> or <code>scp</code>.  </p>"},{"location":"environments.html#stability-of-network-connection","title":"Stability of Network Connection","text":"<p>Note that a stable network connection is required to use the PE hosts for a long period without interruption.   If you encounter frequent disconnections while working at home or on campus while connected wirelessly, please make sure that your Wi-Fi signal is strong and that there is no interference from other sources. </p> <p>If your connection is disconnected in the middle of editing, <code>vim</code> saves the state of the buffer for you.  See the section on recovery files on how to recover your files.</p> <p>If you find yourself facing frequent disconnection, you can consider running <code>screen</code>.  After logging into a PE host, run:</p> <pre><code>screen\n</code></pre> <p>You will see some messages, press Enter to go to the command prompt. You can now use the PE host as usual. In case you are disconnected (e.g., in the middle of editing), you can log into the same PE host again, and run:</p> <pre><code>screen -r\n</code></pre> <p>to resume your previous session.</p> <ol> <li> <p>Alternatively you can read more about setting up <code>ssh-agent</code> with a passphrase for better security.\u00a0\u21a9</p> </li> </ol>"},{"location":"github.html","title":"Linking Your PE Account to Your GitHub Account","text":""},{"location":"github.html#prerequisites","title":"Prerequisites","text":"<ol> <li>You should already have your SoC Unix account, cluster access, and SoC VPN set up, and be able to <code>ssh</code> into one of the PE hosts.  If you are not able to do this, please look at the guide on programming environments.</li> <li>You should feel comfortable running basic UNIX commands.  If you have not gone through the UNIX guide and get your hands dirty, please look at the guide and play with the various basic Unix commands.</li> <li>You should already have a GitHub account and can log into GitHub.com.</li> <li>You know how to create and edit a file in Vim.</li> </ol>"},{"location":"github.html#purpose","title":"Purpose","text":"<p>Your will be using <code>git</code> (indirectly) for retrieving skeleton code and submitting completed assignments.  We will set up your accounts on a PE host below so that <code>git</code> will be associated with your GitHub account.  This is a one-time setup.  You don't have to do this for every assignment.</p>"},{"location":"github.html#1-setting-up-gitconfig","title":"1. Setting up <code>.gitconfig</code>","text":"<p>Create and edit a file called <code>.gitconfig</code> in your home directory on the PE host, with the following content:</p> <pre><code>[user]\n  name = Your Name\n  email = Your Email\n[github]  \n  user = Your GitHub Username\n</code></pre> <p>Your email should be whatever you used to sign up on GitHub (which may not be your SoC or NUS email).</p> <p>For example, a sample <code>.gitconfig</code> looks like this:</p> <pre><code>[user]\n  name = Elsa\n  email = queen@arendelle.gov\n[github]  \n  user = elsasnow16\n</code></pre> <p>After saving this file, run:</p> <pre><code>git config --get github.user\n</code></pre> <p>It should return your GitHub username.</p> <p>It should print your GitHub username as already set.  If there is a typo, you need to edit <code>.gitconfig</code> again and reload it by repeating the command above.</p>"},{"location":"github.html#2-setting-up-password-less-login","title":"2. Setting up Password-less Login","text":""},{"location":"github.html#basic-of-ssh-keys","title":"Basic of SSH Keys","text":"<p>SSH uses public-key cryptography for authentication.  The keys come in pairs: a public key and a private key.  The private key must be kept safe and known only to you.  You should keep the private key in your PE account, and not share it with others.</p> <p>To authenticate yourself to another host or service, you configure the host/service with your public key.  When it is time for you to log in, your private key is \"matched\"<sup>1</sup> with your public key.  Since only you know your private key, the service or the host can be sure that you are you and not someone else.</p> <p>Suppose you want to log in from host X to host Y without a password.  You generate a pair of keys on X, then keep the private keys on X and store the public keys on Y.  If you want to set up SSH Keys so that you can log into a PE host from your computer without a password, for example, you generate the pair of keys on your computer (e.g., X) and then copy the public key to a PE host.</p> <p>Our goal now is to authenticate ourselves to GitHub from the PE host.  So, X is the PE host, and Y is GitHub.</p>"},{"location":"github.html#generating-ssh-keys","title":"Generating SSH keys","text":"<p>The steps are explained in detail on GitHub Docs.  Here is a summary of the steps that you should follow:</p> <p>On any of the PE hosts, run <pre><code>ssh-keygen -t ed25519 -C \"your_email@example.com\"\n</code></pre> where <code>your_email@example.com</code> is the email your associate with you, when you signed up for your GitHub account (i.e., the same one you entered in <code>.gitconfig</code>).</p> <p>The command will prompt you where to save the key.  Just press Enter to save into the default location, which is <code>$HOME/.ssh/id_ed25519</code>.</p> <p>You will then be prompted for a passphrase.  Since our goal is to automate assignment submission without needing to type anything, you should enter an empty passphrase.  This increases the security risk, but then, we are working with lab assignments, not a top-secret project.  So empty passphrase will do.</p> <p>You should see something like this: <pre><code>ooiwt@pe119:~$ ssh-keygen -t ed25519 -C \"ooiwt@comp.nus.edu.sg\"\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/o/ooiwt/.ssh/id_ed25519):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/o/ooiwt/.ssh/id_ed25519.\nYour public key has been saved in /home/o/ooiwt/.ssh/id_ed25519.pub.\nThe key fingerprint is:\nSHA256:Br3wg7mplVuPyuDz8yZVDSh8Mn5ls5+yPZhTvGzmAkk ooiwt@comp.nus.edu.sg\nThe key's randomart image is:\n+--[ED25519 256]--+\n|   .   .         |\n|    = o.=        |\n|   . =oo.=.      |\n|   .E=.=o...     |\n|  ..Bo=ooS. .    |\n| . =o+.++ o      |\n|  + +o = +       |\n|   oo = O        |\n|    .=oB..       |\n+----[SHA256]-----+\n</code></pre></p>"},{"location":"github.html#adding-your-pe-host-public-key-to-your-github-account","title":"Adding Your PE Host Public Key to Your GitHub Account","text":"<p>The next step involves logging into GitHub.com: click on your avatar in the top right corner, and choose \"Settings\".  Then choose \"SSH and GPG keys\" on the sidebar.</p> <p>Then, click either \"New SSH key\" or \"Add SSH key\".  Enter an appropriate title for the key (e.g., \"PE Hosts\").</p> <p>Next, you need to paste your public key into the text box.  Go back to your terminal and run </p> <pre><code>cat ~/.ssh/id_ed25519.pub\n</code></pre> <p>Remember that <code>cat</code> just dumps the content of the file to the standard output.  Now, you need to copy the content of the file displayed on the terminal, which is your public key, and paste it into the text box in the browser.  Your key should start with <code>ssh-ed22519</code> and ends with your email address.  For instance, this is the exact text that I copy-pasted: <pre><code>ssh-ed25519 AAAZC3NzaC1lZDI1NTE8AAAAIDdmwMpRrhRB95u7CTahehtBEeOdhSxDQdlpCxBK3KCP ooiwt@comp.nus.edu.sg\n</code></pre></p> <p>I showed the above as an example, don't use my public key for your GitHub.  Otherwise, I will have access to your account :)</p> <p>After entering the title and key above, click the green \"Add SSH key\" button to add the key you entered.  If prompted, confirm your GitHub password.</p> <p>These steps are explained in detail on GitHub Docs.</p>"},{"location":"github.html#3-checking-your-authentication-settings","title":"3. Checking Your Authentication Settings","text":"<p>To check if you can connect to <code>git@github.com</code> using SSH keys, run: <pre><code>ssh -T git@github.com\n</code></pre></p> <p>If everything is set up correctly, you will see the message <pre><code>Hi ooiwt! You've successfully authenticated, but GitHub does not provide shell access.\n</code></pre></p> <p>Otherwise, you should see <pre><code>git@github.com: Permission denied (publickey).\n</code></pre></p> <p>or other error messages.</p> <p>Note that you need to connect with the username <code>git</code>.  Do not use your GitHub username (e.g., do not use <code>ssh -T ooiwt@github.com</code>)</p> <ol> <li> <p>I skipped many cool details here.  This topic is part of CS2105 and CS2107.  Interested students can google up various articles and videos online about how public-key cryptography is used for authentication.\u00a0\u21a9</p> </li> </ol>"},{"location":"javadoc.html","title":"Javadoc","text":""},{"location":"javadoc.html#why-is-documentation-important","title":"Why is documentation important","text":"<p>One of the goals of CS2030S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S labs) and you are writing code that no one else will read except you.  CS2030S prepares you to work in software engineering teams in many ways, and one of the ways is to get you to document your code.</p> <p><code>javadoc</code> is a tool used to document Java code.  It automatically generates HTML documentation from the comments in your code.  The Java API that you have seen are generated from <code>javadoc</code>.</p>"},{"location":"javadoc.html#how-to-comment-for-javadoc","title":"How to comment for javadoc","text":"<p><code>javadoc</code> distinguishes between normal comments and comments meant for <code>javadoc</code> by how we \"fence\" the comments.  A <code>javadoc</code> comment always starts with <code>/**</code> (note the double asterisks) and ends with <code>*/</code> and is always placed immediately before a class, an interface, a constructor, a method, or field declaration.</p> <p>Example: <pre><code>/**\n * Encapsulates a circle on a 2D plane.  The operators supported \n * includes (i) checking if a point is contained in the circle,\n * and (ii) moving the circle to a new position.\n */\n</code></pre></p> <p>The first sentence is the summary sentence.  We should follow some style guidelines when writing the summary sentence (see below).</p> <p><code>javadoc</code> comments supports HTML tags.  If you are not familiar with HTML, that is fine.  We will tell you what you need to know below.</p>"},{"location":"javadoc.html#tags","title":"Tags","text":"<p><code>javadoc</code> supports tags.  Below are some tags that we would like you to use.  We use curly bracket (e.g., <code>{name}</code>) to indicate information that need to be filled in by you.</p> <ul> <li><code>@param {name} {description}</code>: describe the parameter <code>{name}</code></li> <li><code>@param &lt;{name}&gt; {description}</code>: describe the type parameter <code>{name}</code></li> <li><code>@return {description}</code> describe the return value</li> <li><code>@throws {class name} {description}</code> describe what the exception <code>{class name}</code> being thrown and what are the possible reasons</li> </ul> <p>Example</p> <pre><code>/** \n * Generate the content of the list.\n *\n * @param &lt;T&gt; The type of the elements in the list.\n * @param n The number of elements.\n * @param seed The first element.\n * @param f The transformation function on the elements.\n * @return The created list.\n */\npublic static &lt;T&gt; EagerList&lt;T&gt; generate(int n, T seed, Transformer&lt;T, T&gt; f) {\n  EagerList&lt;T&gt; eagerList = new EagerList&lt;&gt;(new ArrayList&lt;&gt;());\n  T curr = seed;\n  for (int i = 0; i &lt; n; i++) {\n    eagerList.list.add(curr);\n    curr = f.transform(curr);\n  }\n  return eagerList;\n}\n</code></pre> <p>Note how the <code>@param</code> are ordered.</p>"},{"location":"javadoc.html#style","title":"Style","text":"<ol> <li> <p>If you want to break your comments into paragraphs, insert one blank line between paragraphs.  Start a new paragraph with HTML tag <code>&lt;p&gt;</code> with no space after, and end your paragraph with HTML tag <code>&lt;/p&gt;</code>.</p> </li> <li> <p>You should use the tags <code>@param</code> <code>@return</code> and <code>@throws</code> in that order, and they should never appear without a description.</p> <ul> <li>The order of <code>@param</code> should follow how the parameters (including type parameters) appear in your method.</li> </ul> </li> <li> <p>The summary should be short and succinct.  It may not be a complete sentence, but it should still be capitalized and ends with a period.  E.g., <code>/** Encapsulates a circle on 2D plane. .. */</code></p> </li> <li> <p>You don't need to write <code>javadoc</code> for self-explanatory, simple, obvious, methods.  e.g., <code>getX()</code>, unless you want to explain what <code>x</code> means.  </p> </li> </ol>"},{"location":"javadoc.html#how-to-generate-javadoc","title":"How to generate javadoc","text":"<p>In its simplest form, you can generate <code>javadoc</code> like this:</p> <pre><code>javadoc *.java\n</code></pre> <p>This will generate the HTML files in your current directory.  </p> <p>To avoid clutters, I recommend that you specify the output directory, e.g.,</p> <pre><code>javadoc *.java -d docs\n</code></pre> <p>This will generate the documentation and put it under the <code>docs</code> subdirectory.</p> <p><code>javadoc</code> by default generates documents only for public classes, fields, and methods.  To generate documentation for everything, run</p> <pre><code>javadoc *.java -d docs -private\n</code></pre> <p>If you generate the documentation on your computer, you can view it by opening up the file <code>index.html</code> in your browser.</p>"},{"location":"javadoc.html#see-also","title":"See Also","text":"<ul> <li>Oracle's <code>javadoc</code> guide</li> </ul>"},{"location":"lab.html","title":"CS2030S Programming Exercise Guide","text":""},{"location":"lab.html#github-setup","title":"GitHub Setup","text":"<p>You need a one-time setup at the beginning of semester to link your PE account to your GitHub account.  Following the instructions here to set up your GitHub account for CS2030S.</p>"},{"location":"lab.html#vim-setup","title":"Vim Setup","text":"<p>You need a one-time setup at the beginning of the semester to install the standard vim configuration, color schemes, and plugins.  Follow the instructions here to set up your Vim for CS2030S.</p> <p>You will not be able to retrieve an exercise if the expected Vim-related directory cannot be found. </p>"},{"location":"lab.html#github-classroom","title":"GitHub Classroom","text":"<p>We will use GitHub Classroom for our programming exercise release and submission for CS2030S.</p> <p>Here are what you need to do for every programming exercise:</p>"},{"location":"lab.html#1-accept-the-programming-exercise","title":"1. Accept the Programming Exercise","text":"<p>Make sure that you have logged into GitHub.  </p> <p>WARNING</p> <p>If you have multiple GitHub accounts, make sure you use the one with the same GitHub username you have submitted to us.</p> <p>Click on the given URL to accept the programming exercise. </p> <p>A repo will be created automatically for you.</p> <p>WARNING</p> <p>Do not interact with the programming exercise repo directory using GitHub or other <code>git</code> commands.</p>"},{"location":"lab.html#2-read-and-understand-the-programming-exercise-task","title":"2. Read and Understand the Programming Exercise Task","text":"<p>The programming exercise question will be given in a link on Canvas.</p> <p>Read through the question carefully before starting your programming exercise.</p>"},{"location":"lab.html#3-get-a-copy-on-pe-hosts","title":"3. Get a Copy on PE Hosts","text":"<p>Run the command <code>~cs2030s/get exX</code> (where <code>X</code> is the programming exercise number) to clone a copy of the programming exercise on your home directory.  You will see a new directory named something like <code>exX-username</code> created, with the skeleton files and questions inside.</p> <p>You can edit the code, compile, test, etc, on the PE hosts.</p> <p>You can open two files side-by-side with <code>vim -O file1 file2</code> or in different tabs with <code>vim -p file1 file2</code>.</p> <p>WARNING</p> <p>Do not edit your code directly on GitHub.</p>"},{"location":"lab.html#4-submit-a-copy","title":"4. Submit a Copy","text":"<p>When you are ready to submit, run <code>~cs2030s/submit exX</code> (where <code>X</code> is the programming exercise number).  This will submit a copy to GitHub.  You can submit multiple times, but only the last copy will be graded.</p> <p>WARNING</p> <p>Do not use <code>git push</code> or other <code>git</code> commands to submit your code to GitHub.</p>"},{"location":"lab.html#5-receiving-feedback","title":"5. Receiving Feedback","text":"<p>The tutors will grade and comment on your submission on Github after the deadline.  You should receive both your comments and your preliminary marks on GitHub.  You can reply to their comment, etc, on GitHub as well.  Communicate with your grader via Ed (or directly if they preferred) if you think the grading is unfair.</p> <p>WARNING</p> <p>Do not change your code on GitHub after the deadline (by either re-running <code>submit</code> or using <code>git</code> commands directly).  If you wish to improve upon your code after feedback from the tutors, replicate it in your own personal repo.</p> <p>Your submission will also be automatically graded by a bot.</p>"},{"location":"lab.html#6-feedback-reports","title":"6. Feedback Reports","text":"<p>A file named <code>feedback.md</code> summarizing your marks will be placed into your GitHub repo.</p> <p>IMPORTANT WARNING</p> <p>If it is not clear to you by now, let us repeat: You should only interact with your programming exercise submissions on GitHub using the provided scripts <code>get</code> and <code>submit</code>.  Failure to do so will break our workflow and will not be appreciated.  We may deduct marks for students who do not follow this instruction.</p> <p>If you accidentally break your repo by running <code>git</code> commands on it or edit it directly on GitHub, you should save a copy of your code elsewhere, then reset your programming exercise directory, by (i) requesting your tutor to delete the repo on GitHub, (ii) deleting the corrupted programming exercise directory on PE nodes, (iii) go through Steps 1 and 2 again, then copy back your edited code into the programming exercise directory.</p>"},{"location":"lab.html#dealing-with-submission-errors","title":"Dealing with Submission Errors","text":"<p>It is the student's responsibility to ensure that the code is submitted correctly, by checking the GitHub website.  There is no grace period for students to get familiarized with the code submission process.  However, you can still earn 5% towards the final grade even if you miss some programming exercises.</p>"},{"location":"lab.html#dealing-with-broken-computers-at-home-etc","title":"Dealing with Broken Computers at Home, etc.","text":"<p>The School of Computing has more than 350 computers in various programming labs for students to use.  We do not accept excuses such as broken computers or the Internet at home as justification for late submission.  You can search for available slots in which a programming lab does not hold a class via nusmods.</p>"},{"location":"lab.html#timeline","title":"Timeline","text":"<p>The graded programming exercises are released before every Thursday at 8 am, with a deadline (usually Tuesday night in the following week) given.  You must submit each programming exercises before the deadline.</p> <p>No late submission is accepted for all CS2030S formative assessments, include programming exercises. Students, however, are given the leeway as there are more marks available than what will be awarded.</p>"},{"location":"lab.html#general-advice","title":"General Advice","text":"<p>You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding, and (iii) test your programs thoroughly.</p> <p>Remember to spend some time thinking about the design and approach to solving each question.</p> <p>Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams.</p> <p>You should test your program thoroughly with your test data before submission.</p> <p>You may assume that all input data are correct unless otherwise stated. Hence, you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof.</p>"},{"location":"lab.html#peer-learning","title":"Peer-Learning","text":"<p>We encourage students to discuss and seek help from each other and from the lab tutors if they are stuck.  Ed is a great forum for that.  However, do note that while students are encouraged to discuss the approach to the solution, students are expected to write their code independently.  Copy-pasting of code or coming up with the code together, line-by-line, is considered plagiarism.</p> <p>All programming exercises are designed to be completed within half a day.  If you get stuck on an issue for longer than that, you should talk to others.</p> <p>If you are discussing with other students on specific exercise or task, please document the discussion with the following information as comments in the program so we can keep track of them in case your submissions are flagged as plagiarism.  However, for codes that are blatant copying, no amount of documentation will suffice.</p> <pre><code>/* Discussion\n * - Participants: Deadpool &amp; Wolverine\n * - Discussion: The class diagram without specific method name.\n */\n</code></pre> <p>Both parties must provide the documentations similar to the above.  If you are using AI, please document the AI as one of the participant.  Additionally, document the prompt used and the response given.</p> <pre><code>/* Discussion\n * - Participants: Me, Myself, &amp; AI\n * - Prompt: What is the airspeed velocity of an unladen swallow?\n * - Response: An African or European swallow?\n */\n</code></pre>"},{"location":"lab.html#submissions-with-compilation-errors","title":"Submissions with Compilation Errors","text":"<p>Writing code that compiles without any compilation error is the most basic requirement for all our programming exercises and practical assessments.  You will the lowest possible score for the given exercise if your code cannot be compiled.</p>"},{"location":"lab.html#identifying-yourself","title":"Identifying Yourself","text":"<p>In every Java file that you submit, you need to identify yourself by writing your name matric number and lab group. Marks may be deducted if you fail to do so. You need to edit the line:</p> <pre><code>@author XXXX (Group YYYY)\n</code></pre> <p>and change it to something like:</p> <pre><code>@author D34DP00L (Group 9A)\n</code></pre> <p>where <code>D34DP00L</code> is the matric number of the student named <code>Deadpool</code>.  As a reminder, the matric number starts with the letter <code>A</code>.</p>"},{"location":"lab.html#method-of-submission","title":"Method of Submission","text":"<p>Please follow the instructions above to submit your homework.  Programs submitted through other means, such as emails, will NOT be accepted.</p>"},{"location":"lab.html#use-of-ed","title":"Use of Ed","text":"<p>If you have doubts about the problem statements of an assignment, you may raise them on Ed.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.</p> <p>Please exercise discretion when posting to Ed.  Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Ed (or any publicly accessible online site).</p>"},{"location":"lab.html#disallowed-syntax","title":"Disallowed Syntax","text":"<p>Some programming exercises may explicitly disallow the use of certain syntax.  If the objective of the exercise is undermined due to the use of forbidden syntax, the penalty will be heavy. If in doubt, please ask for clarification on Ed.</p>"},{"location":"lab.html#plagiarism","title":"Plagiarism","text":"<p>While we encourage discussions among students for programming assignments, each student should be responsible for writing his/her own code and should give credit to others when appropriate.</p> <p>NUS and the School of Computing have a high standard of academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy.</p> <p>We adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.</p> <p>This means that you should also guard your solution carefully, not posting them to publicly accessible places, not changing the permissions of the files on the PE hosts so that it is accessible by others, ensuring your computers are locked when not in use, etc.</p> <p>Copying others' programs will only offer a short-term reprieve. When Practical Assessment (PA) time comes, your inadequacy will be exposed and the consequence would be dire.</p>"},{"location":"style.html","title":"CS2030/S Java Style Guide","text":""},{"location":"style.html#why-coding-style-is-important","title":"Why Coding Style is Important","text":"<p>One of the goals of CS2030/S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S missions) and you are writing code that no one else will read except you and your tutor.  CS2030/S prepares you to work in a software engineering teams in many ways. One of the ways is to enforce a consistent coding style.</p> <p>If everyone on the team follows the same style, the intend of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug prone (e.g., see the Apple <code>goto fail</code> bug for an example of buggy program due to style).  Empirical studies support this:</p> <p>Quote</p> <p>\"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"</p> <p>Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.</p> <p>Many major companies enforce coding styles, and some have published them.  For CS2030, we base our (simplified) coding style on Google's Java Coding Style.  You should bookmark the link because you need to come back to it again and again.</p>"},{"location":"style.html#cs2030s-coding-style","title":"CS2030/S Coding Style","text":"<p>For CS2030S</p> <p>When marked with [\u263b], these options are already included in the <code>~/.vimrc</code> file if you follow the Vim setup guide. In fact, we recommend you follow the Vim setup guide instead and don't manually manage your own version of your <code>~/.vimrc</code> file.</p> <p>Most other source code editors have similar configuration.  </p>"},{"location":"style.html#spacing-and-indentation","title":"Spacing and Indentation","text":"<ol> <li> <p>No tabs.  Use only whitespace.  [\u263b]</p> <p>VIM Setting</p> <p>For <code>vim</code> users, you can add the following line in your <code>~/.vimrc</code> file:</p> <pre><code>set expandtab\n</code></pre> <p>So that when you press Tab it is expanded to whitespace. </p> </li> <li> <p>Block indentation is exactly two spaces. [\u263b]</p> <pre><code>if (x == 0) { \n  x++;\n  for (i = 0; i &lt; x; i++) {\n    x += i;\n  }\n}\n</code></pre> <p>VIM Setting</p> <p>For <code>vim</code> users, in <code>~/.vimrc</code>, add the following:</p> <pre><code>set tabstop=2\nset shiftwidth=2\nset autoindent\nset smartindent\n\" For Java: enabling this includes Java-specific indentation settings that handles annotations like @Override\nfiletype plugin indent on\n</code></pre> <p>To help you with indentation.</p> </li> <li> <p>Each line is limited to 80 characters in length.  You can break a long     line into multiple lines to enhance readability, this is called line wrapping.  When you do so, each continuation line is indented at least 4 spaces from the original line.</p> <p>Good Example</p> <pre><code>void foo(double a, double b, double c, double d\n    double e, double f) {\n  if ((a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d) &amp;&amp; (d &gt; e) &amp;&amp;\n    (e &gt; f)) {\n  }\n}\n</code></pre> <p>Note the 4 spaces indentation at line 2 and line 4.</p> <p>Bad Example</p> <pre><code>void foo(double a, double b, double c, double d double e, double f, double g, double h, double i) {\n  if ((a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d) &amp;&amp; (d &gt; e) &amp;&amp; (e &gt; f)) {\n  }\n}\n</code></pre> <p>In the example above, we have over 80 characters in line 1.</p> <pre><code>void foo(double a, double b, double c, double d\n  double e, double f) {\n    if ((a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d) &amp;&amp; (d &gt; e) &amp;&amp;\n      (e &gt; f)) {\n    }\n}\n</code></pre> <pre><code>void foo(double a, double b, double c, double d\ndouble e, double f) {\n  if ((a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d) &amp;&amp; (d &gt; e) &amp;&amp;\n  (e &gt; f)) {\n  }\n}\n</code></pre> <p>In the example above, we omitted the 4 spaces indentation for the continuation line.</p> <p>80 vs 100</p> <p>While we prefer lines to be limited to 80, we are OK if the length is up to 100.  Any longer, however, will be frowned upon.</p> </li> <li> <p>Indent comments at the same level as the surrounding code.  For multiple comments, align <code>*</code> with the previous line.</p> <p>Good Example</p> <pre><code>/*\n * Good style\n */\n</code></pre> <pre><code>/**\n * Good style for JavaDoc\n */\n</code></pre> <p>Bad Example</p> <pre><code>/*\n* Not a good style\n*/\n</code></pre> <pre><code>/**\n* Not a good style for JavaDoc\n*/\n</code></pre> <pre><code>/**\n  * Also not a good style for JavaDoc\n  */\n</code></pre> </li> <li> <p>White space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators (<code>+</code>, <code>-</code>, <code>/</code>, etc) as well as <code>:</code> in enhanced for-loop.  Space should also appears before and after <code>//</code> comments</p> <p>Good Example</p> <pre><code>if (x == 0) { \n  x++; // to make sure x is at least one.\n  for (i = 0; i &lt; x; i++) {\n    x += i;\n  }\n}\n</code></pre> <p>Bad Example</p> <pre><code>if(x==0){ \n  x++;//to make sure x is at least one.\n  for(i=0;i&lt;x;i++){\n    x+=i;\n  }\n}\n</code></pre> </li> </ol>"},{"location":"style.html#classes","title":"Classes","text":"<ol> <li> <p>Each file contains exactly one top-level (i.e., non-nested) class.</p> </li> <li> <p>Each top-level class resides in a source file of its own.</p> </li> <li> <p>When a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between.</p> </li> </ol>"},{"location":"style.html#braces","title":"Braces","text":"<ol> <li> <p>Braces are always used (even if the body is empty or contains a single statement).</p> </li> <li> <p>Use \"Egyptian brackets\": </p> <ul> <li>Opening brace have no line break before; but has line break after</li> <li>Closing brace has a line break before; and has a line break after (except when there is <code>else</code> or comma following a closing brace).</li> </ul> <p>Good Example</p> <pre><code>if (x == 0) {\n  x++;\n} \n</code></pre> <p>Bad Example</p> <p><pre><code>if (x == 0) { x++; }\n</code></pre> <pre><code>if (x == 0) // Allman style (do not use)\n{\n  x++;\n}\n</code></pre> <pre><code>if (x == 0) // Pico style (do not use)\n{\n  x++; }\n</code></pre></p> </li> </ol>"},{"location":"style.html#lines","title":"Lines","text":"<ol> <li> <p>Exactly one blank line after <code>import</code> statements.</p> </li> <li> <p>Each statement is followed by a line break, no matter how short the statement is.</p> <p>Good Example</p> <pre><code>x++; \ni++;\n</code></pre> <p>Bad Example</p> <pre><code>x++; i++;\n</code></pre> </li> <li> <p>There should be a blank line between constructors, methods, nested classes and static initializers.  Blank lines can be used between fields to create logical groupings.</p> </li> </ol>"},{"location":"style.html#declarations-identifiers-and-keywords","title":"Declarations, Identifiers, and Keywords","text":"<ol> <li> <p>One variable per declaration.  </p> <p>Good Example</p> <pre><code>int x;\nint y;\n</code></pre> <p>Bad Example</p> <pre><code>int x, y;\n</code></pre> </li> <li> <p>No C-style array declaration</p> <p>Good Example</p> <pre><code>String[] args;\n</code></pre> <p>Bad Example</p> <pre><code>String args[];\n</code></pre> </li> <li> <p>Class modifier appears in the following order:</p> <pre><code>public protected private abstract default static final transient volatile synchronized native strictfp\n</code></pre> <p>Good Example</p> <pre><code>public static void main(String[] args)\n</code></pre> <p>Bad Example</p> <pre><code>static public void main(String[] args)\n</code></pre> </li> <li> <p>Class names are writte in <code>UpperCamelCase</code>, method names and field names in <code>lowerCamelCase</code>, constant names in <code>ALL_CAPS_SNAKE_CASE</code>.  Type parameters in single capital letter.</p> </li> <li> <p>Static fields and methods must be accessed with class name.</p> </li> </ol>"},{"location":"style.html#statements-and-annotations","title":"Statements and Annotations","text":"<ol> <li> <p>Switch statement always include a <code>default</code> case.</p> </li> <li> <p>One annotation per line.</p> </li> <li> <p>Always use <code>@Override</code>.</p> <pre><code>@Override\npublic boolean equals(Object o) {\n    :\n}\n</code></pre> </li> <li> <p>Caught exceptions should not be ignored.</p> </li> <li> <p>Avoid <code>import</code> using wildcards <code>*</code>.  Always import the specific class you need.</p> <p>Good Example</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n</code></pre> <p>Bad Example</p> <pre><code>import java.util.*;\n</code></pre> </li> <li> <p><code>import</code> statement should be in alphabetical order.</p> <p>Good Example</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n</code></pre> <p>Bad Example</p> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n</code></pre> </li> </ol>"},{"location":"style.html#using-checkstyle","title":"Using <code>checkstyle</code>","text":"<p>To automatically check for style violation, we use a tool call <code>checkstyle</code>.</p> <p>To run, </p> <pre><code>java -jar ~cs2030s/bin/checkstyle.jar -c ~cs2030s/bin/cs2030_checks.xml *.java \n</code></pre> <p>The exercises and assessments may have different stylecheck configurations.  See the corresponding instructions in the exercises/assessment papers.</p> <p>Hint: put the command into a <code>bash</code> script so that you do not need to type such a long string all the time.</p>"},{"location":"labs/lab01.html","title":"Lab 01: Mini Problems","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to translate an imperative/procedural code into an object-oriented code.</li> <li>be able to write simple Java program and use JShell for testing and prototyping.</li> </ul> <p>Initializing</p> <p>To get the files, run the following command from your PE node. We recommend creating a new directory called <code>mini</code> to store all your lab mini problems.</p> <pre><code>lab1@pe111:~/mini$ cp -r ~cs2030s/mini/lab1/ .\n</code></pre>"},{"location":"labs/lab01.html#mini-problem-1","title":"Mini Problem 1","text":"<p>Alice wants to invest in several companies. She decides to create a list of her portfolio and track her progress. There are three kinds of companies she can invest in. The information needed for the companies differ depending on the kind of companies.</p> <ul> <li>MNC: Only the name and the valuation.</li> <li>Startup: Besides the name and the valuation, we also need to know the number of years for the valuation to double.  We call the number of years as X.</li> <li>SME: Besides the name and the valuation, we also need to know the amount to increase each year.</li> </ul> <p>Depending on the kind of company, the valuation may increase or decrease as follows.</p> <ul> <li>MNC: The valuation will always be the same.</li> <li>Startup: The valuation will double after every X number of years where X is the number stored as above.</li> <li>SME: The valuation will always increase by a fixed amount each year.</li> </ul> <p>Alice wants to keep track of the valuation of the companies in her portfolio for a given number of years. At the end, she wants to print the latest valuations.</p> <ul> <li>MNC: The format will be <code>[name]: $valuation</code>.</li> <li>Startup: <code>&lt;name&gt;: $valuation</code></li> <li>SME: The format will be <code>(name): $valuation</code>.</li> </ul> Mini1.1.in<pre><code>3 5\n1 Goggle 1000\n3 Bong 50 5\n2 QuackQuackGo 20 3\n</code></pre> Mini1.1.out<pre><code>[Goggle]: $1000\n(Bong): $75\n&lt;QuackQuackGo&gt;: $40\n</code></pre>"},{"location":"labs/lab01.html#potential-changes","title":"Potential Changes","text":"<p>As designs are intricately related to potential changes, you should think about the following potential changes.</p> <ul> <li>We may want to add different kinds of companies.</li> <li>We may want to change the behavior of each kind of companies independently of one another.</li> </ul>"},{"location":"labs/lab01.html#running-and-testing","title":"Running and Testing","text":"<p>First, you need to enter the directory <code>mini1</code> using the following command.</p> <pre><code>alice@pe111:~/mini/lab1$ cd mini1\nalice@pe111:~/mini/lab1/mini1$\n</code></pre> <p>Then you need to compile it:</p> <pre><code>alice@pe111:~/mini/lab1/mini1$ javac Mini1.java\n</code></pre> <p>You can run the following command to test a input file individually.</p> <pre><code>alice@pe111:~/mini/lab1/mini1$ java Mini1 &lt; inputs/Mini1.1.in\n</code></pre> <p>Alternatively, you can also run the test script.</p> <pre><code>alice@pe111:~/mini/lab1/mini1$ ./test.sh Mini1\n</code></pre>"},{"location":"labs/lab01.html#mini-problem-2","title":"Mini Problem 2","text":"<p>Bob -- a startup founder -- wants to design a simple payroll system for his company. The main goal is simple: he wants to know how much money he needs to prepare to pay her employees each month. On top of that, he mentioned a few other requirements as listed below.</p> <ul> <li>Each employee should have a unique consecutive ID, starting from 0.</li> <li>There are three types of employees: managers, full-time, and interns.<ul> <li>Managers and full-time employees are paid monthly while interns are paid hourly.</li> <li>Full-time employees and interns can be paid overtime.  This is simply the overtime hours * overtime rate.</li> </ul> </li> </ul> <p>Since not all information are useful, the constructor need not receive all information. But you are guaranteed that there will be no other kinds of employees besides those listed above.</p> <p>Initially Alice was tasked to handle this project. However, since her timeline is very tight, he rushed this project and the resulting code does not adhere to basic OOP principles. Alice asked for your help to refactor her code and make it more readable and extendable. Help Alice improve the quality of the code of this payroll system!</p>"},{"location":"labs/lab01.html#potential-changes_1","title":"Potential Changes","text":"<p>As designs are intricately related to potential changes, you should think about the following potential changes.</p> <ul> <li>We may want to add different kinds of employees.</li> <li>We may want to change the behavior of each kind of employees independently of one another.</li> </ul>"},{"location":"labs/lab01.html#running-and-testing_1","title":"Running and Testing","text":"<p>First, you need to enter the directory <code>mini2</code> using the following command.</p> <pre><code>alice@pe111:~/mini/lab1$ cd mini2\nalice@pe111:~/mini/lab1/mini2$\n</code></pre> <p>You will find <code>Employee.java</code> and <code>Payroll.java</code> but there is no <code>main</code> method in any of these files. We will be using JShell to run and test our program. To load the files using JShell, we can either (i) pass the Java file as an argument to JShell or (ii) open the files interactively inside JShell using <code>/open</code>.</p> Option (i)<pre><code>alice@pe111:~/mini/lab1/mini2$ jshell Employee.java Payroll.java\n|  Welcome to JShell -- Version 21.0.4\n|  For an introduction type: /help intro\njshell&gt;\n</code></pre> Option (ii)<pre><code>alice@pe111:~/mini/lab1/mini2$ jshell \n|  Welcome to JShell -- Version 21.0.4\n|  For an introduction type: /help intro\njshell&gt; /open Employee.java\njshell&gt; /open Payroll.java\n</code></pre> <p>If you made any changes to your code, you can also reload them using the <code>/open</code> command (i.e., option (ii)). This will update the class definition to the latest definition in your JShell session.</p> <p>To test your program, you may create objects and invoke their methods. The following is a sample run in a script called <code>Sample.jsh</code>.</p> Sample.jsh<pre><code>/open Employee.java\n/open Payroll.java\n\nEmployee manager = new Employee(1, 10000);\nEmployee fulltime = new Employee(2, 5000, 5, 100);\nEmployee intern = new Employee(3, 40, 50, 160, 25);\nPayroll pr = new Payroll();\n\npr.register(manager);\npr.register(fulltime);\npr.register(intern);\n\n// pr\n// pr.getTotalSalary()\n</code></pre> <p>You can load this script using the following command:</p> <pre><code>alice@pe111:~/mini/lab1/mini2$ jshell Employee.java Payroll.java Sample.jsh\n|  Welcome to JShell -- Version 17.0.8.1\n|  For an introduction type: /help intro\n\njshell&gt; pr\npr ==&gt; Manager0 FullTime1 Intern2\n\njshell&gt; pr.getTotalSalary()\n$14 ==&gt; 21500\n</code></pre>"},{"location":"labs/lab02.html","title":"Lab 02: Mini Problems","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to extend existing OOP code to meet changing requirements.</li> </ul> <p>Initializing</p> <p>To get the files, run the following command from your PE node. We recommend creating a new directory called <code>mini</code> to store all your lab mini problems.</p> <pre><code>lab2@pe111:~/mini$ cp -r ~cs2030s/mini/lab2/ .\n</code></pre> <p>The files will only be available on Wednesday, 4 September 2024.</p> <p>Lab 01 Extension</p> <p>This problem is an extension to mini problems of Lab 01.  The solution to the mini problems of Lab 1 can be found in the accompanying directory.</p> <p>In Ex 1, you will need to copy your solution instead of having the accompanying solution.</p>"},{"location":"labs/lab02.html#mini-problem-1","title":"Mini Problem 1","text":"<p>Class Diagram</p> <p></p> <p>Note the file <code>Mini1.java</code> was also modified.  The modification is as follows.</p> <p></p> <p>In particular, note that all fields are <code>private</code>, including class fields.  All of them are used only inside <code>Mini1</code> class and there is no need to make them <code>public</code>.</p>"},{"location":"labs/lab02.html#task-1-printing","title":"Task 1: Printing","text":"<p>Previously, the way Alice prints the companies are not very informative to other people.  Obviously, Alice knows how to read this, but this requires a kind of convention to know the following.</p> <ul> <li>MNC: The format will be <code>[name]: $valuation</code>.</li> <li>Startup: <code>&lt;name&gt;: $valuation</code></li> <li>SME: The format will be <code>(name): $valuation</code>.</li> </ul> <p>For example, given the output below,</p> Mini1.1.out<pre><code>[Goggle]: $1000\n(Bong): $75\n&lt;QuackQuackGo&gt;: $40\n</code></pre> <p>we know that <code>Goggle</code> is an MNC, <code>Bong</code> is an SME, and <code>QuackQuackGo</code> is a startup.  Unfortunately, other people may not know that.  So, Alice wants to change the way the company is being printed to make this easier to read.  The changes is summarized as follows.</p> Company Before After MNC <code>[name]: $valuation</code> <code>name [MNC]: $valuation</code> MNC <code>&lt;name&gt;: $valuation</code> <code>name [SUP]: $valuation</code> SME <code>(name): $valuation</code> <code>name [SME]: $valuation</code> <p>Using only this changes, you should see the following sample run.</p> Mini2.1.in<pre><code>3 5\n1 Goggle 1000\n3 Bong 50 5\n2 QuackQuackGo 20 3\n</code></pre> Mini2.1.out<pre><code>Goggle [MNC]: $1000\nBong [SME]: $75\nQuackQuackGo [SUP]: $40\n</code></pre>"},{"location":"labs/lab02.html#task-2-penny-stocks","title":"Task 2: Penny Stocks","text":"<p>There is a new kind of company that is representing a very risky company that is often called penny stock companies because their stocks are often priced below $1.  The valuation of this company may fluctuate before stabilizing.  The computation is as follows.</p> <ul> <li>If the valuation is even (i.e., divisible by 2), then the next valuation after one year is halved.</li> <li>If the valuation is odd (i.e., not divisible by 2), then the next valuation is three times the old valuation plus $1.</li> </ul> <p>You will need to change two things.</p> <ol> <li>Change <code>Mini2.java</code> to read data about the new company.  We will use the number <code>4</code> to indicate penny stock company.  The only information needed are the company name and valuation similar to MNC.</li> <li> <p>Add the company with the given way of computing valuation.  The company will be printed in the following format:</p> <p><code>name [$$$] $valuation</code></p> </li> </ol> <p>You can check with the following sample run.</p> Mini2.3.in<pre><code>4 5\n1 Goggle 1000\n3 Bong 50 5\n2 QuackQuackGo 20 3\n4 AlfaVisa 3\n</code></pre> Mini2.3.out<pre><code>Goggle [MNC]: $1000\nBong [SME]: $75\nQuackQuackGo [SUP]: $40\nAlfaVisa [$$$]: $4\n</code></pre> <p>The valuation of AlfaVisa is computed as follows: 3 \\(\\rightarrow\\) 10 \\(\\rightarrow\\) 5 \\(\\rightarrow\\) 16 \\(\\rightarrow\\) 8 \\(\\rightarrow\\) 4.</p>"},{"location":"labs/lab02.html#mini-problem-2","title":"Mini Problem 2","text":"<p>Class Diagram</p> <p></p>"},{"location":"labs/lab02.html#task-1-more-interns","title":"Task 1: More Interns","text":"<p>As Bob's company is doing well, he needs to expand the company.  For now, he intends to hire more interns.  Unfortunately, other companies also need to do the same.  Bob needs to entice interns by doubling the overtime rate.</p> <p>Make the necessary changes on the program to accomplish this.</p> Sample Run<pre><code>/open Payroll.java\n/open Employee.java\n/open Intern.java\n\nPayroll payroll = new Payroll();\nEmployee intern = new Intern(40, 50, 160, 25);\n\npayroll.register(intern);\npayroll.getTotalSalary(); // previously 6000, now 8000\n</code></pre>"},{"location":"labs/lab02.html#task-2-the-chiefs","title":"Task 2: The Chiefs","text":"<p>With the success of Alice's payroll system, you want to promote Alice to the role of the chief.  In particular, she will become the Chief Technology Officer (CTO).  There may be other chiefs like CEO, COO, CIO, etc.</p> <p>So what is the salary of a chief?  It is a fixed salary actually.  So why not just manager?  The difference is that chief will also receive a bonus each time <code>getMonthlySalary</code> is invoked.  However, this bonus is only applied after the salary is given.  In other words, it will be for next month.</p> Sample Run<pre><code>/open Payroll.java\n/open Employee.java\n/open Chief.java\n\nPayroll payroll = new Payroll();\nEmployee chief = new Chief(100000, 5000);\n\npayroll.register(chief);\npayroll.getTotalSalary(); // 100000\npayroll.getTotalSalary(); // 105000\npayroll.getTotalSalary(); // 110000\n</code></pre>"},{"location":"labs/lab03.html","title":"Lab 03: Mini Problems","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to create generic data structure.</li> <li>be able to use generic data structure.</li> </ul> <p>Initializing</p> <p>To get the files, run the following command from your PE node. We recommend creating a new directory called <code>mini</code> to store all your lab mini problems.</p> <pre><code>lab3@pe111:~/mini$ cp -r ~cs2030s/mini/lab3/ .\n</code></pre> <p>The files will only be available on Wednesday, 11 September 2024.</p> <p>Lab 02 Extension</p> <p>This problem is an extension to mini problems of Lab 02.  The solution to the mini problems of Lab 2 can be found in the accompanying directory.</p> <p>In Ex 2, you will need to copy your solution instead of having the accompanying solution.</p>"},{"location":"labs/lab03.html#mini-problem-1","title":"Mini Problem 1","text":"<p>Class Diagram</p> <p></p> <p>Note: We add a generic interface called <code>Filterable&lt;T&gt;</code>.  This interface has a single abstract method <code>boolean isOK(T)</code>.  This works as a predicate that we will use in our <code>Stack</code>.</p>"},{"location":"labs/lab03.html#task-1-creating-generic-stack","title":"Task 1: Creating Generic Stack","text":"<p>Currently, we have been using array of companies (i.e., <code>Company[]</code>) to store the list of companies in our program.  Now that we have learnt about generics, let's try to create our own generic data structure.  For this problem, we are going to implement a generic stack.</p> <p>A stack is a last in, first out (LIFO) data structure.  In other words, the last element you put in will be the first one taken out.  Similar to how if we look at a stack of paper, the top-most paper is the first element taken out.  Additionally, we can only place a new paper on the top-most.</p> <p>Update <code>Stack</code> in the file <code>Stack.java</code> to be generic.  Study the implementation to satisfy the requirement below.</p> <ul> <li><code>Stack</code> is a generic stack with one type parameter <code>T</code>.</li> <li><code>Stack</code> takes in only a subtype of <code>Filterable</code> as its type argument.</li> <li><code>Stack</code> has a constructor that takes in a single integer corresponding to the maximum size of the stack.</li> <li><code>Stack</code> supports the following methods:<ul> <li><code>void push(T elem)</code>: Inserts the element <code>elem</code> of type <code>T</code> to the top of the stack if the element is OK to be inserted.  An element is OK to be inserted if given the top element of the stack <code>top</code>, <code>elem.isOK(top)</code> returns <code>true</code>.  If there is no top element, the method simply inserts <code>elem</code> to the stack.  The method does nothing if the stack is full.</li> <li><code>T pop()</code>: Removes and returns the top element of the stack.  The method returns <code>null</code> if the stack is empty.</li> <li><code>boolean isEmpty()</code>: Returns <code>true</code> if the stack is empty.  Otherwise, it returns <code>false</code>.</li> <li><code>boolean isFull()</code>: Returns <code>true</code> if the stack is full.  Otherwise, it returns <code>false</code>.</li> <li><code>String toString()</code>: Returns the string representation of the stack with each element enclosed in <code>{ .. } &lt;-- Top</code>.</li> </ul> </li> </ul> <p>Study the following sample run of a <code>Stack</code> for more information on how we use the class.</p> Sample Run<pre><code>jshell&gt; class A implements Filterable&lt;A&gt; {\n   ...&gt;   private int val;\n   ...&gt;\n   ...&gt;   public A(int val) {\n   ...&gt;     this.val = val;\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public boolean isOK(A other) {\n   ...&gt;     return this.val &gt;= other.val;\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public String toString() {\n   ...&gt;     return \"A{\" + this.val + \"}\";\n   ...&gt;   }\n   ...&gt; }\n|  created class A\n\njshell&gt; class B1 extends A {\n   ...&gt;   public B1(int val) {\n   ...&gt;     super(val);\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public String toString() {\n   ...&gt;     return \"B1{\" + super.toString() + \"}\";\n   ...&gt;   }\n   ...&gt; }\n|  created class B1\n\njshell&gt; class B2 extends A {\n   ...&gt;   public B2(int val) {\n   ...&gt;     super(val);\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public String toString() {\n   ...&gt;     return \"B2{\" + super.toString() + \"}\";\n   ...&gt;   }\n   ...&gt; }\n|  created class B2\n\njshell&gt; Stack&lt;A&gt; s = new Stack&lt;A&gt;(2);\ns ==&gt; { } &lt;-- Top\njshell&gt; s.isEmpty();\n$.. ==&gt; true\njshell&gt; s.isFull();\n$.. ==&gt; false\njshell&gt; s.push(new A(3));\njshell&gt; s\ns ==&gt; { A{3} } &lt;-- Top\njshell&gt; s.push(new B1(2)); // not inserted\njshell&gt; s\ns ==&gt; { A{3} } &lt;-- Top\njshell&gt; s.push(new B2(4)); // inserted\njshell&gt; s\ns ==&gt; { A{3} B2{A{4}} } &lt;-- Top\njshell&gt; s.push(new B2(100)); // full\njshell&gt; s\ns ==&gt; { A{3} B2{A{4}} } &lt;-- Top\njshell&gt; s.pop();\n$.. ==&gt; B2{A{4}}\njshell&gt; s\ns ==&gt; { A{3} } &lt;-- Top\njshell&gt; s.push(new B1(100));\njshell&gt; s\ns ==&gt; { A{3} B1{A{100}} } &lt;-- Top\n</code></pre>"},{"location":"labs/lab03.html#task-2-use-generic-stack","title":"Task 2: Use Generic Stack","text":"<p>Modify the class <code>Mini3.java</code> to remove any usage of <code>Company[]</code> and replacing it with <code>Stack&lt;Company&gt;</code>.  We will read the company one by one and push it into the stack.  During this process, some company may be rejected due to the way <code>isOK(T)</code> is implemented and that is OK.</p> <p>More importantly, in the method <code>run()</code>, we will find that we need a temporary <code>Stack</code> to process all the companies before copying them back to the original <code>Stack</code>.  Assuming that the original <code>Stack</code> is a field named <code>companies</code> and the number of companies is in the field named <code>numCompanies</code>, the code structure will look like the following.</p> <pre><code>Stack&lt;Company&gt; tmp = new Stack&lt;Company&gt;(this.numCompanies);\nwhile (!this.companies.isEmpty()) {\n  Company company = this.companies.pop();\n  // process ...\n  tmp.push(company);\n}\n// Copy back\nwhile (!tmp.isEmpty()) {\n  this.companies.push(tmp.pop());\n}\n</code></pre> <p>As a good practice, you should still copy back even after printing.  Just in case we want to do more operations, we should not end with no companies.</p> <p>Note that this process may further filter out more companies.  That is fine.  In the end, there may be only one company in the output.</p> Mini3.3.in<pre><code>4 5\n1 Goggle 1000\n3 Bong 50 5\n2 QuackQuackGo 20 3\n4 AlfaVisa 3\n</code></pre> Mini3.3.out<pre><code>QuackQuackGo [SUP]: $40\n</code></pre>"},{"location":"labs/lab03.html#testing","title":"Testing","text":"<p>You can test your implementation of <code>Stack</code> independently by executing <code>TestStack.java</code>.</p> <pre><code>javac TestStack.java\njava TestStack\n</code></pre> <p>If everything is correct, you should see the following.</p> TestStack<pre><code>Stack&lt;A&gt; s = new Stack&lt;A&gt;(2)\ns.toString().. ok\ns.isEmpty().. ok\ns.isFull().. ok\ns.push(new A(3))\ns.toString().. ok\ns.push(new B1(2))\ns.toString().. ok\ns.push(new B2(4))\ns.toString().. ok\ns.push(new B2(100))\ns.toString().. ok\ns.pop().. ok\ns.toString().. ok\ns.push(new B1(100))\ns.toString().. ok\n</code></pre>"},{"location":"labs/lab03.html#mini-problem-2","title":"Mini Problem 2","text":"<p>Class Diagram</p> <p></p> <p>Note: We add a generic interface called <code>SalaryMan&lt;T&gt;</code>.  This interface has a single abstract method <code>T higher(T other)</code>.  The method returns either <code>this</code> or <code>other</code> depending on the instance with the higher salary</p>"},{"location":"labs/lab03.html#task-1-creating-generic-queue","title":"Task 1: Creating Generic Queue","text":"<p>Bob prefers the use of <code>Queue</code> instead of a <code>Stack</code> as it is fairer because it is a first in, first out (FIFO) data structure.  In other words, the first element you put in will be the first one taken out.  Similar to how from a queue at the canteen, you enter from the back of the queue. Then, when you reached the front, you may exit the queue.</p> <p>Update <code>Queue</code> in the file <code>Queue.java</code> to be generic.  Study the implementation to satisfy the requirement below.</p> <ul> <li><code>Queue</code> is a generic queue with one type parameter <code>T</code>.</li> <li><code>Queue</code> takes in only a subtype of <code>SalaryMan</code> as its type argument.</li> <li><code>Queue</code> has a constructor that takes in a single integer corresponding to the maximum size of the queue.</li> <li><code>Queue</code> supports the following methods:<ul> <li><code>void enqueue(T elem)</code>: Inserts the element <code>elem</code> of type <code>T</code> to back of the queue.  The method does nothing if the stack is full.</li> <li><code>boolean isEmpty()</code>: Returns <code>true</code> if the stack is empty.  Otherwise, it returns <code>false</code>.</li> <li><code>boolean isFull()</code>: Returns <code>true</code> if the stack is full.  Otherwise, it returns <code>false</code>.</li> <li><code>String toString()</code>: Returns the string representation of the stack with each element enclosed in <code>{ .. } &lt;-- Back</code>.</li> </ul> </li> </ul>"},{"location":"labs/lab03.html#task-2-extending-a-queue","title":"Task 2: Extending a Queue","text":"<p>Now implement the method <code>T findBoss()</code> that returns the highest element.  The element <code>elem</code> is the highest if for every other element <code>other</code>, <code>elem.higher(other)</code> or <code>other.higher(elem)</code> returns <code>elem</code>.</p> <p>Study the following sample run of a <code>Queue</code> for more information on how we use the class.</p> Sample Run<pre><code>jshell&gt; class A implements SalaryMan&lt;A&gt; {\n   ...&gt;   private int val;\n   ...&gt;\n   ...&gt;   public A(int val) {\n   ...&gt;     this.val = val;\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public A higher(A that) {\n   ...&gt;     if (this.val &lt;= that.val) {\n   ...&gt;       return this;\n   ...&gt;     }\n   ...&gt;     return that;\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public String toString() {\n   ...&gt;     return \"A{\" + this.val + \"}\";\n   ...&gt;   }\n   ...&gt; }\n|  created class A\n\njshell&gt; class B1 extends A {\n   ...&gt;   public B1(int val) {\n   ...&gt;     super(val);\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public String toString() {\n   ...&gt;     return \"B1{\" + super.toString() + \"}\";\n   ...&gt;   }\n   ...&gt; }\n|  created class B1\n\njshell&gt; class B2 extends A {\n   ...&gt;   public B2(int val) {\n   ...&gt;     super(val);\n   ...&gt;   }\n   ...&gt;\n   ...&gt;   @Override\n   ...&gt;   public String toString() {\n   ...&gt;     return \"B2{\" + super.toString() + \"}\";\n   ...&gt;   }\n   ...&gt; }\n|  created class B2\n\njshell&gt; Queue&lt;A&gt; q = new Queue&lt;A&gt;(2);\nq ==&gt; { } &lt;-- Back\njshell&gt; q.enqueue(new B1(2));\njshell&gt; q.enqueue(new B2(10));\njshell&gt; q\nq ==&gt; { B1{A{2}} B2{A{10}} } &lt;-- Back\njshell&gt; q.findBoss();\n$.. ==&gt; B1{A{2}}\njshell&gt; q.enqueue(new A(1)); // full\njshell&gt; q\nq ==&gt; { B1{A{2}} B2{A{10}} } &lt;-- Back\n</code></pre>"},{"location":"labs/lab03.html#testing_1","title":"Testing","text":"<p>You can test your implementation of <code>Queue</code> independently by executing <code>TestQueue.java</code>.</p> <pre><code>javac TestQueue.java\njava TestQueue\n</code></pre> <p>If everything is correct, you should see the following.</p> TestQueue<pre><code>Queue&lt;A&gt; s = new Stack&lt;A&gt;(2)\nq.toString().. ok\nq.isEmpty().. ok\nq.isFull().. ok\nq.enqueue(new B1(2))\nq.enqueue(new B2(10))\nq.toString().. ok\nq.findBoss().. ok\nq.enqueue(new A(1))\nq.toString().. ok\n</code></pre>"},{"location":"labs/lab04.html","title":"Lab 04: Mini Problems","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to create immutable class.</li> <li>be able to create factory method.</li> <li>be able to work with generics.</li> </ul> <p>Initializing</p> <p>To get the files, run the following command from your PE node. We recommend creating a new directory called <code>mini</code> to store all your lab mini problems.</p> <pre><code>lab4@pe111:~/mini$ cp -r ~cs2030s/mini/lab4/ .\n</code></pre> <p>The files will only be available on Wednesday, 18 September 2024.</p> <p>New Lab Problem</p> <p>This problem is a new problem and no longer an extension of Lab 03.</p>"},{"location":"labs/lab04.html#mini-problem-1","title":"Mini Problem 1","text":"<p>In this problem, we are going to create an immutable class.  An immutable object refers to an object whose state cannot be modified after it is created (Wikipedia).  You will learn more about immutability during lecture, but to motivate you for the time being, immutability makes it easy to reason about our code.  Less changes == less bugs!</p> Point.java<pre><code>public class Point {\n  private int x;\n  private int y;\n\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public void moveTo(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  @Override\n  public String toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\n</code></pre>"},{"location":"labs/lab04.html#task-1-immutable-point","title":"Task 1: Immutable Point","text":"<p>Recap the <code>Point</code> class that we have above. It is possible to mutate the variables by invoking the <code>moveTo</code> method.</p> Mutable Point<pre><code>jshell&gt; Point p = new Point(1, 1);\np ==&gt; (1,1)\njshell&gt; p.moveTo(2,2);\njshell&gt; p\np ==&gt; (2,2)\n</code></pre> <p>Make the class <code>Point</code> immutable by making the following changes:</p> <ul> <li>Modify <code>void moveTo(int, int)</code> to return a new <code>Point</code> instead of mutating the current point.</li> <li>If you are moving the point to the same coordinate as the current coordinate, return the current instance.</li> </ul> <p>Your code should pass the following check.</p> Immutable Point<pre><code>jshell&gt; Point p = new Point(1, 1);\np ==&gt; (1,1)\njshell&gt; Point p2 = new Point(1, 1);\np2 ==&gt; (1,1)\njshell&gt; p == p2\n$.. ==&gt; false\njshell&gt; p.moveTo(2, 2)\n$.. ==&gt; (2,2)\njshell&gt; Point p3 = p2.moveTo(1, 1)\np3 ==&gt; (1,1)\njshell&gt; p3 == p2\n$.. ==&gt; true\njshell&gt; p3 == p\n$.. ==&gt; false\n</code></pre>"},{"location":"labs/lab04.html#task-2-factory-method","title":"Task 2: Factory Method","text":"<p>Now that we have an immutable point, we may find it weird that <code>p</code> and <code>p2</code> above are not identical (i.e., <code>p == p2</code> returns <code>false</code>) even when they are the same coordinates. On the other hand, <code>p2</code> and <code>p3</code> are identical (i.e., <code>p2 == p3</code> returns <code>true</code>). We want to do something similar but only for a special point called origin at (0, 0).</p> <p>We will do this by implementing a factory method. A factory method is a static method that can be invoked to create an instance instead of exposing the constructor directly. This has several advantages that we will explore here.</p> <p>Make the following changes to the <code>Point</code> class to implement factory method with several advantages.</p> <ul> <li> <p>Make <code>Point</code> class behave in the following way:</p> Factory v1<pre><code>jshell&gt; new Point(1, 1)\n|  Error:\n|  Point(int,int) has private access in Point\n|  new Point(1, 1)\n|  ^-------------^\njshell&gt; Point p = Point.of(1, 1)\np ==&gt; (1,1)\njshell&gt; p.moveTo(2, 2)\n$.. ==&gt; (2,2)\n</code></pre> </li> <li> <p>Modify <code>Point</code> class such that it returns the same instance if we are creating the origin point (i.e., point at (0, 0)).  This is only possible because of the use of factory method.  Ensure that you pass the following test.</p> <pre><code>jshell&gt; Point p1 = Point.of(0, 0)\np1 ==&gt; (0,0)\njshell&gt; Point p2 = Point.of(0, 0)\np2 ==&gt; (0,0)\njshell&gt; p1 == p2\n$.. ==&gt; true\njshell&gt; p1 = Point.of(1, 1)\np1 ==&gt; (1,1)\njshell&gt; p2 = Point.of(1, 1)\np2 ==&gt; (1,1)\njshell&gt; p1 == p2\n$.. ==&gt; false\n</code></pre> </li> <li> <p>Finally, we want our point to have only non-negative coordinates.  If any of the inputs are negative, return <code>null</code>.  Again, this is only possible with factory methods.</p> <pre><code>jshell&gt; Point p = Point.of(-1, 0)\np ==&gt; null\njshell&gt; Point p = Point.of(0, -2)\np ==&gt; null\njshell&gt; Point p = Point.of(3, -2)\np ==&gt; null\njshell&gt; Point p = Point.of(1, 3)\np ==&gt; (1,3)\n</code></pre> </li> </ul>"},{"location":"labs/lab04.html#mini-problem-2","title":"Mini Problem 2","text":"<p>In this problem, we are going to implement generic class.  In particular, we will expand on the implementation of generic pair.</p> Pair.java<pre><code>public class Pair&lt;S, T&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n\n  @Override\n  public String toString() {\n    return \"(\" + this.first + \",\" + this.second + \")\";\n  }\n}\n</code></pre>"},{"location":"labs/lab04.html#task-1-comparing-pair","title":"Task 1: Comparing Pair","text":"<p>We say that two pairs <code>p1</code> and <code>p2</code> are equal if both of the followings are true:</p> <ul> <li><code>p1.first</code> is equal to <code>p2.first</code> according to their <code>equals</code> method.</li> <li><code>p1.second</code> is equal to <code>p2.second</code> according to their <code>equals</code> method.</li> </ul> <p>However, you will notice that in some cases, you may get run-time errors.  Try to figure out why and make sure that you pass the following test case by overriding the <code>boolean equals(Object)</code> method.</p> <p><pre><code>jshell&gt; Pair&lt;String, Integer&gt; p1 = new Pair&lt;&gt;(\"CS2030S\", 100)\np1 ==&gt; (CS2030S,100)\njshell&gt; Pair&lt;String, Number&gt; p2 = new Pair&lt;&gt;(\"CS2030S\", 100)\np2 ==&gt; (CS2030S,100)\njshell&gt; p1.equals(p2)\n$.. ==&gt; true\njshell&gt; p1.equals(new Pair&lt;&gt;(\"CS2030S\", 100))\n$.. ==&gt; true\njshell&gt; p1.equals(new Pair&lt;&gt;(\"CS2030S\", null))\n$.. ==&gt; false\njshell&gt; p1.equals(new Pair&lt;&gt;(null, null))\n$.. ==&gt; false\njshell&gt; p2 = new Pair&lt;&gt;(null, null)\np2 ==&gt; (null,null)\njshell&gt; p2.equals(new Pair&lt;&gt;(null, null))\n$.. ==&gt; false\n</code></pre> Also, you need to ensure that your code has no warnings when compiled with the following command</p> <pre><code>lab4@pe111:~/mini$ javac Pair.java -Xlint:unchecked -Xlint:rawtypes\n</code></pre>"},{"location":"labs/lab04.html#task-2-swapping-elements","title":"Task 2: Swapping Elements","text":"<p>Since a pair has two fields <code>first</code> and <code>second</code>, we may be able to swap with another pair. The swap is done in the following way when <code>p1.swap(p2)</code> is invoked:</p> <ul> <li>We assign <code>p2.first</code> into <code>p1.first</code>.</li> <li>We assign <code>p1.second</code> into <code>p2.second</code>.</li> </ul> <p>We need to make sure that the method is the most flexible with the minimum number of type parameter it can be. For that, we assume that we have the following three classes with the following subtyping relationship: <code>C</code> &lt;: <code>B</code> &lt;: <code>A</code>.</p> <pre><code>class A {}\nclass B extends A {}\nclass C extends B {}\n</code></pre> <p>We need to at least pass the following test.</p> <pre><code>jshell&gt; Pair&lt;B, B&gt; p1 = new Pair&lt;&gt;(new B(), new B())\np1 ==&gt; (B@6767c1fc,B@29ee9faa)\njshell&gt; Pair&lt;C, A&gt; p2 = new Pair&lt;&gt;(new C(), new A())\np2 ==&gt; (C@cc285f4,A@55f3ddb1)\njshell&gt; p1.swap(p2)      // no error\njshell&gt; p2.swap(p1)      // error\n|  Error:\njshell&gt; p2.swap(p2)      // no error\njshell&gt; p1.swap(p1)      // no error\njshell&gt; p1.&lt;B,B&gt;swap(p2) // no error\njshell&gt; p1.&lt;B&gt;swap(p2)   // no error\n</code></pre>"},{"location":"labs/lab05.html","title":"Lab 05: Mini Problems","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to organize program into packages</li> <li>be able to create and use nested classes</li> </ul> <p>Initializing</p> <p>To get the files, run the following command from your PE node. We recommend creating a new directory called <code>mini</code> to store all your lab mini problems.</p> <pre><code>cp -r ~cs2030s/mini/lab5/ .\n</code></pre> <p>The files will only be available on Wednesday, 9 October 2024.</p> <p>Lab 04 Extension</p> <p>Parts of this problem is an extension to mini problems of Lab 04.  The solution to the mini problems of Lab 4 can be found in the accompanying directory.</p> <p>In Ex 5, you will need to copy your solution instead of having the accompanying solution.</p>"},{"location":"labs/lab05.html#mini-problem-1","title":"Mini Problem 1","text":"<p>We have created an immutable point in Lab 04, the partial code is shown below. While it may not fully solve Lab 04, it is sufficient for our purpose.</p> Point.java<pre><code>public final class Point {\n  private final int x;\n  private final int y;\n  private static Point ORIGIN = new Point(0, 0);\n\n  private Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public static Point of(int x, int y) {\n    if (x == 0 &amp;&amp; y == 0) {\n      return Point.ORIGIN;\n    }\n    return new Point(x, y);\n  }\n\n  public Point moveTo(int x, int y) {\n    return new Point(x, y);\n  }\n\n  @Override\n  public String toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj instanceof Point) {\n      Point pt = (Point) obj;\n      return this.x == pt.x &amp;&amp; this.y == pt.y;\n    }\n    return false;\n  }\n}\n</code></pre>"},{"location":"labs/lab05.html#task-1-packaging","title":"Task 1: Packaging","text":"<p>We will now create a package called <code>shapes</code>. To do this, follow the steps below. Please revise the bash commands to do this.</p> <ol> <li>Create a directory called <code>shapes</code>.</li> <li>Copy <code>Point.java</code> into <code>shapes</code>.</li> <li>Add the line <code>package shapes;</code> at the top of <code>Point.java</code>.<ul> <li>All classes in the package <code>shapes</code> must begin with <code>package shapes;</code>.</li> </ul> </li> <li>Add the line <code>import shapes.Point;</code> at the top of <code>Task1.java</code>.<ul> <li>Note that you should NOT use <code>import shapes.*;</code>.  Instead, you should import the needed classes individually to avoid namespace polution.</li> </ul> </li> </ol> <p>At the end, you should see something like the following directory structure. The base directory is called <code>mini1</code>. All directory ends with <code>/</code> as part of their names.</p> <pre><code>mini1/\n\u251c\u2500\u2500 shapes/\n\u2502   \u2514\u2500\u2500 Point.java\n\u251c\u2500\u2500 Task1.java\n\u2514\u2500\u2500 Task2.java\n</code></pre> <p>Now we can check if this works. We will test with <code>Task1.java</code> only.</p> <ol> <li>Compile <code>Task1.java</code> with <code>javac Task1.java</code>.<ul> <li>Notice that <code>Point.java</code> inside the directory <code>shapes</code> will also be compiled.</li> </ul> </li> <li>Run <code>Task1.java</code> with <code>java Task1</code>.<ul> <li>You should get all ok.</li> </ul> </li> </ol>"},{"location":"labs/lab05.html#task-2-adding-shapes","title":"Task 2: Adding Shapes","text":"<p>Given points, we can now create shapes. We have created <code>Circle</code> before, so let us recreate it inside the <code>shapes</code> package. Remember that all classes in the package <code>shapes</code> must begin with <code>package shapes;</code>.</p> <p>Before we specify the requirement for <code>Circle</code>, we first remove the keyword <code>public</code> from the constructor of class <code>Point</code>. This will prevent us from creating a point directly from outside of the package. That is because beside the <code>public</code> and <code>private</code> modifier, we have the following modifiers. Without any modifier, the class <code>Point</code> can only be used by code in the same class or in the same package.</p> Modifier Class Package Subclass Others <code>public</code> Y Y Y Y <code>protected</code> Y Y Y N no modifier Y Y N N <code>private</code> Y N N N <p>Circle.java \u00a0\u00a0\u00a0\u00a0 Now we can create <code>Circle</code> inside the package <code>shapes</code>. Design your class in the following way.</p> <ul> <li>It is a <code>public</code> class with two <code>private</code> fields.  The first field is a <code>Point</code> indicating the center point of the circle.  The second field is the radius of the circle as <code>int</code>.</li> <li>It has a <code>public</code> constructor that accepts two parameters.  The first parameter is the center point and the second parameter is the radius of the circle.</li> <li>The <code>public</code> method <code>toString</code> prints the circle as <code>Circle @ &lt;center&gt; with radius &lt;radius&gt;</code>.  <code>&lt;center&gt;</code> is the string representation of its center point and <code>&lt;radius&gt;</code> is the string representation of its radius.</li> <li>The <code>protected</code> method <code>getRadius</code> returns the radius of the circle.</li> <li>Add the method <code>public void moveTo(int x, int y)</code> in the class <code>Circle</code> to move the center point of the circle.  However, instead of invoking <code>Point::moveTo</code>, try creating <code>new Point(x, y)</code> directly in the <code>Circle</code> class.</li> </ul> <p>You can check your implementation with <code>Task2.java</code>.</p> <p>MyCircle.java \u00a0\u00a0\u00a0\u00a0 Now we can create <code>ColoredCircle</code> outside the package <code>shapes</code>. Design your class in the following way.</p> <ul> <li>It is a <code>public</code> class extending <code>Circle</code> with no fields.</li> <li>It has a <code>public</code> constructor that accepts one parameters: the radius of the circle.  The center point is always at (0, 0).</li> <li>It has a single <code>public</code> method <code>isSmallerThan(int radius)</code> to compare the radius with the input parameter <code>radius</code>.  The method returns true if the radius is strictly smaller than <code>radius</code>.</li> </ul> <p>You can check your implementation with <code>Task3.java</code>.</p>"},{"location":"labs/lab05.html#mini-problem-2","title":"Mini Problem 2","text":"<p>We have created a generic pair in Lab 04, the partial code is shown below. While it may not fully solve Lab 04, it is sufficient for our purpose. Although we are not extending pair, you may use it as an inspiration.</p> Pair.java<pre><code>public class Pair&lt;S, T&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true; // optional, for efficiency\n    }\n    if (obj instanceof Pair&lt;?, ?&gt;) {\n      Pair&lt;?, ?&gt; pair = (Pair&lt;?, ?&gt;) obj;\n\n      if (this.first == null &amp;&amp; this.second == null) {\n        return pair.first == null &amp;&amp; pair.second == null;\n      }\n      if (this.first == null) {\n        return pair.first == null &amp;&amp; this.second.equals(pair.second);\n      }\n      if (this.second == null) {\n        return this.first.equals(pair.first); &amp;&amp; pair.second == null;\n      }\n\n      return this.first.equals(pair.first)\n          &amp;&amp; this.second.equals(pair.second);\n    }\n    return false;\n  }\n\n  @Override\n  public String toString() {\n    return \"(\" + this.first + \",\" + this.second + \")\";\n  }\n}\n</code></pre>"},{"location":"labs/lab05.html#task-1-abstract-boolean-condition","title":"Task 1: Abstract Boolean Condition","text":"<p>We will now create a new class that is an abstraction of an boolean condition. We call this class <code>Bool&lt;T&gt;</code>. Your current task is to implement the abstract class <code>Bool&lt;T&gt;</code> with the following specification.</p> <ul> <li>It is a generic abstract class with one type parameter <code>T</code>.</li> <li>It has a single <code>private</code> field of type <code>T</code>.</li> <li>It has a <code>private</code> constructor that accepts a value of type <code>T</code>.</li> <li>It has a single concrete method <code>T getVal()</code> that returns the field of type <code>T</code>.</li> <li>It has two <code>public</code> <code>abstract</code> methods.<ul> <li><code>Bool&lt;T&gt; doThen(T val)</code>.</li> <li><code>Bool&lt;T&gt; doElse(T val)</code>.</li> </ul> </li> </ul> <p>This class will have a factory method based on the second task below.</p>"},{"location":"labs/lab05.html#task-2-nested-class","title":"Task 2: Nested Class","text":"<p>We will now create two static nested classes.</p> <p>True \u00a0\u00a0\u00a0\u00a0 The class <code>True&lt;T&gt;</code> extends <code>Bool&lt;T&gt;</code>. It overrides the two abstract methods as follows.</p> <ul> <li><code>Bool&lt;T&gt; doThen(T val)</code>: returns a new instance of <code>True&lt;T&gt;</code> such that the <code>protected</code> field of type <code>T</code> inherited from <code>Bool&lt;T&gt;</code> is set to the given value <code>val</code>.</li> <li><code>Bool&lt;T&gt; doElse(T val)</code>: returns itself without change.</li> </ul> <p>False \u00a0\u00a0\u00a0\u00a0 The class <code>False&lt;T&gt;</code> extends <code>Bool&lt;T&gt;</code>. It overrides the two abstract methods as follows.</p> <ul> <li><code>Bool&lt;T&gt; doThen(T val)</code>: returns itself without change.</li> <li><code>Bool&lt;T&gt; doElse(T val)</code>: returns a new instance of <code>False&lt;T&gt;</code> such that the <code>protected</code> field of type <code>T</code> inherited from <code>Bool&lt;T&gt;</code> is set to the given value <code>val</code>.</li> </ul> <p>Factory Method \u00a0\u00a0\u00a0\u00a0 Implement the factory method <code>test(boolean cond)</code> that takes in a boolean condition and returns <code>Bool&lt;T&gt;</code> such that</p> <ul> <li>if <code>cond</code> is <code>true</code>, it returns a new <code>True&lt;T&gt;</code> with initial value of <code>null</code>.</li> <li>if <code>cond</code> is <code>false</code>, it returns a new <code>False&lt;T&gt;</code> with initial value of <code>null</code>.</li> </ul> <p>See the sample usage below.</p> <pre><code>jshell&gt; Bool.&lt;Integer&gt;test(true).doThen(1).doElse(2).getVal()\n$.. ==&gt; 1\njshell&gt; Bool.&lt;Integer&gt;test(false).doThen(1).doElse(2).getVal()\n$.. ==&gt; 2\n\njshell&gt; Bool.&lt;Integer&gt;test(true).getVal()\n$.. ==&gt; null\njshell&gt; Bool.&lt;Integer&gt;test(false).getVal()\n$.. ==&gt; null\n\njshell&gt; Bool.&lt;Integer&gt;test(true).doThen(1).doThen(2).getVal()\n$.. ==&gt; 2\njshell&gt; Bool.&lt;Integer&gt;test(false).doElse(2).doElse(1).getVal()\n$.. ==&gt; 1\n\njshell&gt; Bool.&lt;Integer&gt;test(true).doElse(1).doElse(2).getVal()\n$.. ==&gt; null\njshell&gt; Bool.&lt;Integer&gt;test(false).doThen(2).doThen(1).getVal()\n$.. ==&gt; null\n</code></pre> <p>Look Ma, no if-then-else statement!</p> <p>You can check your implementation with <code>Task1.java</code>.</p>"},{"location":"labs/lab06.html","title":"Lab 06: Mini Problems","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to use <code>Maybe&lt;T&gt;</code> class in their code.</li> <li>be able to write functional-style code.</li> </ul> <p>Initializing</p> <p>To get the files, run the following command from your PE node. We recommend creating a new directory called <code>mini</code> to store all your lab mini problems.</p> <pre><code>cp -r ~cs2030s/mini/lab6/ .\n</code></pre> <p>The files will only be available on Wednesday, 16 October 2024.</p> <p>Class Files</p> <p>We have given you a <code>.class</code> file from a badly written <code>Maybe&lt;T&gt;</code> as well as the functional interfaces used in the directory cs2030s/fp. These class files are compiled on the PE node, so we can only guarantee that they can work on the PE node. They may or may not work on other places especially on other operating systems.</p>"},{"location":"labs/lab06.html#maybe","title":"Maybe","text":"<p>Our <code>Maybe</code> class has the following methods available.  Methods that are not available cannot be used.  You should not modify <code>Maybe</code> class. You may use the method descriptor as an inspiration for future exercises to make your method more flexible. All the methods below are <code>public</code>. No other <code>public</code> methods are available.</p> Method Description <code>static &lt;T&gt; Maybe&lt;T&gt; of</code> <code>(T val)</code> Returns a new <code>Maybe&lt;T&gt;</code> depending on the value of <code>val</code>.<ul><li>If <code>val</code> is <code>null</code> returns the singleton <code>NONE</code> without any value inside</li><li>Otherwise returns a new <code>Maybe&lt;T&gt;</code> with the content <code>val</code>.</li></ul> <code>static &lt;T&gt; Maybe&lt;T&gt; some</code> <code>(T val)</code> Returns a new <code>Maybe&lt;T&gt;</code> with the content <code>val</code> regardless if <code>val</code> is <code>null</code> or not. <code>static &lt;T&gt; Maybe&lt;T&gt; none</code> <code>(T val)</code> Returns a the singleton <code>NONE</code> without any value inside. <code>&lt;U&gt; Maybe&lt;U&gt; map</code> <code>(Transformer&lt;? super T,</code> <code>? extends U&gt; func)</code> Transform <code>this.val</code> (if any) using <code>func</code> and return a new <code>Maybe&lt;U&gt;</code>.<ul><li>If there is no <code>this.val</code> returns the singleton <code>NONE</code> without any value inside.</li><li>Otherwise return a new instance of <code>Maybe&lt;U&gt;</code> with <code>this.val</code> transformed using <code>func</code>. <code>Maybe&lt;T&gt; filter</code> <code>(BooleanCondition&lt;? super T&gt; pred)</code> Transform <code>this.val</code> (if any) depending on the result of <code>pred</code>.<ul><li>If there is no <code>this.val</code> returns the singleton <code>NONE</code> without any value inside.</li><li>If <code>this.val == null</code> returns the singleton <code>NONE</code> without any value inside.</li><li>If <code>this.val</code> evaluates to <code>false</code> when passed into<code>pred</code> returns the singleton <code>NONE</code> without any value inside.</li><li>Otherwise the current instance.</li></ul> <code>&lt;U&gt; Maybe&lt;U&gt; flatMap</code> <code>(Transformer&lt;? super T,</code> <code>? extends Maybe&lt;? extends U&gt;&gt; func)</code> Transform <code>this.val</code> (if any) using <code>func</code> and return a new <code>Maybe&lt;U&gt;</code>.<ul><li>If there is no <code>this.val</code> returns the singleton <code>NONE</code> without any value inside.</li><li>Otherwise return a new instance of <code>Maybe&lt;U&gt;</code> with <code>this.val</code> transformed using <code>func</code> but without making a nested <code>Maybe</code>. <code>T orElse</code> <code>(Producer&lt;? extends T&gt; prod)</code> Returns <code>this.val</code> (if any).<ul><li>If there is no <code>this.val</code> produce a new value using <code>prod</code>.</li><li>Otherwise <code>this.val</code>. <code>void ifPresent</code> <code>(Consumer&lt;? super T&gt; cons)</code> Consumes <code>this.val</code> (if any).<ul><li>If there is no <code>this.val</code> do nothing.</li><li>Otherwise consume <code>this.val</code> using <code>cons</code>."},{"location":"labs/lab06.html#map","title":"Map","text":"Method Description <code>V get</code> <code>(Object key)</code> Returns the value to which the specified <code>key</code> is mapped, or <code>null</code> if this map contains no mapping for the key."},{"location":"labs/lab06.html#functional-style","title":"Functional-Style","text":"<p>As a sanity check, your answer should be ONLY a single statement without any blocks of code inside. Most of the time, this will be a <code>return</code> statement if you need to return some value. However, in some cases, you are to write a <code>void</code> method in which case, there should not be a <code>return</code>.</p> <p>Additionally, you may use lambda expressions with a single return expression (if necessary). You should not create new methods (not even constructors) or use blocks in your lambda expressions.</p> <p>A typical misconception is to think that as long as there is only one <code>return</code> statement, the code is functional-style. This is not correct if the code has other statements (e.g., assignments before the <code>return</code>).</p>"},{"location":"labs/lab06.html#mini-problem-1","title":"Mini Problem 1","text":""},{"location":"labs/lab06.html#maybet-i-can-get-good-grades","title":"<code>Maybe&lt;T&gt;</code> I Can Get Good Grades","text":"<p>Now that we have our <code>Maybe</code> class, let's try to use it to do something more meaningful.</p> <p>It is a common idiom (although not a good one) for a method to return a value if successful and return a <code>null</code> otherwise. It is up to the caller to check and make sure that the return value is not <code>null</code> before using it, to prevent receiving a run-time <code>NullPointerException</code>.</p> <p>One example of this is the <code>Map&lt;K,V&gt;</code> implemented in Java. The relevant methods is the <code>Map::get</code> that returns <code>null</code> if the key that you are looking for does not exist.</p> <p>We have given you a program <code>Lab6Mini1.java</code> that uses multiple layers of <code>Map</code> to store information about students, their modules, and their assessment grades. There is a method <code>getGrade</code> that, given this map, a student, a module, and an assessment, look up the corresponding grade. There are multiple checks if a returned value is <code>null</code> in this method.</p> <p>Our new <code>Maybe&lt;T&gt;</code> class provides a good abstraction for the returned value from <code>Map::get</code> since the value returned is either some value or none!</p> <p>Modify <code>getGrade</code> so that it uses <code>Maybe&lt;T&gt;</code> and is written in a functional-style. If your code works, the output should still be the same as before which is shown below.</p> <pre><code>A\nA-\nA+\nA\nC\nNo such entry\nNo such entry\nNo such entry\n</code></pre>"},{"location":"labs/lab06.html#mini-problem-2","title":"Mini Problem 2","text":""},{"location":"labs/lab06.html#maybet-i-can-earn-a-lot-of-money","title":"<code>Maybe&lt;T&gt;</code> I Can Earn a Lot of Money","text":"<p>CS2030S AY2022-23 Sem 2 PA2</p> <p>This mini problem is adapted from CS2030S AY2022-23 Semester 2 PA 2.</p> <p>You are given three classes: <code>Pair</code>, <code>Account</code>, and <code>Bank</code>. You should read the given source codes to understand the behavior of each class and their interaction with each other.</p> <p>Your task is simply to remove all conditional statements and all reference to <code>null</code> in the <code>transfer</code> method inside the <code>Bank</code> class (reproduced below):</p> <pre><code>class Bank {\n  // ... fields and other methods omitted ...\n  void transfer(int from, int to, double amount) {\n    Account fromAccount = findAccount(from);\n    Account toAccount = findAccount(to);\n    if (fromAccount != null &amp;&amp; toAccount != null &amp;&amp; fromAccount.getBalance() &gt;= amount &amp;&amp;\n        !fromAccount.isClosed() &amp;&amp; !toAccount.isClosed()) {\n      fromAccount.transferTo(toAccount, amount);\n    }\n  }\n}\n</code></pre> <p>Note that you may not be able to rewrite <code>transfer</code> in a functional-style easily. That is fine for now. If you do have time, do try to rewrite it in functional-style.</p> <p>Do NOT Change Behavior</p> <p>This is a given, but the behavior of your code should not change after rewriting the implementation.</p> <p>Hint: Your implementation should look something like this:</p> <pre><code>Maybe&lt;&gt; fromAccount = ...;\nMaybe&lt;&gt; toAccount = ...;\nfromAccount.something(...);\n</code></pre> <p>This is not functional-style as we have two assignments before the third statement. If your code works, the output should still be the same as before which is shown below.</p> <pre><code>Bank Status:\nAcc ID: 1, balance: 100.00\nAcc ID: 2, balance: 150.00\nAcc ID: 3, balance: 90.00\nAcc ID: 4, balance: 70.00 [Closed]\n\nBank Status:\nAcc ID: 1, balance: 110.00\nAcc ID: 2, balance: 140.00\nAcc ID: 3, balance: 90.00\nAcc ID: 4, balance: 70.00 [Closed]\n\nBank Status:\nAcc ID: 1, balance: 110.00\nAcc ID: 2, balance: 140.00\nAcc ID: 3, balance: 90.00\nAcc ID: 4, balance: 70.00 [Closed]\n\nBank Status:\nAcc ID: 1, balance: 110.00\nAcc ID: 2, balance: 140.00\nAcc ID: 3, balance: 90.00\nAcc ID: 4, balance: 70.00 [Closed]\n</code></pre> <p>Follow Up</p> <p>How would you change your implementation if <code>Account</code> class were immutable? What other steps do you need to do to update the state of the <code>Bank</code>?</p>"},{"location":"labs/lab07.html","title":"Lab 07: Mini Problems","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to use <code>Stream&lt;T&gt;</code> in their code to replace loops.</li> <li>be able to write functional-style code.</li> </ul> <p>Initializing</p> <p>To get the files, run the following command from your PE node. We recommend creating a new directory called <code>mini</code> to store all your lab mini problems.</p> <pre><code>cp -r ~cs2030s/mini/lab7/ .\n</code></pre> <p>The files will only be available on Wednesday, 23 October 2024.</p> <p>Class Files</p> <p>We have given you a <code>.class</code> file from a badly written <code>Maybe&lt;T&gt;</code> as well as the functional interfaces used in the directory cs2030s/fp. These class files are compiled on the PE node, so we can only guarantee that they can work on the PE node. They may or may not work on other places especially on other operating systems.</p>"},{"location":"labs/lab07.html#mini-problem-1","title":"Mini Problem 1","text":"<p>CS2030S AY2022-23 Sem 2 PA2</p> <p>This mini problem is adapted from CS2030S AY2022-23 Semester 2 PA 2.</p> <p>You are given two classes: <code>Product.java</code> and <code>Cart.java</code>.</p>"},{"location":"labs/lab07.html#productjava","title":"Product.java","text":"<p><code>Product.java</code> is a class that represents a product in an e-commerce site. Each product has</p> <ul> <li>an ID called <code>id</code>, with accessor <code>getID()</code>.</li> <li>a price called <code>price</code>, with accessor <code>getPrice()</code>.</li> <li>a name called <code>name</code>, with accessor <code>getName()</code>.</li> </ul>"},{"location":"labs/lab07.html#cartjava","title":"Cart.java","text":"<p><code>Cart.java</code> is a class that represents a shopping cart in an e-commerce site. It keeps track the list of products added by the user using an <code>ArrayList</code>. It has three methods</p> <ul> <li><code>int totalCost()</code> that returns the total cost of all items in the cart.</li> <li><code>long numOfExpensiveItems(int threshold)</code> that takes in a threshold price and return the number of items with the price greater than or equal to <code>threshold</code>.</li> <li><code>product findByName(String name)</code> that takes in a <code>String</code> representing the product name and return the first product with that name.</li> </ul>"},{"location":"labs/lab07.html#shopping-spree","title":"Shopping Spree","text":"<p>Rewrite the three methods in <code>Cart.java</code> above using functional style.</p>"},{"location":"labs/lab07.html#mini-problem-2","title":"Mini Problem 2","text":"<p>CS2030S AY2022-23 Sem 2 PA2</p> <p>This mini problem is adapted from CS2030S AY2022-23 Semester 2 PA 2.</p> <p>You are given two classes: <code>Account.java</code> and <code>Bank.java</code>. Additionally, we will be using <code>Pair.java</code> from the notes.</p>"},{"location":"labs/lab07.html#accountjava","title":"Account.java","text":"<p><code>Account.java</code> is a class that represents an account in a bank. Each account has</p> <ul> <li>an account number called <code>accountNumber</code>, with accessor <code>getAccountNumber()</code>.</li> <li>an owner called <code>owner</code>, with accessor <code>getOwner()</code>.</li> <li>a balance called <code>balance</code>, with accessor <code>getBalance()</code>, and two mutators: <code>deposit(double amount)</code> and <code>withdraw(double amount)</code>.</li> <li>a flag to indicate if an account is closed or not called <code>isClosed</code>, with accessor <code>isClosed()</code>.</li> </ul>"},{"location":"labs/lab07.html#bankjava","title":"Bank.java","text":"<p>Our bank is getting more popular and now we need to add more functionalities to it. The board members wants you to implement these methods:</p> <ul> <li><code>double totalMoneyInBank()</code> that calculates the total money in the bank across all accounts; and</li> <li><code>String allAccounts()</code> that return the details of all active accounts in the bank as a string, sorted based on their account balance.</li> <li><code>Map&lt;Integer, Account&gt; multiAccounts()</code>that returns a map containing <code>Accounts</code> that belong to someone having multiple bank accounts. The key of the map is the account ID, and the value is the Account object.</li> </ul>"},{"location":"labs/lab07.html#endless-stream-of-money","title":"Endless Stream of Money!","text":"<p>You implemented these classes using for loops in no time. However, during code review, your manager (who is a big fan of functional programming) told you that these methods should be implemented using <code>Stream</code> for the sake of consistency. After all, you implemented the <code>transfer()</code> method using functional style.</p> <p>To help you, your manager came up with a method <code>Stream&lt;Account&gt; getAccountStream()</code> that returns a stream of all accounts in the bank. He also gave you the documentation for Java's Stream API. Equipped with the tools given by your manager, replace all <code>for</code> loops in <code>totalMoneyInBank()</code>, <code>allAccounts()</code>, and <code>multiAccounts()</code> using <code>Stream</code>! We have indicated the lines you need to make into functional style as comments in <code>Bank.java</code>.</p>"},{"location":"prog-ex/0-circle.html","title":"Ex 0: Circle and Point","text":"<p>Basic Information</p> <ul> <li>Deadline: 27 August 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Familiar with the CS2030S lab guidelines.</li> <li>Able to access the CS2030S programming environment via ssh.</li> <li>Setup vim and completed basic <code>vim</code> lessons.</li> <li>Link your PE node account to GitHub.</li> </ul> <p>Files</p> <p>The link to accept the exercise is posted on Canvas and is not available publicly.  You sould not share the link with other people.  After accepting the exercise, run the following command</p> <pre><code>~cs2030s/get ex0\n</code></pre> <p>to retrieve the skeleton code.  You should see the following files:</p> <ol> <li>Skeleton Java Files:<ul> <li><code>Point.java</code>: Skeleton file for <code>Point</code> class.</li> <li><code>RandomPoint.java</code>: Skeleton file for <code>RandomPoint</code> class.</li> <li><code>Circle.java</code>: Skeleton file for <code>Circle</code> class.</li> <li><code>Ex0.java</code>: The main program.</li> </ul> </li> <li>Input/Output Files:<ul> <li><code>inputs/Ex0.k.in</code> for the input files for different values of <code>k</code>.</li> <li><code>outputs/Ex0.k.out</code> for the output files for different values of <code>k</code>.</li> </ul> </li> <li>Bash Script:<ul> <li><code>test.sh</code>: Testing <code>Ex0</code> if it estimates \\(\\pi\\) correctly by comparing the output when running <code>Ex0</code> on <code>inputs/Ex0.k.in</code> with the expected output in <code>outputs/Ex0.k.out</code>.</li> </ul> </li> <li>Unit Tests: <code>Test1.java</code> to <code>Test3.java</code> to test individual classes for expected behavior.</li> </ol>"},{"location":"prog-ex/0-circle.html#overview","title":"Overview","text":"<p>The Monte Carlo method for estimating the value of \\(\\pi\\) is as follows.  We have a square of width \\(2r\\), and within it, a circle with a radius of \\(r\\).  We randomly generate \\(k\\) points within the square.  We count how many points fall within the circle.  Suppose \\(n\\) points out of \\(k\\) fall within the circle.  Since the area of the square is \\(4r^2\\) and the area of the circle is \\(\\pi r^2\\), the ratio between them is \\(\\pi/4\\).  The ratio \\(n/k\\) should therefore be \\(\\pi/4\\), and \\(\\pi\\) can be estimated as \\(4n/k\\).</p>"},{"location":"prog-ex/0-circle.html#tasks","title":"Tasks","text":"<p>A skeleton code has been given.  Your task is to complete the implementation of the classes <code>Point</code>, <code>RandomPoint</code>, <code>Circle</code>, and <code>ex0</code>, according to the OO principles that were taught: abstraction, encapsulation, information hiding, inheritance, tell-don't-ask.</p>"},{"location":"prog-ex/0-circle.html#task-1-point-class","title":"Task 1: <code>Point</code> Class","text":"<p>Fill in the class <code>Point</code> with the constructor and the necessary fields.  Add a <code>toString</code> method so that a string representation as shown in the examples below is returned.</p> <p>For instance,</p> <pre><code>new Point(0, 0).toString();\n</code></pre> <p>should return the string:</p> <pre><code>(0.0, 0.0)\n</code></pre> <p>You will need to come back to this class and add other methods later.  For now, check that your constructor and <code>toString</code> methods are correct.</p> <p>Some simple tests are provided in the file <code>Test1.java</code>. Note that these test cases are not exhaustive and you are encouraged to test your <code>Point</code> class on your own.  Proceed to the next class if you are convinced your <code>Point</code> class is correct.</p> <pre><code>user@pe111:~/ex0-github-username$ javac Test1.java\nuser@pe111:~/ex0-github-username$ java Test1\nPoint: new at (0, 0).. ok\nPoint: new at (-3.14, 1.59).. ok\n</code></pre> <p>Re-Compiling Files that Changed</p> <p>As an aside, note that we do not need to explicitly compile <code>Point.java</code>.  Since <code>Test1.java</code> refers to the <code>Point</code> class, <code>javac</code> is smart enough to compile <code>Point.java</code> if <code>Point.class</code> is not found, or recompile <code>Point.java</code> if it is newer than <code>Point.class</code>.</p> <p>However, sometimes Java can get confused (e.g., if some class files are removed by hand).  It is recommended that students recompile every file that has been edited explicitly, instead of letting Java figure out which file should be recompiled.</p> <p>A simple, brute-force, way to re-compile all the Java files:</p> <pre><code>user@pe111:~/ex0-github-username$ javac *.java\n</code></pre> <p>This only works when all the Java files can be compiled without error, of course including files that are not being used.</p>"},{"location":"prog-ex/0-circle.html#task-2-circle-class","title":"Task #2: <code>Circle</code> Class","text":"<p>Most of the <code>Circle</code> class has been written for you.  You need to complete the method <code>contains</code>.  The method checks if a given point is contained in the calling <code>Circle</code> object. To complete this method according to the tell-don't-ask principle, you will need to add a method in the <code>Point</code> class.</p> <p>Some simple tests are provided in the file <code>Test2.java</code>.  These test cases are not exhaustive and you are encouraged to test your <code>Circle</code> class extensively.</p> <pre><code>user@pe111:~/ex0-github-username$ javac Test2.java\nuser@pe111:~/ex0-github-username$ java Test2\nCircle: new at (0, 0) with radius 4).. ok\nCircle centered at (0, 0) with radius 4 contains (0, 0).. ok\nCircle centered at (0, 0) with radius 4 does not contain (4, 3).. ok\nCircle centered at (0, 0) with radius 4 does not contain (3, 4).. ok\nCircle centered at (2, -3) with radius 0.5 contains (1.8, -3.1).. ok\nCircle centered at (2, -3) with radius 0.5 does not contain (1.8, -4).. ok\n</code></pre>"},{"location":"prog-ex/0-circle.html#task-3-randompoint-class","title":"Task 3: <code>RandomPoint</code> Class","text":"<p>To estimate \\(\\pi\\) using the method above, we need to use a random number generation.  A random number generator is an entity that spews up one random number after another.  We, however, cannot generate a truly random number algorithmically.  We can only generate a pseudo-random number.  A pseudo-random number generator can be initialized with a seed.  A pseudo-random number generator, when initialized with the same seed, always produces the same sequence of (seemingly random) numbers.</p> <p>Java provides a class <code>java.util.Random</code> that encapsulates a pseudo-random number generator.  We can create a random number generator with a seed of 1 as follows.</p> <pre><code>Random rng = new Random(1);\n</code></pre> <p>We can then call <code>rng.nextDouble()</code> repeatedly to generate (pseudo-)random numbers between 0 and 1.</p> <p>Impact of Seed</p> <p>If we re-initialized <code>rng</code> again with another random number generator, with a different seed as shown below</p> <pre><code>rng = new Random(2);\n</code></pre> <p>then calling <code>rng.nextDouble()</code> produces a different sequence.  But if we re-initialized <code>rng</code> with the seed of 1 again as shown below</p> <pre><code>rng = new Random(1);\n</code></pre> <p>then <code>rng.nextDouble()</code> will produce the same sequence as when the seed was 1.</p> <p>(Don't take our word for it.  Try out the above using <code>jshell</code>)</p> <p>Using a fixed seed is important for testing since the execution of the program will be deterministic, even when random numbers are involved.</p> <p><code>RandomPoint</code> is a subclass of <code>Point</code> that represents a randomly generated point.  The random number generator that generates a random point has a default seed of 1.  There is a public method <code>setSeed()</code> that we can use to update the seed. Here is how it can be used:</p> <p>To generate a new point,</p> <pre><code>Point p = new RandomPoint(minX, maxX, minY, maxY); \n</code></pre> <p><code>minX</code>, <code>minY</code>, <code>maxX</code>, <code>maxY</code> represent the minimum and maximum possible x and y values respectively, for each randomly generated point.</p> <p>To set the random seed,</p> <pre><code>RandomPoint.setSeed(10);\n</code></pre> <p>Tips</p> <p>What are the fields and methods that should be associated with the class <code>RandomPoint</code> instead of an instance of <code>RandomPoint</code>?</p> <p>Some simple tests are provided in the file <code>Test3.java</code>.  These test cases are not exhaustive and you are encouraged to test your <code>RandomPoint</code> class extensively.</p> <pre><code>user@pe111:~/ex0-github-username$ javac Test3.java\nuser@pe111:~/ex0-github-username$ java Test3\nRandomPoint: is a subtype of Point.. ok\nRandomPoint: generate a new point with default seed.. ok\nRandomPoint: generate a new point with seed 10.. ok\nRandomPoint: generate a new point with the same seed.. ok\nRandomPoint: reset seed to 10 and generate a new point.. ok\n</code></pre>"},{"location":"prog-ex/0-circle.html#task-4-estimating-pi-using-monte-carlo-method","title":"Task #4: Estimating Pi using Monte Carlo Method","text":""},{"location":"prog-ex/0-circle.html#ex0","title":"Ex0","text":"<p><code>Ex0</code> is the main program to solve the problem above.  The <code>main</code> method is provided.  It includes the method to read in the number of points and the seed from the standard input and to print the estimated pi value.</p> <p>The method <code>estimatePi</code> is incomplete.  Determine how you should declare <code>estimatePi</code>, then complete the body by generating random points and count how many fall under the given circle.</p> <p>Use a circle centred at (0.5, 0.5) with radius 0.5 for this purpose. Use <code>long</code> and <code>double</code> within <code>estimatePi</code> for computation to ensure that you have the right precision.</p> <p>Tips</p> <p>In Java and many other languages, using <code>/</code> on two integers result in an integer division.  Make sure one of the operand of <code>/</code> is a floating point number if you intend to use <code>/</code> for floating point division.</p> <p>To compile <code>Ex0</code>, run</p> <pre><code>user@pe111:~/ex0-github-username$ javac Ex0.java\n</code></pre> <p>To run <code>Ex0</code> and enter the input manually, run</p> <pre><code>user@pe111:~/ex0-github-username$ java Ex0\n</code></pre> <p>The program will pause, waiting for inputs from keyboards.  Enter two numbers.  The first is the number of points.  The second is the seed.</p> <p>To avoid repeatedly entering the same inputs to test, you can enter the two numbers into a text file, say, <code>TEST</code>, and then run</p> <pre><code>user@pe111:~/ex0-github-username$ java Ex0 &lt; TEST\n</code></pre> <p>If you are not sure what <code>&lt;</code> means, read more input/output direction here</p> <p>Sample inputs and outputs have been provided and can be found under the <code>inputs</code> and <code>outputs</code> directory.</p> <p>To test your implementation of <code>Ex0</code>, automatically against the test data given in <code>inputs</code> and <code>outputs</code>, <pre><code>user@pe111:~/ex0-github-username$ ./test.sh Ex0\n</code></pre></p>"},{"location":"prog-ex/0-circle.html#common-mistakes","title":"Common Mistakes","text":""},{"location":"prog-ex/0-circle.html#1-running-a-java-file","title":"1. Running a Java File","text":"<p>Symptom</p> <p>You encounter the following error below.</p> <pre><code>username@pe111:~/ex0-github-username$ java Test1.java\nException in thread \"main\" java.lang.IllegalAccessError: failed\nto access class CS2030STest from class Test1 (CS2030STest is\nin unnamed module of loader 'app'; Test1 is in unnamed module\nof loader com.sun.tools.javac.launcher.Main$MemoryClassLoader\n@782663d3)\n        at Test1.main(Test1.java:5)\n</code></pre> <p>Why?</p> <p>Java code needs to be compiled before you run.  So the correct sequence is to first compile using <code>javac</code> as follows</p> <pre><code>username@pe111:~/ex0-github-username$ javac Test1.java\n</code></pre> <p>and then run using <code>java</code> as follows</p> <pre><code>username@pe111:~/ex0-github-username$ java Test1\n</code></pre>"},{"location":"prog-ex/0-circle.html#2-changes-to-code-not-taking-effect","title":"2. Changes to Code Not Taking Effect","text":"<p>Symptom</p> <p>You have made changes to your code, but the output or behavior of your program remained unchanged.</p> <p>Why?</p> <p>Java code needs to be compiled before you run. You need to compile the files that you have changed first before they can take effect.</p> <p>After you have made changes to multiple files, the easiest way to recompile everything is:</p> <pre><code>username@pe111:~/ex0-github-username$ javac *.java\n</code></pre> <p>where <code>*</code> is a wildcard that pattern-match any string.</p>"},{"location":"prog-ex/0-circle.html#3-constructor-point-cannot-be-applied","title":"3. Constructor Point Cannot be Applied","text":"<p>Symptom</p> <p>You encounter the following error below.</p> <pre><code>RandomPoint.java:12: error: constructor Point in class Point\ncannot be applied to given types;\n</code></pre> <p>Why?</p> <p>The constructor for the subclass should invoke the constructor of the superclass. See the example given in the notes on <code>ColoredCircle</code> and <code>Circle</code>.</p> <p>If the constructor of the superclass is not called explicitly, Java tries to call the default constructor of the superclass without any argument.  If no such constructor is defined, the error above is generated.</p> <p>Also note that the call to <code>super(..)</code> should be the first line inside the constructor of the subclass.  That means, if your call to <code>super(..)</code> requires a computed value, the value has to be computed inline as the arguments to <code>super(..)</code>.</p>"},{"location":"prog-ex/0-circle.html#woopsie","title":"WOOPSIE","text":"<p>Introducing the \"Wonderful OOP SanItizEr\" also called as WOOPSIE.  This is a static analysis tool that will help check some general OOP property of your program.  Its outputs are potentially a series of check starting with <code>[filename]</code>.  These are suggestions to help you not to lose mark.</p> <p>Please note that the checks that can be performed by WOOPSIE are merely suggestions.  In particular, we reduced the precision because a checker that is too eager will give too many checks.  Many of these checks will be a false positive.  Such checker are not a useful checker and you may not even want to use that.</p> <p>Additionally, the coverage of the checker may be limited.  You can, after all, try to fool it by making your code unnecessarily complicated.  We try to hit a sweet spot where if you follow the lab guide, WOOPSIE may give the most optimal benefit with minimal false positives.</p> <p>To run WOOPSIE on all <code>.java</code> file in your current directory, type the following:</p> <pre><code>user@pe111:~/ex0-github-username$ python3 ~cs2030s/WOOPSIE.py\n</code></pre> <p>To run WOOPSIE on a specific file(s), you can specify the files that you wish to be checked.  For instance,</p> <pre><code>user@pe111:~/ex0-github-username$ python3 ~cs2030s/WOOPSIE.py Point.java Circle.java\n</code></pre> <p>WOOPSIE may run even if your program cannot compile.  The requirement is simply that we it can parse your program.  So if the compilation error is due to type issues, WOOPSIE can still check for some common errors.  Some messages that you may see includes:</p> <pre><code>[Point.java]: \"x\" not private\n  HINT: can it be made private?\n</code></pre> <p>javalang</p> <p>If you encounter a problem related to javalang library, you need to install this first by running the following command</p> <pre><code>user@pe111:~/ex0-github-username$ pip install javalang\n</code></pre> <p>CS2030STest</p> <p>If you are running WOOPSIE on all java file, you may see the following message</p> <pre><code>----- WOOPSIE -----\n[CS2030STest.java]: \"CS2030STest.ANSI_RESET\" not private\nHINT: can it be made private?\n[CS2030STest.java]: \"CS2030STest.ANSI_RED\" not private\nHINT: can it be made private?\n[CS2030STest.java]: \"CS2030STest.ANSI_GREEN\" not private\nHINT: can it be made private?\n-------------------\n</code></pre> <p>You do not have to worry about the test files.  Focus only on files you edited.</p>"},{"location":"prog-ex/1-simulation1.html","title":"Ex 1: Simulation I","text":"<p>Basic Information</p> <ul> <li>Deadline: 3 September 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Completed Programming Exercise 0.</li> <li>Caught up to Unit 18 of Lecture Notes.</li> </ul> <p>Goal</p> <p>The goal of Programming Exercise 1 is for you to practice the basic OOP principles: encapsulation (including tell-don't-ask and information hiding), abstraction, inheritance, and polymorphism.</p> <p>You are given six classes: five Java classes and one main <code>Ex1</code> class.  Two of them are poorly written without applying any of the OOP principles.  Using the OO principles that you have learned, you should rewrite, remove, or add new classes as needed.</p>"},{"location":"prog-ex/1-simulation1.html#background-discrete-event-simulator","title":"Background: Discrete Event Simulator","text":"<p>A discrete event simulator is a piece of software that simulates a system (often modeled after the real world) with events and states.  An event occurs at a particular time and each event alters the states of the system and may generate more events.  A discrete event simulator can be used to study many complex real-world systems.  The term discrete refers to the fact that the states remain unchanged between two events, and therefore, the simulator can jump from the time of one event to another, instead of following the clock in real time.</p> <p>In Programming Exercise 1, we provide you with three very generic classes:</p> <ul> <li><code>Simulator</code>: Implements a discrete event simulator.</li> <li><code>Event</code>: Encapsulates an event (with a time)</li> <li><code>Simulation</code>: Encapsulates the states we are simulating.</li> </ul> <p>The Event and Simulation class can be extended to implement any actual simulation (network, road traffic, weather, pandemic, etc).</p>"},{"location":"prog-ex/1-simulation1.html#simulating-a-coffee-shop","title":"Simulating a Coffee Shop","text":"<p>In Exercise 1, we wish to extend the <code>Simulation</code> class to simulate customers in a coffee shop.</p> <p>Our coffee shop can have one or more counters to make orders. In the beginning, all counters are available. A counter becomes unavailable when it is serving a customer, and becomes available again after servicing a customer.</p> <p>A customer, upon arrival at the coffee shop, goes to the first available counter. If no counter is available, the customer departs (we are simulating a neighborhood coffee shop with no space for waiting). Otherwise, the customer is served by a counter. After being served for a given amount of time (called service time), the customer departs.</p> <p>Two classes, <code>CoffeeSimulation</code> (a subclass of <code>Simulation</code>) and <code>CoffeeEvent</code> (a subclass of <code>Event</code>) are provided.  The two classes implement the simulation above.</p>"},{"location":"prog-ex/1-simulation1.html#the-event-class","title":"The <code>Event</code> Class","text":"<p>Do NOT Edit</p> <p>You should NOT edit this class.  The following is for your info only.</p> <p>The <code>Event</code> class is an abstract class with a single field <code>time</code>, which indicates the time the event occurs.  The <code>Event::toString</code> method returns the time as a string and the <code>Event::getTime</code> method returns the time.</p> <p>The most important thing to know about the <code>Event</code> class is that it has an abstract method <code>simulate</code> that needs to be overridden by its subclass to concretely define the action to be taken when this event occurs.</p> <p>Simulating an event can lead to more events being created. <code>Event::simulate</code> returns an array of <code>Event</code> instances.</p>"},{"location":"prog-ex/1-simulation1.html#the-simulation-class","title":"The <code>Simulation</code> Class","text":"<p>Do NOT Edit</p> <p>You should NOT edit this class.  The following is for your info only.</p> <p>The <code>Simulation</code> class is an abstract class with a single method <code>getInitialEvents</code>, which returns an array of events to simulate. Each of these events may generate more events.</p>"},{"location":"prog-ex/1-simulation1.html#the-simulator-class","title":"The <code>Simulator</code> Class","text":"<p>Do NOT Edit</p> <p>You should NOT edit this class.  The following is for your info only.</p> <p>The <code>Simulator</code> class is a class with only two methods and it is what drives the simulation. To run the simulator, we initialize it with a <code>Simulation</code> instance, and then call run:</p> <pre><code>Simulation sim = new SomeSimulation(); \nnew Simulator(sim).run();\n</code></pre> <p>The <code>Simulation::run</code> method simply does the following:</p> <ul> <li> <p>It gets the list of initial <code>Event</code> objects from the <code>Simulation</code> object;</p> </li> <li> <p>It then simulates the pool of events, one by one in the order of increasing time, by calling <code>Event::simulate</code>;</p> </li> <li> <p>If simulating an event results in one or more new events, the new events are added to the pool.</p> </li> <li> <p>Before each event is simulated, <code>Event::toString</code> is called and a message is printed</p> </li> <li> <p>The simulation stops running if there are no more events to simulate.</p> </li> </ul> <p>For those of you taking CS2040S, you might be interested to know that the <code>Simulator</code> class uses a priority queue to keep track of the events with their time as the key.</p>"},{"location":"prog-ex/1-simulation1.html#the-coffeesimulation-class","title":"The <code>CoffeeSimulation</code> Class","text":"<p>Edit</p> <p>You are expected to edit this class and create new classes.</p> <p>The <code>CoffeeSimulation</code> class is a concrete implementation of a <code>Simulation</code>. This class is responsible for:</p> <ul> <li> <p>reading the inputs from the standard inputs,</p> </li> <li> <p>initialize the coffee shop counters (represented with boolean <code>available</code> arrays)</p> </li> <li> <p>initialize the events corresponding to customer arrivals</p> </li> <li> <p>return the list of customer arrival events to the <code>Simulator</code> object when <code>getInitialEvent</code> is called.</p> </li> </ul> <p>Each customer has an ID. The first customer has id 0, the next one is 1, and so on.</p> <p>Each counter has an ID, numbered from 0, 1, 2, and onwards.</p>"},{"location":"prog-ex/1-simulation1.html#the-coffeeevent-class","title":"The <code>CoffeeEvent</code> Class","text":"<p>Replace</p> <p>You are expected to replace this class with new classes. You must remove the file <code>CoffeeEvent.java</code> before submission if the file is no longer used in your solution.</p> <p>The <code>CoffeeEvent</code> class is a concrete implementation of <code>Event</code>. This class overrides the simulate method to simulate the customer and counter behavior.</p> <p>A <code>CoffeeEvent</code> instance can be tagged as either an arrival event, service-begin event, service-end event, or departure event.</p> <ul> <li> <p>Arrival: the customer arrives. It finds the first available coffee shop counter (scanning from ID 0 upwards) and goes to the counter for service immediately. A service-begin event is generated. If no counter is available, it departs. A departure event is generated.</p> </li> <li> <p>Service-begin: the customer is being served. A service-end event scheduled at the time (current time + service time) is generated.</p> </li> <li> <p>Service-end: the customer is done being served and departs immediately. A departure event is generated.</p> </li> <li> <p>Departure: the customer departs.</p> </li> </ul>"},{"location":"prog-ex/1-simulation1.html#inputs-and-outputs","title":"Inputs and Outputs","text":"<p>The main program <code>Ex1.java</code> reads the following, from the standard inputs.</p> <ul> <li>An integer \\(n\\), for the number of customers to simulate.</li> <li>An integer \\(k\\), for the number of coffee shop counters the coffee shop has.</li> <li>\\(n\\) pairs of double values, each pair corresponds to a customer.  The first value indicates the arrival time, and the second indicates the service time for the customer.</li> </ul> <p>The customers are sorted in increasing order of arrival time.</p> <p>Assumptions</p> <p>We assume that no two events at the same time will ever be in the collection of events and no customer will arrive exactly at the same time as another customer is leaving. As per all exercises, we assume that the input is correctly formatted.</p>"},{"location":"prog-ex/1-simulation1.html#tasks","title":"Tasks","text":"<p>The two classes, <code>CoffeeSimulation</code> and <code>CoffeeEvent</code>, are poorly written.  They do not fully exploit OOP features and apply the OO principles such as abstraction, encapsulation (including information hiding and tell-don't-ask), composition, inheritance, polymorphism, and Liskov substitution principle.</p>"},{"location":"prog-ex/1-simulation1.html#task-1-rewrite","title":"Task 1: Rewrite","text":"<p>Rewrite these two classes (adding new ones as needed) with the OOP principles that you have learned:</p> <ul> <li>encapsulation to group relevant fields and methods into new classes;</li> <li>inheritance and composition to model the relationship between the classes;</li> <li>information hiding to hide internal details; and</li> <li>using polymorphism to make the code more succinct and extendable in the future, while adhering to the LSP.</li> </ul> <p>Here are some hints:</p> <ul> <li>Think about the problem that you are solving: what are the nouns? These are good candidates for new classes.</li> <li>For each class, what are the attributes/properties relevant to the class? These are good candidates for fields in the class.</li> <li>Do the classes relate to each other via IS-A or HAS-A relationship?</li> <li>For each class, what are their responsibilities? What can they do? These are good candidates for methods in the class.</li> <li>How do the objects of each class interact? These are good candidates for public methods.</li> <li>What are some behavior that changes depending on the specific type of object?</li> </ul> <p>Note that the goal of this exercise, and CS2030S in general, is NOT to solve the problem with the cleverest and the shortest piece of code possible.  For instance, you might notice that you can solve Programming Exercise 1 with only a few variables and an array.  But such a solution is hard to extend and modify.  In CS2030S, our goal is to produce software that can easily evolve and be modified, with a reduced risk of introducing bugs while doing so.</p> <p>Note that Programming Exercise 1 is the first of a series of exercises, where we introduce new requirements or modify existing ones in every exercise (not unlike what software engineers face in the real world). We will modify the behavior of the coffee shop, the counters, and the customers. In particular, in the future,</p> <ul> <li>a customer may order different kinds of coffee such as Latte, etc.</li> <li>there may be different counters that only allow a customer to order specific coffee, such as only Cold Brew, only Latte, or only Espresso.</li> <li>counters may open and close at different times because some orders are more popular at certain times.</li> <li>the coffee shop might expand and be able to handle more customers and more counters.</li> </ul> <p>Thus, making sure that your code will be able to adapt to new problem statements is the key. If you solve the exercise without considering this, you will likely find yourself painted into a corner and have to re-write much of your solution to handle any new requirements.</p>"},{"location":"prog-ex/1-simulation1.html#testing","title":"Testing","text":"<p>You will find the sub-directories <code>inputs</code> and <code>outputs</code> in the given skeleton. These directories contain the test cases. The file <code>Ex1.x.in</code> contains the input for Test Case \\(x\\); the file <code>Ex1.x.out</code> contains the expected output for Test Case \\(x\\).</p> <p>A script <code>test.sh</code> has been given to you for testing. To test your program, run</p> <pre><code>username@pe111:~/ex1-github-username$ ./test.sh Ex1\n</code></pre> <p>You should see:</p> <pre><code>test 1: passed\ntest 2: passed\ntest 3: passed\ntest 4: passed\ntest 5: passed\nEx1: passed everything \ud83c\udf89\n</code></pre> <p>Note that the given skeleton is a fully working program. Thus, it already passed the test cases.</p> <p>If you want to test your program with your own test cases, run the following:</p> <pre><code>username@pe111:~/ex1-github-username$ java Ex1 &lt; FILE\n</code></pre> <p>where <code>FILE</code> is the file that contains your own test case. If you are not familiar with <code>&lt;</code>, take a look at our Unix CLI notes on standard input and output.</p>"},{"location":"prog-ex/1-simulation1.html#comparing-outputs","title":"Comparing Outputs","text":"<p>If the output of your program is different from the expected output, you can redirect the output of your program to a file for inspection. For instance, suppose that your code failed Test Case 3. The following would create a file <code>OUT</code> that contains the output from your program for Test Case 3.</p> <pre><code>username@pe111:~/ex1-github-username$ java Ex1 &lt; inputs/Ex1.3.in &gt; OUT\n</code></pre> <p>Use <code>vim -d</code> to compare your output with the expected output.</p> <pre><code>username@pe111:~/ex1-github-username$ vim -d OUT outputs/Ex1.3.out\n</code></pre>"},{"location":"prog-ex/1-simulation1.html#style-optional","title":"Style (Optional)","text":"<p>Make sure that your code following our coding style is optional for Programming Exercise 1. If you would like to keep your code neat, tidy, and adhere to the CS2030S style, you can run </p> <pre><code>username@pe111:~/ex1-github-username$ java -jar ~cs2030s/bin/checkstyle.jar -c ~cs2030s/bin/cs2030_checks.xml *.java\n</code></pre> <p>You should see the following output, with nothing in between the two lines. Any style errors would appear in between the two.</p> <pre><code>Starting audit...\nAudit done.\n</code></pre>"},{"location":"prog-ex/1-simulation1.html#documentation-optional","title":"Documentation (Optional)","text":"<p>Documenting your code with Javadoc is optional for Programming Exercise 1. It is, however, always a good practice to include comments to help readers understand your code.</p>"},{"location":"prog-ex/2-simulation2.html","title":"Ex 2: Simulation II","text":"<p>Basic Information</p> <ul> <li>Deadline: 10 September 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Completed Programming Exercise 1.</li> <li>Caught up to Unit 20 of Lecture Notes.</li> </ul> <p>Goal</p> <p>This is a continuation of Programming Exercise 1. Programming Exercise 2 changes some of the requirements of Programming Exercise 1 and adds some new things to the world that we are simulating.  The goal is to demonstrate that, when OO principles are applied properly, we can adapt our code to changes in the requirement with less effort.  If your design for Programming Exercise 1 follows the OOP principles, then only about 50 lines of changes/additions are required.</p> <p>For Programming Exercise 2, you should (i) improve upon your design for Programming Exercise 1 if needed, (ii) update CoffeeSimulation and associated classes to simulate the extended scenarios, and (iii) update the input and output components of the classes to conform to the specification below.</p> <p>Programming Exercise 2 also nudges you towards following good coding practice by adhering to a published coding convention.</p>"},{"location":"prog-ex/2-simulation2.html#tasks","title":"Tasks","text":"<p>We have two extensions that we want to do on our coffee shop.  Before we do that, we need to make sure that your Ex 1 code are sufficiently good.</p>"},{"location":"prog-ex/2-simulation2.html#task-1-address-the-concern","title":"Task 1: Address the Concern","text":"<p>Hopefully, by now your friendly TA should have written comments about your submission.  You should address the concerns pointed by your TA.  If those concerns remained unaddressed, the same deductions will be applied to the current submission too.</p>"},{"location":"prog-ex/2-simulation2.html#task-2-extend","title":"Task 2: Extend","text":""},{"location":"prog-ex/2-simulation2.html#extension-1-simulating-a-coffee-shop-with-a-queue","title":"Extension 1: Simulating a Coffee Shop with a Queue","text":"<p>Recall that, no waiting was allowed inside the coffee shop we are simulating.  The coffee shop is losing customers as a customer departs if all the counters are busy.</p> <p>Programming Exercise 2 adds an entrance queue to the coffee shop.  If all counters are busy when a customer arrives, the customer will join the queue and wait.  When a counter becomes available, the customer at the front of the queue will proceed to the counter for service.</p> <p>The entrance queue has a maximum queue length of \\(m\\).  If there are already \\(m\\) customers waiting in the entrance queue, any arriving customer will be turned away<sup>1</sup>.</p> <p>If some counters are available when a customer arrives, the customer will go the first available counter, just like in Programming Exercise 1.</p>"},{"location":"prog-ex/2-simulation2.html#extension-2-customers-with-orders","title":"Extension 2: Customers with Orders","text":"<p>Customers now come to the coffee shop with a coffee they intend to order.  The order can be either an espresso or a latte for now.</p> <p>Note</p> <p>We are not going to actually make the coffee using our code but it is possible if you have an espresso machine<sup>2</sup>.</p>"},{"location":"prog-ex/2-simulation2.html#extension-3-changes-to-input","title":"Extension 3: Changes to Input","text":"<p>As we want to add a queue of some length \\(m\\) and customer order, we need to modify the input as well.  The changes to the input are summarized below.  You will need to implement this changes first before you can do testing as our input test files follow this new format.</p> <ol> <li> <p>There is an additional input parameter in the first line of the input file, an integer \\(m\\), indicating the maximum allowed length of the entrance queue. This input parameter should be read immediately after reading the number of customers and the number of service counters.</p> </li> <li> <p>There is an additional input parameter at the end of each line in the input file that describes a customer's arrival.  The new parameter is an <code>int</code>, which is either \\(0\\) (for espresso order) or \\(1\\) (for latte order).</p> </li> </ol>"},{"location":"prog-ex/2-simulation2.html#changes","title":"Changes","text":"Ex1.1.in<pre><code>3 1\n1.0 1.0\n3.0 1.0\n5.0 1.0\n</code></pre> Ex2.1.in<pre><code>3 1 2\n1.0 1.0 0\n3.0 1.0 1\n5.0 1.0 0\n</code></pre> <p>In <code>Ex2.1.in</code>, the first line of the input has an additional integer input <code>2</code>.  This specifies the length of the queue.</p> <p>Additionally, for subsequent lines we have additional integer inputs for each line.  For line 2 and 4, the customers are ordering espresso.  For line 3, the customer is ordering latte.</p> <p>Assumptions</p> <p>We assume that no two events involving two different customers ever occur at the same time (except when a customer departs and another customer begins their order).  As per all exercises, we assume that the input is correctly formatted.</p>"},{"location":"prog-ex/2-simulation2.html#extension-4-changes-to-output","title":"Extension 4: Changes to Output","text":"<ol> <li> <p>A customer will now be printed with a single letter prefix <code>C</code>.  For instance, instead of printing <code>Customer 1</code>, we print <code>C1</code>.</p> </li> <li> <p>A counter will be manned by a barista.  As such, a counter will now be printed with a single letter prefix <code>B</code>.  So, instead of printing <code>Counter 1</code>, we print <code>B1</code>.</p> </li> <li> <p>The entrance queue of the coffee shop will be printed with the arrival event.  For example, the following shows that <code>C4</code> arrived at time <code>2.100</code> and at the time of interval, there were two customers <code>C2</code> and <code>C3</code> already waiting in the entrance queue.</p> From Ex2.10.out<pre><code>2.100: C4 arrives [ C2 C3 ]\n</code></pre> </li> <li> <p>If a customer joins the entrance queue, the customer along with the queue before joining should be printed.</p> From Ex2.4.out<pre><code>4.000: C4 joined queue [ C2 C3 ]\n</code></pre> </li> <li> <p>When a customer ordered a coffee or has been served their order, the customer order should also be printed. For example, Customer <code>C2</code> is ordering a latte on counter <code>B0</code> would be printed as follows.</p> From Ex2.4.out<pre><code>5.100: C2 ordered Coffee Latte (by B0)\n7.100: C2 served Coffee Latte (by B0)\n</code></pre> </li> </ol>"},{"location":"prog-ex/2-simulation2.html#skeleton-for-programming-exercise-2","title":"Skeleton for Programming Exercise 2","text":"<p>We only provide two classes for Programming Exercise 2, the main <code>Ex2.java</code> (which is simply <code>Ex1.java</code> renamed) and <code>Queue.java</code>. The <code>Ex2.java</code> is similar to <code>Ex1.java</code>.  <code>Queue.java</code> is new.  It models a first-in first-out (FIFO) queue of objects.  Its usage will be explained further below.</p> <p>Do NOT Edit</p> <p>You should NOT edit <code>Ex2.java</code> or <code>Queue.java</code>.  However, you may change the <code>@author</code> tag of these two files if you wish.</p> <p>Additionally, if you have made changes to <code>Event.java</code>, <code>Simulation.java</code>, or <code>Simulator.java</code>, you will need to use the original file given for Programming Exercise 1 as those are not supposed to be edited.</p>"},{"location":"prog-ex/2-simulation2.html#building-on-programming-exercise-1","title":"Building on Programming Exercise 1","text":"<p>You are required to build on top of your Programming Exercise 1 submission for this exercise.</p> <p>Assuming you have <code>ex1-username</code> and <code>ex2-username</code> under the same directory, and <code>ex2-username</code> is your current working directory, you can run </p> <pre><code>username@pe111:~/ex2-username$ cp -i ../ex1-username/*.java .\nusername@pe111:~/ex2-username$ rm -i Ex1.java\n</code></pre> <p>to copy all your Java code over and remove the main file for <code>Ex1</code>.</p> <p>If you are still unfamiliar with Unix commands to navigate the file system and manage files, please review our Unix guide.</p> <p>You are encouraged to consider your tutor's feedback and fix any issues with your design for your Programming Exercise 1 submission before you embark on your Programming Exercise 2.</p>"},{"location":"prog-ex/2-simulation2.html#the-queue-class","title":"The <code>Queue</code> Class","text":"<p><code>Queue</code> is a general class for a first-in, first-out queue of objects. Here is an example of how it is used:</p> Usage of Queue<pre><code>// Create a queue that holds up to 4 elements\nQueue q = new Queue(4);\n\n// Add a string into the queue.  returns true if successful; \n// false otherwise.\nboolean b = q.enq(\"a1\");\n\n// Remove a string from the queue.  `Queue::deq` returns an \n// `Object`, so narrowing type conversion is needed.  Returns \n// `null` if queue is empty.\nString s = (String) q.deq();\n\n// Returns the string representation of the queue (showing \n// each element)\nString s = q.toString();\n\n// Returns true if the queue is full, false otherwise.\nboolean b = q.isFull();\n\n// Returns true if the queue is empty, false otherwise.\nboolean b = q.isEmpty();\n</code></pre>"},{"location":"prog-ex/2-simulation2.html#following-cs2030s-style-guide","title":"Following CS2030S Style Guide","text":"<p>In addition to the changes above, you should also make sure that your code follows the given Java style guide.</p> <p>You can use checkstyle tool and the given configuration <code>ex2_style.xml</code> to check your code:</p> <pre><code>username@pe111:~/ex2-username$ java -jar ~cs2030s/bin/checkstyle.jar -c ex2_style.xml *.java\n</code></pre>"},{"location":"prog-ex/2-simulation2.html#compiling-testing-and-debugging","title":"Compiling, Testing, and Debugging","text":""},{"location":"prog-ex/2-simulation2.html#compiling","title":"Compiling","text":"<p>To compile your code, you can compile all the Java file.</p> <pre><code>username@pe111:~/ex2-username$ javac *.java\n</code></pre>"},{"location":"prog-ex/2-simulation2.html#running-and-testing","title":"Running and Testing","text":"<p>You should not test your code by manually entering the inputs. Instead, enter the inputs into a file, and run </p> <pre><code>username@pe111:~/ex2-username$ java Ex2 &lt; file\n</code></pre> <p>A set of test inputs is provided as part of the skeleton, named <code>Ex2.x.in</code> under the inputs directory.  You can run them with, for instance, </p> <pre><code>username@pe111:~/ex2-username$ java Ex2 &lt; inputs/Ex2.4.in\n</code></pre> <p>You can save the output by redirecting it into a file. </p> <pre><code>username@pe111:~/ex2-username$ java Ex2 &lt; inputs/Ex2.4.in &gt; OUT\n</code></pre> <p>You can automatically test your code against all the given inputs/outputs as well as against the <code>checkstyle</code> by running: </p> <pre><code>username@pe111:~/ex2-username$ java Ex2 &lt; inputs/Ex2.4.in &gt; OUT\n</code></pre>"},{"location":"prog-ex/2-simulation2.html#debugging","title":"Debugging","text":"<p>The expected outputs are given in the <code>outputs</code> directory. You can compare <code>OUT</code> with the expected output with <code>diff</code> or <code>vim</code>. Using <code>vim</code>, </p> <pre><code>username@pe111:~/ex2-username$ vim -d OUT outputs/Ex2.4.out\n</code></pre> <p>will open both files and highlight the differences.</p> <p>As the output becomes too long, you can focus on tracing a particular counter or customer with the help of <code>grep</code>. Suppose you want to focus on what happened to Customer 3 in <code>OUT</code>, run </p> <pre><code>username@pe111:~/ex2-username$ grep \": C3\" OUT\n</code></pre> <p>You should see the following output: </p> <pre><code>1.400: C3 arrives [ C1 C2 ]\n1.400: C3 joined queue [ C1 C2 ]\n9.100: C3 departed\n</code></pre> <p>Suppose you want to see all the customers served by <code>B0</code>, run: </p> <pre><code>username@pe111:~/ex2-username$ grep \"B0\" OUT\n</code></pre> <p>You should see the following output: </p> <pre><code>1.100: C0 ordered Coffee Espresso (by B0)\n3.100: C0 served Coffee Espresso (by B0)\n3.100: C1 ordered Coffee Espresso (by B0)\n5.100: C1 served Coffee Espresso (by B0)\n5.100: C2 ordered Coffee Latte (by B0)\n7.100: C2 served Coffee Latte (by B0)\n7.100: C3 ordered Coffee Latte (by B0)\n9.100: C3 served Coffee Latte (by B0)\n9.100: C4 ordered Coffee Latte (by B0)\n11.100: C4 served Coffee Latte (by B0)\n</code></pre>"},{"location":"prog-ex/2-simulation2.html#documentation-optional","title":"Documentation (Optional)","text":"<p>Documenting your code with Javadoc is optional for Programming Exercise 2.  It is, however, always a good practice to include comments to help readers understand your code.</p> <ol> <li> <p>This is known as \"balking\" in queueing theory.\u00a0\u21a9</p> </li> <li> <p>If you want to try creating an arduino controlled espresso machine, you can follow the following guide: https://gaggiuino.github.io/#/ \u21a9</p> </li> </ol>"},{"location":"prog-ex/3-simulation3.html","title":"Ex 3: Simulation III","text":"<p>Basic Information</p> <ul> <li>Deadline: 17 September 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605\u2605\u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Completed Programming Exercise 2.</li> <li>Caught up to Unit 25 of Lecture Notes.</li> <li>Familiar with CS2030S Java style guide.</li> </ul> <p>Goal</p> <p>This is a continuation of Programming Exercise 2. Programming Exercise 3 extends some of the requirements of Programming Exercise 2 and adds new entities to the world that we are simulating.  The goal is to demonstrate that, when OO principles are applied properly, we can adapt our code to changes in the requirements with less effort.</p> <p>Programming Exercise 3 also involves writing your generic classes.</p>"},{"location":"prog-ex/3-simulation3.html#tasks","title":"Tasks","text":"<p>We have two extensions that we want to do on our coffee shop.  Before we do that, we need to make sure that your Ex 1 code are sufficiently good.</p>"},{"location":"prog-ex/3-simulation3.html#task-1-address-the-concern","title":"Task 1: Address the Concern","text":"<p>Hopefully, by now your friendly TA should have written comments about your submission.  You should address the concerns pointed by your TA.  If those concerns remained unaddressed, the same deductions will be applied to the current submission too.</p>"},{"location":"prog-ex/3-simulation3.html#task-2-extend","title":"Task 2: Extend","text":""},{"location":"prog-ex/3-simulation3.html#extension-1-queueing-with-the-barista","title":"Extension 1: Queueing with the Barista","text":"<p>The coffee shop has now decided to streamline its operations.  It rearranges the layout and makes some space for queues at the counters with the barista.  With that, customers can now wait at individual barista.</p> <p>In this exercise, we will modify the simulation to add a queue to each barista/counter.  Remember that each counter has exactly one barista so we can use counter and barista interchangeably.  For simplicity, we will refer to the queue at the counter as barista queue.</p> <p>The maximum queue length for each barista queue is \\(l\\). All barista queues are independent.  Recall from Exercise 2 that the maximum queue length for the entrance queue is denoted as \\(m\\). \\(m\\) and \\(l\\) may be different.</p> <p>When a customer arrives, a few scenarios could happen:</p> <ul> <li>If more than one counter is available, a customer will go to the counter with the smallest id (just like in Exercise 2).</li> <li>If none of the counters is available, but at least one of the barista queues is not full, the customer will join the counter with the shortest barista queue.  If there are two counters with the same queue length, we break ties by going to the counter with the smaller id.</li> <li>If every barista queue has reached its maximum capacity of \\(l\\), but the entrance queue is not full, then the customer will join the entrance queue.</li> <li>If every barista queue has reached its maximum capacity of \\(l\\), and the entrance queue has reached its maximum capacity of \\(m\\), then the customer will leave.</li> </ul> <p>When a counter is done serving a customer and becomes available, the customer at the front of its barista queue will proceed to the counter for service.  This event frees up a slot in the barista queue.  One customer from the entrance queue may join the barista queue of that counter.  It takes 0.05 time unit for a customer to move from the entrance queue to the barista queue.</p> <p>Note that, the entrance queue is empty unless all barista queues have reached the maximum length. Furthermore, a counter cannot \"steal\" a customer from another barista queue. Once a customer joins a barista queue, it cannot switch to another barista queue.</p>"},{"location":"prog-ex/3-simulation3.html#extension-2-custom-orders","title":"Extension 2: Custom Orders","text":"<p>Recall that a customer comes into the coffee shop with an order.  We will now add custom instructions on the orders.  For simplicity, assume that all barista can accommodate all instructions.  The custom instructions are always a single word (i.e., not separated by a space).</p>"},{"location":"prog-ex/3-simulation3.html#extension-3-changes-to-input","title":"Extension 3: Changes to Input","text":"<ol> <li> <p>There is an additional input parameter, an integer \\(l\\), indicating the maximum allowed length of the barista queue. This input parameter should be read immediately after reading the number of coffee shop counters and before the maximum allowed length of the entrance queue.</p> </li> <li> <p>There is an additional input parameter at the end of each line in the input file that indicates the custom instructions for the order.  This new input is always a string consisting only of alphabets.  You should read the input using <code>Scanner::next()</code>.</p> </li> </ol>"},{"location":"prog-ex/3-simulation3.html#changes","title":"Changes","text":"Ex2.1.in<pre><code>3 1 2\n1.0 1.0 0\n3.0 1.0 1\n5.0 1.0 0\n</code></pre> Ex3.1.in<pre><code>3 1 0 2\n1.0 1.0 0 Small\n3.0 1.0 1 Medium\n5.0 1.0 0 Large\n</code></pre> <p>In <code>Ex3.1.in</code>, the first line of the input has an additional integer input <code>0</code> as the third input on the first line.  This specifies the length of the barista queue.</p> <p>Additionally, for subsequent lines we have additional String inputs for each line.</p> <ul> <li>Line 2: The customer wants a \"Small\" order.</li> <li>Line 3: The customer wants a \"Medium\" order.</li> <li>Line 4: The customer wants a \"Large\" order.</li> </ul> <p>Assumptions</p> <p>We assume that no two events involving two different customers ever occur at the same time (except when a customer departs and another customer begins their order).  As per all exercises, we assume that the input is correctly formatted.</p>"},{"location":"prog-ex/3-simulation3.html#extension-4-changes-to-output","title":"Extension 4: Changes to Output","text":"<ol> <li> <p>Whenever we print a counter/barista, we also print its barista queue.</p> From Ex3.13.out<pre><code>1.700: C7 joined barista queue (at B1 [ C4 ])\n</code></pre> </li> <li> <p>Whenever we print an order, we print the custom instructions before the order.  The custom instruction is enclosed within a parentheses.</p> From Ex3.13.out<pre><code>3.100: C7 ordered (Medium) Coffee Espresso (by B1 [ ])\n4.000: C3 served (Hot) Coffee Latte (by B0 [ C6 C9 ])\n</code></pre> </li> </ol>"},{"location":"prog-ex/3-simulation3.html#task-3-incorporate-generic-queue","title":"Task 3: Incorporate Generic Queue","text":"<p>Do NOT Edit</p> <p>You are not allowed to edit <code>CoffeeQueue.java</code>.</p> <p>Delete Queue.java</p> <p>Please completely delete <code>Queue.java</code> before submitting.</p> <p>We have given you a generic <code>CoffeeQueue&lt;T&gt;</code> class as an improvement to <code>Queue</code> class in Exercise 2 because <code>Queue</code> stores its elements as <code>Object</code> and is not type-safe.  Update your program to incorporate <code>CoffeeQueue&lt;T&gt;</code> instead of <code>Queue</code>.  You should not longer use <code>Queue</code> and you should delete <code>Queue.java</code>.</p> <p>Our <code>CoffeeQueue&lt;T&gt;</code> is comparable to other <code>CoffeeQueue&lt;T&gt;</code>.  This is done by implementing the interface <code>Comparable&lt;CoffeeQueue&lt;T&gt;&gt;</code> and providing an implementation of <code>compareTo</code>.  We compare two <code>CoffeeQueue&lt;T&gt;</code> according to their sizes.  Consider the method invocation below.</p> <pre><code>queue1.compareTo(queue2);\n</code></pre> <ul> <li>If the result is negative, then <code>queue1</code> &lt; <code>queue2</code>.</li> <li>If the result is positive, then <code>queue1</code> &gt; <code>queue2</code>.</li> <li>Otherwise, <code>queue1</code> = <code>queue2</code>.</li> </ul>"},{"location":"prog-ex/3-simulation3.html#task-4-creating-generic-sequence","title":"Task 4: Creating Generic Sequence","text":"<p>Let's call the class that encapsulates the counter/barista as <code>CoffeeCounter</code> (you may name it differently).  We have been using an array to store the <code>CoffeeCounter</code> objects.  In Exercise 3, you should replace that with a generic wrapper around an array. In other words, we want to replace <code>CoffeeCounter[]</code> with <code>Seq&lt;BankCounter&gt;</code>. You may build upon the <code>Seq&lt;T&gt;</code> class from the notes \u2014 Unit 25.</p> <p>The <code>Seq&lt;T&gt;</code> class should support the following:</p> <ul> <li> <p><code>Seq&lt;T&gt;</code> takes in only a subtype of <code>Comparable&lt;T&gt;</code> as its type argument.  That is, we want to parameterize <code>Seq&lt;T&gt;</code> with only a <code>T</code> that can compare with itself.  Note that in implementing <code>Seq&lt;T&gt;</code>, you will find another situation where using raw type is necessary.  You may, for this case, use <code>@SuppressWarnings(\"rawtypes\")</code> at the smallest scope possible to suppress the warning about raw types.  If you need to suppress multiple warnings, you may use <code>@SuppressWarnings({\"warning1\", \"warning2\"})</code>.</p> </li> <li> <p><code>Seq&lt;T&gt;</code> must support the <code>min</code> method, with the following descriptor:</p> <pre><code>T min()\n</code></pre> <p><code>min</code> returns the minimum element (based on the order defined by the <code>compareTo</code> method of the <code>Comparable&lt;T&gt;</code> interface).  Recap the specification of <code>compareTo</code>.  If <code>x.compareTo(y)</code> returns</p> <ul> <li>any negative value, then <code>x</code> &lt; <code>y</code>.</li> <li>zero, then <code>x</code> = <code>y</code>.</li> <li>any positive value, then <code>x</code> &gt; <code>y</code>.</li> </ul> </li> <li> <p><code>Seq&lt;T&gt;</code> supports a <code>toString</code> method.  The code has been given to you in <code>Seq.java</code>.</p> </li> </ul> <p>You are encouraged to test your <code>Seq&lt;T&gt;</code> in jshell yourself.  A sample test sequence is as follows:</p> <pre><code>jshell&gt; /open Seq.java\njshell&gt; Integer i\njshell&gt; String s\njshell&gt; Seq&lt;Integer&gt; a;\njshell&gt; a = new Seq&lt;Integer&gt;(4);\njshell&gt; a.set(0, 3);\njshell&gt; a.set(1, 6);\njshell&gt; a.set(2, 4);\njshell&gt; a.set(3, 1);\njshell&gt; a.set(0, \"huat\");\n|  Error:\n|  incompatible types: java.lang.String cannot be converted to java.lang.Integer\n|  a.set(0, \"huat\");\n|           ^----^\njshell&gt; i = a.get(0)\njshell&gt; i\ni ==&gt; 3\njshell&gt; i = a.get(1)\njshell&gt; i\ni ==&gt; 6\njshell&gt; i = a.get(2)\njshell&gt; i\ni ==&gt; 4\njshell&gt; i = a.get(3)\njshell&gt; i\ni ==&gt; 1\njshell&gt; s = a.get(0)\n|  Error:\n|  incompatible types: java.lang.Integer cannot be converted to java.lang.String\n|  s = a.get(0)\n|      ^------^\njshell&gt; i = a.min()\njshell&gt; i\ni ==&gt; 1\njshell&gt; a.set(3,9);\njshell&gt; i = a.min()\njshell&gt; i\ni ==&gt; 3\njshell&gt; // try something not comparable\njshell&gt; class A {}\njshell&gt; Seq&lt;A&gt; a;\n|  Error:\n|  type argument A is not within bounds of type-variable T\n|  Seq&lt;A&gt; a;\n|        ^\njshell&gt; class A implements Comparable&lt;Long&gt; { public int compareTo(Long i) { return 0; } }\njshell&gt; Seq&lt;A&gt; a;\n|  Error:\n|  type argument A is not within bounds of type-variable T\n|  Seq&lt;A&gt; a;\n|        ^\njshell&gt; // try something comparable\njshell&gt; class A implements Comparable&lt;A&gt; { public int compareTo(A a) { return 0; } }\njshell&gt; Seq&lt;A&gt; a;\njshell&gt; \n</code></pre> <p>The file <code>SeqTest.java</code> helps to test your <code>Seq&lt;T&gt;</code> class.</p> <pre><code>username@pe111:~/ex3-username$ javac -Xlint:unchecked -Xlint:rawtypes SeqTest.java\nusername@pe111:~/ex3-username$ java SeqTest\n</code></pre>"},{"location":"prog-ex/3-simulation3.html#task-5-comparable-counter","title":"Task 5: Comparable Counter","text":"<p>Your class that encapsulates coffee counters must now implement <code>Comparable&lt;T&gt;</code> interface so that it can be compared with another instance of the same type.  This way, it can also be used as type argument for <code>Seq&lt;T&gt;</code>.</p> <p>You should implement <code>compareTo</code> in such a way that <code>counters.min()</code> returns the counter that a customer should join (unless all the barista queues have reached maximum length).</p>"},{"location":"prog-ex/3-simulation3.html#task-6-updating-the-simulation","title":"Task 6: Updating the Simulation","text":"<p>By incorporating <code>CoffeeQueue&lt;T&gt;</code> and <code>Seq&lt;T&gt;</code>, your simulation will need to be updated.  This potentially includes modifying <code>CoffeeCounter</code> (the name may be different) as well as adding new subclass of <code>Event</code>.</p> <p>Finally, ensure that all your files can be compiled without warning even with <code>-Xlint:unchecked</code> and <code>-Xlint:rawtypes</code>.</p>"},{"location":"prog-ex/3-simulation3.html#skeleton-for-programming-exercise-3","title":"Skeleton for Programming Exercise 3","text":"<p>We provide three classes for Exercise 3, the main <code>Ex3.java</code> (which is simply <code>Ex2.java</code> renamed), <code>CoffeeQueue.java</code> (which is simply a generic version of <code>Queue.java</code>), and <code>Seq.java</code>.  You should not edit <code>Ex3.java</code> and <code>CoffeeQueue.java</code> but you need to fill in the blanks (i.e., <code>// TODO</code>) for <code>Seq.java</code> as described above.</p> <p>We also provide two new classes for testing: <code>CS2030STest.java</code> (which you should be familiar with from Programming Exercise 0) and <code>SeqTest.java</code>.</p> <p>Do NOT Edit</p> <p>You should NOT edit <code>Ex3.java</code>, <code>CoffeeQueue.java</code>, <code>CS2030STest.java</code>, or <code>SeqTest.java</code>.  However, you may change the <code>@author</code> tag of these two files if you wish.</p> <p>Additionally, if you have made changes to <code>Event.java</code>, <code>Simulation.java</code>, or <code>Simulator.java</code>, you will need to use the original file given for Programming Exercise 1 as those are not supposed to be edited.</p>"},{"location":"prog-ex/3-simulation3.html#building-on-programming-exercise-2","title":"Building on Programming Exercise 2","text":"<p>You are required to build on top of your Programming Exercise 2 submission for this exercise.</p> <p>Assuming you have <code>ex2-username</code> and <code>ex3-username</code> under the same directory, and <code>ex3-username</code> is your current working directory, you can run </p> <pre><code>username@pe111:~/ex3-username$ cp -i ../ex2-username/*.java .\nusername@pe111:~/ex3-username$ rm -i Ex2.java\n</code></pre> <p>to copy all your Java code over and remove the main file for <code>Ex2</code>.</p> <p>If you are still unfamiliar with Unix commands to navigate the file system and manage files, please review our Unix guide.</p> <p>You are encouraged to consider your tutor's feedback and fix any issues with your design for your Programming Exercise 2 submission before you embark on your Programming Exercise 3.</p>"},{"location":"prog-ex/3-simulation3.html#compiling-testing-and-debugging","title":"Compiling, Testing, and Debugging","text":""},{"location":"prog-ex/3-simulation3.html#compiling","title":"Compiling","text":"<p>To compile your code, you can compile all the Java file.</p> <pre><code>username@pe111:~/ex3-username$ javac -Xlint:unchecked -Xlint:rawtypes *.java\n</code></pre> <p>To check for style,</p> <pre><code>username@pe111:~/ex3-username$ java -jar ~cs2030s/bin/checkstyle.jar -c ex3_style.xml *.java\n</code></pre>"},{"location":"prog-ex/3-simulation3.html#running-and-testing","title":"Running and Testing","text":"<p>You may test your simulation code similarly to how you test your Programming Exercise 3.</p> <p>Note that test cases 1 to 11 set \\(l\\) to 0, so there is no barista queue.  Test cases 12 and 14 set \\(l\\) to non-zero and \\(m\\) to 0, so there is no entrance queue.  Test cases 15 and 16 test scenarios with both entrance and barista queues.</p>"},{"location":"prog-ex/3-simulation3.html#documentation-optional","title":"Documentation (Optional)","text":"<p>Documenting your code with Javadoc is optional for Programming Exercise 3.  It is, however, always a good practice to include comments to help readers understand your code.</p>"},{"location":"prog-ex/4-some.html","title":"Ex 4: Some Body Once Told Me","text":"<p>Basic Information</p> <ul> <li>Deadline: 8 October 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Caught up to Unit 27 of Lecture Notes.</li> <li>Familiar with CS2030S Java style guide.</li> </ul> <p>Goal</p> <p>The goal of this exercise is to build a simple immutable generic container.</p>"},{"location":"prog-ex/4-some.html#tasks","title":"Tasks","text":"<p>Our container is storing some value of reference type.  We shall call this container <code>Some</code>.  It is a generic wrapper class with a single type parameter <code>T</code> (i.e., <code>Some&lt;T&gt;</code>).  At the beginning, this will not be a useful container, but do not worry, we will slowly add more functionalities.</p>"},{"location":"prog-ex/4-some.html#task-1-a-simple-container","title":"Task 1: A Simple Container","text":"<p>Implement a generic class <code>Some&lt;T&gt;</code> that</p> <ul> <li>contains a field of type <code>T</code> that is declared <code>private</code> and <code>final</code> to store the content.</li> <li>overrides the <code>boolean equals(Object)</code> method from <code>Object</code> to compare if two containers are the same in the way described below.<ul> <li>Two containers are the same if the contents are equal to each other, as decided by their respective <code>equals</code> method.</li> </ul> </li> <li>overrides the <code>String toString()</code> method from <code>Object</code> so it returns the string representation of its content, between <code>[</code> and <code>]</code>.</li> <li>provides a class method called <code>some</code> that returns a container with the given object.<ul> <li>You may assume that no <code>null</code> value will be given  for now .</li> </ul> </li> </ul> <p>Factory Method</p> <p>The method <code>some</code> is called a factory method.  A factory method is a method provided by a class for the creation of an instance of the class.  Using a public constructor to create an instance necessitates calling <code>new</code> and allocating a new object on the heap every time.  A factory method, on the other hand, allows the flexibility of reusing the same instance.  The <code>some</code> method does not currently reuse instances but this will be rectified in subsequent exercise.</p> <p>With the availability of the of factory method, <code>Some&lt;T&gt;</code> should keep the constructor <code>private</code>.</p> Sample Usage<pre><code>jshell&gt; Some.&lt;Integer&gt;some(4)\n$.. ==&gt; [4]\njshell&gt; Some.some(5) // type inference!\n$.. ==&gt; [5]\n\njshell&gt; Some.some(4).equals(Some.some(4))\n$.. ==&gt; true\njshell&gt; Some.some(4).equals(4)\n$.. ==&gt; false\njshell&gt; Some.some(Some.some(0)).equals(Some.some(Some.some(0)))\n$.. ==&gt; true\njshell&gt; Some.some(Some.some(0)).equals(Some.some(0))\n$.. ==&gt; false\njshell&gt; Some.some(0).equals(Some.some(Some.some(0)))\n$.. ==&gt; false\n\njshell&gt; Some.some(\"body once told me\")\n$.. ==&gt; [body once told me]\njshell&gt; Some.some(\"4\").equals(Some.some(4))\n$.. ==&gt; false\n</code></pre> <p>You can test your <code>Some&lt;T&gt;</code> more comprehensively by running:</p> Test1.java<pre><code>username@pe111:~/ex4-username$ javac -Xlint:rawtypes -Xlint:unchecked Test1.java\nusername@pe111:~/ex4-username$ java Test1\n</code></pre> <p>There shouldn't be any compilation warning or error when you compile <code>Test1.java</code> and all tests should prints <code>ok</code>.</p>"},{"location":"prog-ex/4-some.html#task-2-transformation","title":"Task 2: Transformation","text":"<p>Now, we are going to write an interface (along with its implementations) and a method in <code>Some</code> that allows a container to be transformed into another container, possibly containing a different type.</p>"},{"location":"prog-ex/4-some.html#step-1-transformer-interface","title":"Step 1: Transformer Interface","text":"<p>First, create an interface called <code>Transformer&lt;T, U&gt;</code> with an abstract method called <code>transform</code> that takes in an argument of generic type <code>T</code> and returns a value of generic type <code>U</code>.</p>"},{"location":"prog-ex/4-some.html#part-2-mapping-method","title":"Part 2: Mapping Method","text":"<p>Second, write a method called <code>map</code> in the class <code>Some</code> that takes in a <code>Transformer</code>, and use the given <code>Transformer</code> to transform the container (and the value inside) into another container of type <code>Some&lt;U&gt;</code>. You should leave the original container unchanged.</p> Sample Usage<pre><code>jshell&gt; class AddOne implements Transformer&lt;Integer, Integer&gt; {\n   ...&gt;   @Override\n   ...&gt;   public Integer transform(Integer arg) {\n   ...&gt;     return arg + 1;\n   ...&gt;   }\n   ...&gt; }\njshell&gt; class StrLen implements Transformer&lt;String, Integer&gt; {\n   ...&gt;   @Override\n   ...&gt;   public Integer transform(String arg) {\n   ...&gt;     return arg.length();\n   ...&gt;   }\n   ...&gt; }\njshell&gt; AddOne fn1 = new AddOne()\njshell&gt; StrLen fn2 = new StrLen()\n\njshell&gt; Some.some(4).&lt;Integer&gt;map(fn1)\n$.. ==&gt; [5]\njshell&gt; Some.some(5).map(fn1)\n$.. ==&gt; [6]\n\njshell&gt; Some&lt;Number&gt; six = Some.some(4).map(fn1).map(fn1)\nsix ==&gt; [6]\njshell&gt; six.map(fn2)\n|  Error: ...\n|  six.map(fn2)\n|  ^-----^\n\njshell&gt; Some&lt;String&gt; mod = Some.some(\"CS2030S\")\nmod ==&gt; [CS2030S]\njshell&gt; mod.map(fn2)\n$.. ==&gt; [7]\njshell&gt; mod\nmod ==&gt; [CS2030S]\njshell&gt; mod.map(fn2).map(fn1)\n$.. ==&gt; [8]\n</code></pre> <p>You can test your <code>Some&lt;T&gt;</code> more comprehensively by running:</p> Test2.java<pre><code>username@pe111:~/ex4-username$ javac -Xlint:rawtypes -Xlint:unchecked Test2.java\nusername@pe111:~/ex4-username$ java Test2\n</code></pre> <p>There shouldn't be any compilation warning or error when you compile <code>Test2.java</code> and all tests should prints <code>ok</code>.</p>"},{"location":"prog-ex/4-some.html#part-3-flexible-method","title":"Part 3: Flexible Method","text":"<p>Make sure that you make the method signature as flexible as possible. Follow the PECS principle after you determine which type (i.e., <code>T</code> or <code>U</code>) acts as producer or consumer (or both?).</p> Flexible Usage<pre><code>jshell&gt; /open A.java\njshell&gt; /open B.java\njshell&gt; /open C.java\n\njshell&gt; class AtoC implements Transformer&lt;A, C&gt; {\n   ...&gt;   @Override\n   ...&gt;   public C transform(A arg) {\n   ...&gt;     return new C(arg.get());\n   ...&gt;   }\n   ...&gt; }\njshell&gt; class BtoB implements Transformer&lt;B, B&gt; {\n   ...&gt;   @Override\n   ...&gt;   public B transform(B arg) {\n   ...&gt;     return new B(arg.get());\n   ...&gt;   }\n   ...&gt; }\njshell&gt; class CtoA implements Transformer&lt;C, A&gt; {\n   ...&gt;   @Override\n   ...&gt;   public A transform(C arg) {\n   ...&gt;     return new A(arg.get());\n   ...&gt;   }\n   ...&gt; }\n\njshell&gt; Some&lt;A&gt; someA = Some.some(new A(1))\njshell&gt; Some&lt;B&gt; someB = Some.some(new B(2))\njshell&gt; Some&lt;C&gt; someC = Some.some(new C(3))\njshell&gt; AtoC fn1 = new AtoC()\njshell&gt; BtoB fn2 = new BtoB()\njshell&gt; CtoA fn3 = new CtoA()\n\njshell&gt; someA.map(fn1)\n$.. ==&gt; [C:1]\njshell&gt; someA.map(fn2)\n|  Error: ...\n|  someA.map(fn2)\n|  ^-------^\njshell&gt; someA.map(fn3)\n|  Error: ...\n|  someA.map(fn3)\n|  ^-------^\n\njshell&gt; someB.map(fn1)\n$.. ==&gt; [C:2]\njshell&gt; someB.map(fn2)\n$.. ==&gt; [B:2]\njshell&gt; someB.map(fn3)\n|  Error: ...\n|  someB.map(fn3)\n|  ^-------^\n\njshell&gt; someC.map(fn1)\n$.. ==&gt; [C:3]\njshell&gt; someC.map(fn2)\n$.. ==&gt; [B:3]\njshell&gt; someC.map(fn3)\n$.. ==&gt; [A:3]\n</code></pre> <p>You can test your <code>Some&lt;T&gt;</code> more comprehensively by running:</p> Test3.java<pre><code>username@pe111:~/ex4-username$ javac -Xlint:rawtypes -Xlint:unchecked Test3.java\nusername@pe111:~/ex4-username$ java Test3\n</code></pre> <p>There shouldn't be any compilation warning or error when you compile <code>Test3.java</code> and all tests should prints <code>ok</code>.</p>"},{"location":"prog-ex/4-some.html#task-3-jack-in-the-box","title":"Task 3: Jack in the Box","text":"<p>The <code>Transformer</code> interface allows us to transform the content of the container from one type into any other type, including a <code>Some&lt;T&gt;</code>! You have seen examples above where we have a container inside a container: <code>Some.some(Some.some(0))</code>.</p> <p>Now, implement your own <code>Transformer</code> in a class called <code>JackInTheBox&lt;T&gt;</code> to transform an item into a <code>Some</code> containing the item. The corresponding type <code>T</code> is transformed into <code>Some&lt;T&gt;</code>. This transformer, when invoked with <code>map</code>, results in a new <code>Some</code> within the <code>Some</code>.</p> Sample Usage<pre><code>jshell&gt; Some.some(4).map(new JackInTheBox&lt;&gt;())\n$.. ==&gt; [[4]]\njshell&gt; Some.some(Some.some(5)).map(new JackInTheBox&lt;&gt;())\n$.. ==&gt; [[[5]]]\n</code></pre> <p>You can test your <code>JackInTheBox&lt;T&gt;</code> more comprehensively by running:</p> Test4.java<pre><code>username@pe111:~/ex4-username$ javac -Xlint:rawtypes -Xlint:unchecked Test4.java\nusername@pe111:~/ex4-username$ java Test4\n</code></pre> <p>There shouldn't be any compilation warning or error when you compile <code>Test4.java</code> and all tests should prints <code>ok</code>.</p>"},{"location":"prog-ex/4-some.html#skeleton-for-programming-exercise-4","title":"Skeleton for Programming Exercise 4","text":"<p>A set of empty files has been given to you.  You should ONLY edit these files.  You must NOT add any additional files.</p> <p>Do NOT Add</p> <p>Only edit the given files, do not add any additional files.</p> <p>Some files (e.g., <code>Test1.java</code>, <code>A.java</code>, <code>CS2030STest.java</code>, etc) are provided for testing. You may edit them to add your own test cases, but we will be using our own version for testing.</p>"},{"location":"prog-ex/4-some.html#following-cs2030s-style-guide","title":"Following CS2030S Style Guide","text":"<p>You should make sure your code follows the given Java style guide.</p> <p>To check for style,</p> Style Check<pre><code>username@pe111:~/ex4-username$ java -jar ~cs2030s/bin/checkstyle.jar -c ex4_style.xml *.java\n</code></pre>"},{"location":"prog-ex/4-some.html#suppressing-warnings","title":"Suppressing Warnings","text":"<p>If you design your code correctly, you do not need any <code>@SuppressWarnings</code>.  If you have any, you may want to check your design again.</p>"},{"location":"prog-ex/4-some.html#further-deductions","title":"Further Deductions","text":"<p>Additional deductions may be given for other issues or errors in your code.  This include but not limited to</p> <ul> <li>run-time error.</li> <li>failure to follow instructions.</li> <li>improper designs (e.g., not following good OOP practice).</li> <li>not comenting <code>@SuppressWarnings</code>.</li> <li>misuse of <code>@SuppressWarnings</code> (e.g., not necessary, not in smallest scope, etc).</li> </ul>"},{"location":"prog-ex/4-some.html#documentation-optional","title":"Documentation (Optional)","text":"<p>Documenting your code with Javadoc is optional for Programming Exercise 4.  It is, however, always a good practice to include comments to help readers understand your code.</p>"},{"location":"prog-ex/5-maybe.html","title":"Ex 5: Call Me Maybe","text":"<p>Basic Information</p> <ul> <li>Deadline: 15 October 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605\u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Caught up to Unit 29 of Lecture Notes.</li> <li>Familiar with CS2030S Java style guide.</li> </ul> <p>Goal</p> <p>This is a continuation of Programming Exercise 4.  In Exercise 4, we have constructed a generic class <code>Some&lt;T&gt;</code>, which is a container for an item of type <code>T</code>.  Beyond being an exercise for teaching about generics, <code>Some&lt;T&gt;</code> is not a very useful type.  In Programming Exercises 5 and 6, we are going to modify <code>Some&lt;T&gt;</code> into two more useful and general classes.  We are going to build our own Java packages using these useful classes.</p>"},{"location":"prog-ex/5-maybe.html#java-package","title":"Java Package","text":"<p>Java package mechanism allows us to group relevant classes and interfaces under a namespace. You have seen two packages so far: <code>java.util</code>, where we import <code>List</code> and <code>Arrays</code> from as well as <code>java.lang</code> where we import the <code>Math</code> class.  These are provided by Java as standard libraries.  We can also create our package and put the classes and interfaces into the same package.  We (and the clients) can then import and use the classes and interfaces that we provide.</p> <p>Java package provides a higher layer of abstraction barrier.  We can designate a class to be used outside a package by prefixing the keyword <code>class</code> with the access modifier <code>public</code>.  This is another advantage of public class.  The previous advantage of a public class is that it must have the same name as the file.  So java compiler knows where to search.  We can further fine-tune which fields and methods are accessible from other classes in the same package using the <code>protected</code> access modifier.</p> <p>You can read more about java packages and the <code>protected</code> modifier yourself through Oracle's Java tutorial.</p> <p>As a summary, the access levels are as follows.</p> Modifier Access from same class Access from same package(or same directory) Access from subclass(even in other directory) Access from other class(even in other directory) <code>public</code> <code>protected</code> no modifier <code>private</code> <p>We will create a package named <code>cs2030s.fp</code> to be used for this and the next few exercises. First, we need to add the line: </p> <pre><code>package cs2030s.fp;\n</code></pre> <p>on top of every <code>.java</code> file that we would like to include in the package.</p> <p>Second, the package name is typically written in a hierarchical manner using the \".\" notation. The name also indicates the location of the <code>.java</code> files and the <code>.class</code> files.  For this reason, you can no longer store the <code>.java</code> files under <code>ex5-username</code> directly.  Instead, you should put them in a subdirectory called <code>cs2030s/fp</code> under <code>ex5-username</code>.  To start, our <code>cs2030s.fp</code> package will contain the one interface <code>Transformer</code> that you have written in Programming Exercise 4.</p> <p>If you have not made <code>Transformer</code> a <code>public</code> class, you should do it now.</p> <pre><code>public interface Transfomer&lt;T, R&gt; {\n    :\n}\n</code></pre> <p>Finally, to compile your code, under your <code>ex5-username</code> directory, run: </p> <pre><code>javac -Xlint:unchecked -Xlint:rawtypes cs2030s/fp/*.java *.java\n</code></pre> <p>Note, you may see some compilation error because the java files in <code>ex5-username</code> directory may fail to compile.  That is normal.  <code>TestN.java</code> can only compile when you finish some tasks below.  If you have set up everything correctly, you should be able to run the following in JShell from your <code>ex5-username</code> directory: </p> <pre><code>jshell&gt; import cs2030s.fp.Transformer;\n</code></pre> <p>Checkpoint</p> <p>If you have done this correctly, your directory structure should look something like the following:</p> <pre><code>labX-username/\n\u251c\u2500 cs2030s/\n\u2502  \u2514\u2500 fp/\n\u2502     \u2514\u2500 Transformer.java\n\u251c\u2500 CS2030STest.java\n\u251c\u2500 Some.java\n\u251c\u2500 Test1.java\n\u251c\u2500 Test2.java\n\u251c\u2500   :\n\u2514\u2500  ...\n</code></pre>"},{"location":"prog-ex/5-maybe.html#tasks","title":"Tasks","text":"<p>Eventually, we will be creating a static nested class <code>Some&lt;T&gt;</code> that is nested inside the <code>Maybe&lt;T&gt;</code> class. <code>Maybe&lt;T&gt;</code> encapsulates the possibility that a value is missing. Our <code>Maybe&lt;T&gt;</code> is an option type, a common abstraction in programming languages (<code>java.util.Optional</code> in Java, <code>option</code> in Scala, <code>Maybe</code> in Haskell, <code>Nullable&lt;T&gt;</code> in C#, etc) that is a wrapper around a value that might be missing.  In other words, it represents either some value, or none.</p>"},{"location":"prog-ex/5-maybe.html#task-1-more-interfaces","title":"Task 1: More Interfaces","text":"<p>Now, we are going to add three more interfaces into our package:</p> <ul> <li><code>Producer&lt;T&gt;</code> is an interface with a single <code>produce</code> method that takes in no parameter and returns a value of type <code>T</code>.</li> <li><code>Consumer&lt;T&gt;</code> is an interface with a single <code>consume</code> method that takes in a parameter of type <code>T</code> and returns nothing.</li> <li><code>BooleanCondition&lt;T&gt;</code> is an interface with a single <code>test</code> method that takes in a parameter of type <code>T</code> and returns a primitive <code>boolean</code> value.</li> </ul> <p>Checkpoint</p> <p>If you have done this correctly, your directory structure should look something like the following:</p> <pre><code>labX-username/\n\u251c\u2500 cs2030s/\n\u2502  \u2514\u2500 fp/\n\u2502     \u251c\u2500 BooleanCondition.java\n\u2502     \u251c\u2500 Consumer.java\n\u2502     \u251c\u2500 Producer.java\n\u2502     \u2514\u2500 Transformer.java\n\u251c\u2500 CS2030STest.java\n\u251c\u2500 Some.java\n\u251c\u2500 Test1.java\n\u251c\u2500 Test2.java\n\u251c\u2500   :\n\u2514\u2500  ...\n</code></pre> <p>If you have set up everything correctly, you should be able to run the following in JShell without errors (remember to always compile your code first!).</p> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.Producer;\njshell&gt; import cs2030s.fp.Consumer;\njshell&gt; import cs2030s.fp.BooleanCondition;\n\njshell&gt; Producer&lt;String&gt; p;\njshell&gt; p = new Producer&lt;&gt;() {\n   ...&gt;   public String produce() { return \"\"; }\n   ...&gt; }\njshell&gt; Consumer&lt;Boolean&gt; c;\njshell&gt; c = new Consumer&lt;&gt;() {\n   ...&gt;   public void consume(Boolean b) { }\n   ...&gt; }\njshell&gt; BooleanCondition&lt;Integer&gt; b;\njshell&gt; b = new BooleanCondition&lt;&gt;() {\n   ...&gt;   public boolean test(Integer x) { return x &gt; 0; }\n   ...&gt; }\n</code></pre>"},{"location":"prog-ex/5-maybe.html#task-2-some-packaging","title":"Task 2: Some Packaging","text":"<p>There is minimal amount of code to be added here. We will be mainly be doing a rearrangement of code.</p> <ol> <li>Copy your implementation of <code>Some.java</code> into <code>lab5-username/cs2030s/fp</code> directory if you have not done so.</li> <li>Add <code>package cs2030s.fp;</code> as the first line on <code>Some.java</code>.</li> <li> <p>Rename <code>Some.java</code> into <code>Maybe.java</code>.  This entails some other changes too:</p> <ul> <li>Rename some occurrences of <code>Some</code> into <code>Maybe</code> especially the return types.</li> <li>Do NOT change the name of the factory method <code>some</code>.</li> </ul> <p>Checkpoint</p> <p>If you have done this correctly, your directory structure should look something like the following:</p> <pre><code>labX-username/\n\u251c\u2500 cs2030s/\n\u2502  \u2514\u2500 fp/\n\u2502     \u251c\u2500 BooleanCondition.java\n\u2502     \u251c\u2500 Consumer.java\n\u2502     \u251c\u2500 Maybe.java\n\u2502     \u251c\u2500 Producer.java\n\u2502     \u2514\u2500 Transformer.java\n\u251c\u2500 CS2030STest.java\n\u251c\u2500 Test1.java\n\u251c\u2500 Test2.java\n\u251c\u2500   :\n\u2514\u2500  ...\n</code></pre> <p>Your <code>Maybe.java</code> should still contain the class <code>Some&lt;T&gt;</code>.</p> cs2030s/fp/Maybe.java<pre><code>public class Some&lt;T&gt; {\n    :\n}\n</code></pre> </li> <li> <p>Change <code>public class Some&lt;T&gt;</code> to <code>private static final class Some&lt;T&gt; extends Maybe&lt;T&gt;</code>.</p> <ul> <li>Then wrap it inside the outer class <code>public abstract class Maybe&lt;T&gt;</code>.</li> <li>Move <code>public static &lt;T&gt; Maybe&lt;T&gt; some(T value)</code> from <code>Some&lt;T&gt;</code> to <code>Maybe&lt;T&gt;</code>.</li> </ul> <p>Checkpoint</p> <p>At this point, <code>Some&lt;T&gt;</code> is a static nested class inside <code>Maybe&lt;T&gt;</code>.  But codes from outside of the package cannot see <code>Some&lt;T&gt;</code> and only <code>Maybe&lt;T&gt;</code>.  Since <code>Maybe&lt;T&gt;</code> does not have any known method, we need to add abstract methods.</p> cs2030s/fp/Maybe.java<pre><code>public abstract class Maybe&lt;T&gt; {\n    :\n  public static &lt;T&gt; Maybe&lt;T&gt; some(T value) {\n      : // implementation omitted\n  }\n\n  private static final class Some&lt;T&gt; extends Maybe&lt;T&gt; {\n      : // code from the old version of Some.java\n  }\n}\n</code></pre> </li> <li> <p>Add abstract method descriptor that appears in <code>Some&lt;T&gt;</code> to <code>Maybe&lt;T&gt;</code> unless these method descriptor already available in <code>Object</code>.</p> </li> <li> <p>Finally, we need to handle <code>null</code> values in <code>Some&lt;T&gt;</code> and <code>Maybe&lt;T&gt;</code>.</p> <ul> <li><code>public static &lt;T&gt; Maybe&lt;T&gt; some(T value)</code> accepts <code>null</code> and simply store the <code>null</code> value in the field.</li> <li>Two <code>Some&lt;T&gt;</code> instances are equal (as decided by their respective <code>equals(Object)</code> method) if either one (or both) of the following condition is true.<ul> <li>The content are both <code>null</code>.</li> <li>The content are equal as decided by their respective <code>equals(Object)</code> method.</li> </ul> </li> </ul> <p>map</p> <p>There is no need to specially handle <code>null</code> in <code>map</code>. In particular, if the <code>Transfomer</code> in <code>map</code> returns <code>null</code>, we will simply use the <code>null</code> value.</p> </li> </ol> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.Maybe\njshell&gt; import cs2030s.fp.Transformer\n\njshell&gt; Maybe&lt;Object&gt; m = new Maybe&lt;&gt;()\n|  Error:\n|  cs2030s.fp.Maybe is abstract; cannot be instantiated\n|  Maybe&lt;Object&gt; m = new Maybe&lt;&gt;();\n|                    ^-----------^\njshell&gt; Maybe.Some&lt;Object&gt; m\n|  Error:\n|  cs2030s.fp.Maybe.Some has private access in cs2030s.fp.Maybe\n|  Maybe.Some&lt;Object&gt; m;\n|  ^--------^\njshell&gt; Maybe.some(0).get()\n|  Error:\n|  cannot find symbol\n|    symbol:   method get()\n|  Maybe.some(0).get()\n|  ^---------------^\n\njshell&gt; Maybe.some(null)\n$.. ==&gt; [null]\njshell&gt; Maybe.some(4)\n$.. ==&gt; [4]\njshell&gt; Maybe.some(\"day\").equals(Maybe.some(\"day\"))\n$.. ==&gt; true\njshell&gt; Maybe.some(null).equals(Maybe.some(\"day\"))\n$.. ==&gt; false\njshell&gt; Maybe.some(null).equals(Maybe.some(null))\n$.. ==&gt; true\njshell&gt; Maybe.some(null).equals(null)\n$.. ==&gt; false\n\njshell&gt; class AddOne implements Transformer&lt;Integer, Integer&gt; {\n   ...&gt;   @Override\n   ...&gt;   public Integer transform(Integer t) {\n   ...&gt;     return t + 1;\n   ...&gt;   }\n   ...&gt; }\njshell&gt; class StrLen implements Transformer&lt;String, Integer&gt; {\n   ...&gt;   @Override\n   ...&gt;   public Integer transform(String t) {\n   ...&gt;     return t.length();\n   ...&gt;   }\n   ...&gt; }\njshell&gt; class Destroyer implements Transformer&lt;Integer, Object&gt; {\n   ...&gt;   @Override\n   ...&gt;   public Object transform(Integer t) {\n   ...&gt;     return null;\n   ...&gt;   }\n   ...&gt; }\njshell&gt; AddOne fn1 = new AddOne();\njshell&gt; StrLen fn2 = new StrLen();\njshell&gt; Destroyer fn3 = new Destroyer();\n\njshell&gt; Maybe.some(4).&lt;Integer&gt;map(fn1)\n$.. ==&gt; [5]\njshell&gt; Maybe.some(5).map(fn1)\n$.. ==&gt; [6]\njshell&gt; Maybe.some(\"CS2030S\").map(fn2)\n$.. ==&gt; [7]\njshell&gt; Maybe.some(\"CS2030S\").map(fn2).map(fn1)\n$.. ==&gt; [8]\n\njshell&gt; Maybe&lt;Number&gt; six = Maybe.some(4).map(fn1).map(fn1)\nsix ==&gt; [6]\n\njshell&gt; Maybe.some(4).map(fn3)\n$.. ==&gt; [null]\njshell&gt; Maybe.some(4).map(fn3) == Maybe.some(null)\n$.. ==&gt; false\njshell&gt; Maybe.some(4).map(fn3).equals(Maybe.some(null))\n$.. ==&gt; true\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test1.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test1.java\njava Test1\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex5_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/5-maybe.html#task-3-none-other-than-you","title":"Task 3: None Other than You","text":"<p>Now we want to add <code>None&lt;T&gt;</code> class as another private static nested class inside <code>Maybe&lt;T&gt;</code>. This class is also a subtype of <code>Maybe&lt;T&gt;</code>. The types <code>None&lt;T&gt;</code> is an internal implementation details of <code>Maybe&lt;T&gt;</code> and must not be used directly by the client. Hence, it must be declared private. Here is the requirement for <code>None&lt;T&gt;</code>.</p> <ul> <li><code>None&lt;T&gt;</code> is a generic private inner class that inherits from <code>Maybe&lt;T&gt;</code>.</li> <li><code>None&lt;T&gt;</code> has no instance field.</li> <li><code>None&lt;T&gt;</code> has private constructor that takes in no argument.</li> <li><code>None&lt;T&gt;</code> overrides the <code>equals(Object)</code> method.<ul> <li>Any instance of <code>None&lt;T&gt;</code> is equal to any other instance of <code>None&lt;T&gt;</code>.</li> <li>Note that <code>Some&lt;T&gt;</code> should never be equal to <code>None&lt;T&gt;</code>.</li> </ul> </li> <li><code>None&lt;T&gt;</code> overrides the <code>toString()</code> method.<ul> <li>It simply prints <code>[]</code>.</li> </ul> </li> <li><code>None&lt;T&gt;</code> overrides the <code>map</code> method from <code>Maybe&lt;T&gt;</code>.<ul> <li>This simply returns itself.</li> </ul> </li> <li><code>None&lt;T&gt;</code> (and by extension <code>Maybe&lt;T&gt;</code>) must be immutable up to <code>T</code>.<ul> <li>But you do not have to make the class a <code>final</code> class.</li> </ul> </li> </ul> <p>Additionally, we need to add the following factory methods in <code>Maybe&lt;T&gt;</code>.</p> <ul> <li>Add the factory method <code>none()</code> that returns an instance of <code>None&lt;T&gt;</code>.<ul> <li>There should only be ONE instance of <code>None&lt;T&gt;</code> such that multiple calls to <code>none()</code> should return the same instance.</li> <li>You may add <code>@SuppressWarnings</code> here with explanation on why it is safe.</li> </ul> </li> <li>Add the factory method <code>of</code> that returns:<ul> <li>an instance of <code>None&lt;T&gt;</code> if the input is <code>null</code>.</li> <li>an instance of <code>Some&lt;T&gt;</code> if the input is not <code>null</code>.</li> </ul> </li> </ul> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.Maybe\njshell&gt; import cs2030s.fp.Transformer\n\njshell&gt; Maybe.None m;\n|  Error:\n|  cs2030s.fp.Maybe.None has private access in cs2030s.fp.Maybe\n|  Maybe.None m;\n|  ^--------^\njshell&gt; Maybe.none().get()\n|  Error:\n|  cannot find symbol\n|    symbol:   method get()\n|  Maybe.none().get()\n|  ^--------------^\n\njshell&gt; Maybe.none()\n$.. ==&gt; []\n\njshell&gt; Maybe.none() == Maybe.none()\n$.. ==&gt; true\njshell&gt; Maybe.none().equals(Maybe.none())\n$.. ==&gt; true\njshell&gt; Maybe.none().equals(Maybe.some(\"day\"))\n$.. ==&gt; false\njshell&gt; Maybe.none().equals(Maybe.some(null))\n$.. ==&gt; false\njshell&gt; Maybe.some(null).equals(Maybe.none())\n$.. ==&gt; false\n\njshell&gt; Maybe.of(null).equals(Maybe.none())\n$.. ==&gt; true\njshell&gt; Maybe.of(null) == Maybe.none()\n$.. ==&gt; true\njshell&gt; Maybe.of(null).equals(Maybe.some(null))\n$.. ==&gt; false\njshell&gt; Maybe.of(4).equals(Maybe.none())\n$.. ==&gt; false\njshell&gt; Maybe.of(4).equals(Maybe.some(4))\n$.. ==&gt; true\n\njshell&gt; Transformer&lt;Integer, Integer&gt; incr = new Transformer&lt;&gt;() {\n   ...&gt;   @Override\n   ...&gt;   public Integer transform(Integer x) {\n   ...&gt;     return x + 1;\n   ...&gt;   }\n   ...&gt; };\njshell&gt; Maybe.&lt;Integer&gt;none().map(incr)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;Integer&gt;some(null).map(incr)\n|  Exception java.lang.NullPointerException: Cannot invoke \"java.lang.Integer.intValue()\" because \"&lt;parameter1&gt;\" is null\n|        at 1.transform (#15:4)\n|        at 1.transform (#15:1)\n|        at Maybe$Some.map (Maybe.java:62)\n|        at (#17:1)\njshell&gt; Maybe.&lt;Integer&gt;some(1).map(incr)\n$.. ==&gt; [2]\n\njshell&gt; import java.util.Map;\njshell&gt; Map&lt;String, Integer&gt; map = Map.of(\"one\", 1, \"two\", 2);\njshell&gt; Transformer&lt;String, Integer&gt; wordToInt = new Transformer&lt;&gt;() {\n   ...&gt;   @Override\n   ...&gt;   public Integer transform(String x) {\n   ...&gt;     return map.get(x);\n   ...&gt;   }\n   ...&gt; };\njshell&gt; Maybe.&lt;String&gt;none().map(wordToInt)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;String&gt;some(\"\").map(wordToInt)\n$.. ==&gt; [null]\njshell&gt; Maybe.&lt;String&gt;some(\"one\").map(wordToInt)\n$.. ==&gt; [1]\n\njshell&gt; Transformer&lt;String, Maybe&lt;Integer&gt;&gt; wordToMaybeInt = new Transformer&lt;&gt;() {\n   ...&gt;   @Override\n   ...&gt;   public Maybe&lt;Integer&gt; transform(String x) {\n   ...&gt;     return Maybe.of(map.get(x));\n   ...&gt;   }\n   ...&gt; };\njshell&gt; Maybe.&lt;String&gt;none().map(wordToMaybeInt)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;String&gt;some(\"\").map(wordToMaybeInt)\n$.. ==&gt; [[]]\njshell&gt; Maybe.&lt;String&gt;some(\"one\").map(wordToMaybeInt)\n$.. ==&gt; [[1]]\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test2.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test2.java\njava Test2\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex5_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/5-maybe.html#task-4-filtering","title":"Task 4: Filtering","text":"<p>We now add the method <code>filter</code> to <code>Maybe&lt;T&gt;</code>.</p> <ul> <li>Add the abstract method <code>filter</code> to <code>Maybe&lt;T&gt;</code> that takes in a <code>BooleanCondition&lt;..&gt;</code> (type parameter is omitted) as a parameter.</li> <li>Override the method <code>filter</code> in <code>Some&lt;T&gt;</code> as follows.<ul> <li>If the value is <code>null</code> or it failed the test (i.e., the call to <code>test</code> returns <code>false</code>), return <code>None&lt;T&gt;</code>.</li> <li>Otherwise, leaves the <code>Maybe&lt;T&gt;</code> untouched and returns the <code>Maybe&lt;T&gt;</code> as it is.</li> </ul> </li> <li>Override the method <code>filter</code> in <code>None&lt;T&gt;</code> as follows.<ul> <li>Always returns a <code>None&lt;T&gt;</code>.</li> </ul> </li> </ul> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.BooleanCondition\njshell&gt; import cs2030s.fp.Maybe\n\njshell&gt; BooleanCondition&lt;Number&gt; isEven = new BooleanCondition&lt;&gt;() {\n   ...&gt;   public boolean test(Number x) {\n   ...&gt;     return x.shortValue() % 2 == 0;\n   ...&gt;   }\n   ...&gt; };\n\njshell&gt; Maybe.&lt;Integer&gt;none().filter(isEven)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;Integer&gt;some(null).filter(isEven)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;Integer&gt;some(1).filter(isEven)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;Integer&gt;some(2).filter(isEven)\n$.. ==&gt; [2]\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test3.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test3.java\njava Test3\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex5_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/5-maybe.html#task-5-flatmap","title":"Task 5: flatMap","text":"<p>Consider a <code>Transformer</code> that might return a <code>Maybe&lt;T&gt;</code> itself (as <code>wordToMaybeInt</code> above). Using <code>map</code> on such a <code>Transformer</code> would lead to a value wrapped around a <code>Maybe</code> twice. We want to add a method that is not doing this.</p> <ul> <li>Add the abstract method <code>flatMap</code> to <code>Maybe&lt;T&gt;</code> that takes in a <code>Transfomer&lt;..&gt;</code> (type parameter is omitted) as a parameter.</li> <li>Override the method <code>flatMap</code> in <code>Some&lt;T&gt;</code> as follows.<ul> <li>The <code>Transformer</code> object transforms the value of type <code>T</code> in <code>Maybe&lt;T&gt;</code> into a value of type <code>Maybe&lt;U&gt;</code>, for some type <code>U</code>.</li> <li>The method <code>flatMap</code>, however, returns a value of type <code>Maybe&lt;U&gt;</code> (instead of <code>Maybe&lt;Maybe&lt;U&gt;&gt;</code> as in the case of <code>map</code>).</li> <li>You may add <code>@SuppressWarnings</code> here with explanation on why it is safe.</li> </ul> </li> <li>Override the method <code>flatMap</code> in <code>None&lt;T&gt;</code> as follows.<ul> <li>Always returns a <code>None&lt;T&gt;</code>.</li> </ul> </li> </ul> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.BooleanCondition\njshell&gt; import cs2030s.fp.Maybe\njshell&gt; import cs2030s.fp.Transformer\n\njshell&gt; Map&lt;String, Integer&gt; map = Map.of(\"one\", 1, \"two\", 2);\njshell&gt; Transformer&lt;String, Maybe&lt;Integer&gt;&gt; wordToMaybeInt = new Transformer&lt;&gt;() {\n   ...&gt;   @Override\n   ...&gt;   public Maybe&lt;Integer&gt; transform(String x) {\n   ...&gt;     return Maybe.of(map.get(x));\n   ...&gt;   }\n   ...&gt; };\n\njshell&gt; Maybe.&lt;String&gt;none().flatMap(wordToMaybeInt)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;String&gt;some(\"\").flatMap(wordToMaybeInt)\n$.. ==&gt; []\njshell&gt; Maybe.&lt;String&gt;some(\"one\").flatMap(wordToMaybeInt)\n$.. ==&gt; [1]\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test4.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test4.java\njava Test4\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex5_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/5-maybe.html#task-6-back-to-t","title":"Task 6: Back to T","text":"<p>Since <code>Maybe&lt;T&gt;</code> is an abstraction for a possibly missing value (of type <code>T</code>), it would be useful to provide methods that decide what to do if the value is missing.</p> <ul> <li>Add the abstract method <code>orElse</code> in <code>Maybe&lt;T&gt;</code> that takes in a <code>Producer&lt;..&gt;</code> (type parameter is omitted) as the parameter.<ul> <li>Override the method <code>orElse</code> in <code>Some&lt;T&gt;</code> to return the value inside.</li> <li>Override the method <code>orElse</code> in <code>None&lt;T&gt;</code> to return the subtype of <code>T</code> produced by the producer.</li> </ul> </li> <li>Add the abstract method <code>ifPresent</code> in <code>Maybe&lt;T&gt;</code> that takes in a <code>Consumer&lt;..&gt;</code> (type parameter is omitted) as the parameter.<ul> <li>Override the method <code>ifPresent</code> in <code>Some&lt;T&gt;</code> such that the given consumer consumes the value inside.</li> <li>Override the method <code>ifPresent</code> in <code>None&lt;T&gt;</code> that does nothing.</li> </ul> </li> </ul> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.Consumer;\njshell&gt; import cs2030s.fp.Maybe;\njshell&gt; import cs2030s.fp.Producer;\njshell&gt; import java.util.ArrayList;\njshell&gt; import java.util.List;\n\njshell&gt; Producer&lt;Double&gt; zero = new Producer&lt;&gt;() {\n   ...&gt;   @Override\n   ...&gt;   public Double produce() {\n   ...&gt;     return 0.0;\n   ...&gt;   }\n   ...&gt; };\n\njshell&gt; Maybe.&lt;Number&gt;none().orElse(zero)\n$.. ==&gt; 0.0\njshell&gt; Maybe.&lt;Number&gt;some(1).orElse(zero)\n$.. ==&gt; 1\n\njshell&gt; List&lt;Object&gt; list = new ArrayList&lt;&gt;();\njshell&gt; Consumer&lt;Object&gt; addToList = new Consumer&lt;&gt;() {\n   ...&gt;   @Override\n   ...&gt;   public void consume(Object o) {\n   ...&gt;     list.add(o);\n   ...&gt;   }\n   ...&gt; };\n\njshell&gt; Maybe.&lt;Number&gt;none().ifPresent(addToList)\n\njshell&gt; list.size()\n$.. ==&gt; 0\njshell&gt; list\nlist ==&gt; []\njshell&gt; Maybe.&lt;Number&gt;some(1).ifPresent(addToList)\njshell&gt; list.get(0)\n$.. ==&gt; 1\njshell&gt; list\nlist ==&gt; [1]\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test5.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test5.java\njava Test5\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex5_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/5-maybe.html#skeleton-for-programming-exercise-5","title":"Skeleton for Programming Exercise 5","text":"<p>You need to copy the files <code>Some.java</code> and <code>Transformer.java</code> from <code>ex4-username</code> to <code>ex5-username</code>. Some files (e.g., <code>Test1.java</code>, <code>Test2.java</code>, <code>CS2030STest.java</code>, etc) are provided for testing. Do not copy these from <code>ex4-username</code>. You may edit them to add your own test cases, but we will be using our own version for testing.</p> <p>While there is no given public test cases for it, we will test your code with hidden test cases that checks for flexible type. Additionally, minimize the number of type parameter by using wildcards. Lastly, ensure that you use <code>@SuppressWarnings</code> as needed.</p>"},{"location":"prog-ex/5-maybe.html#following-cs2030s-style-guide","title":"Following CS2030S Style Guide","text":"<p>You should make sure your code follows the given Java style guide.</p> <p>To check for style, we may need two commands as there are two directories of interest.</p> Style Check<pre><code>java -jar ~cs2030s/bin/checkstyle.jar -c ex5_style.xml *.java\njava -jar ~cs2030s/bin/checkstyle.jar -c ex5_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/5-maybe.html#further-deductions","title":"Further Deductions","text":"<p>Additional deductions may be given for other issues or errors in your code.  These deductions may now be unbounded, up to 5 marks.  This include but not limited to</p> <ul> <li>run-time error.</li> <li>failure to follow instructions.</li> <li>improper designs (e.g., not following good OOP practice).</li> <li>not comenting <code>@SuppressWarnings</code>.</li> <li>misuse of <code>@SuppressWarnings</code> (e.g., not necessary, not in smallest scope, etc).</li> </ul>"},{"location":"prog-ex/5-maybe.html#documentation-optional","title":"Documentation (Optional)","text":"<p>Documenting your code with Javadoc is optional for Programming Exercise 5.  It is, however, always a good practice to include comments to help readers understand your code.</p>"},{"location":"prog-ex/6-lazy.html","title":"Ex 6: The Art of Being Lazy","text":"<p>Basic Information</p> <ul> <li>Deadline: 22 October 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605\u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Caught up to Unit 32 of Lecture Notes.</li> <li>Familiar with CS2030S Java style guide.</li> </ul> <p>Class Files</p> <p>If you have not finished Programming Exercise 5, do not worry. We provide <code>.class</code> files for the functional interfaces as well as <code>Maybe&lt;T&gt;</code>. Note that the implementation for <code>Maybe&lt;T&gt;</code> is badly written not following OOP but it is the correct implementation.</p> <p>Additionally, the class files were compiled on PE node using Java 21 compiled. If you are not using Java 21 or if you are not working on PE node, you may get different result. It is unlikely, but the possibility is there. Please only do your work on the PE node.</p> <p>Note that since we provide only the <code>.class</code> files for <code>Maybe&lt;T&gt;</code> and the functional interfaces, you may need to compile <code>Lazy&lt;T&gt;</code> with the following command from <code>ex6-username</code> directory.</p> <pre><code>javac cs2030s/fp/Lazy.java\n</code></pre>"},{"location":"prog-ex/6-lazy.html#maybe","title":"Maybe","text":"<p>Our <code>Maybe</code> class has the following methods available.  Methods that are not available cannot be used.  You should not modify <code>Maybe</code> class. You may use the method descriptor as an inspiration for future exercises to make your method more flexible. All the methods below are <code>public</code>. No other <code>public</code> methods are available.</p> Method Description <code>static &lt;T&gt; Maybe&lt;T&gt; of</code> <code>(T val)</code> Returns a new <code>Maybe&lt;T&gt;</code> depending on the value of <code>val</code>.<ul><li>If <code>val</code> is <code>null</code> returns the singleton <code>NONE</code> without any value inside</li><li>Otherwise returns a new <code>Maybe&lt;T&gt;</code> with the content <code>val</code>.</li></ul> <code>static &lt;T&gt; Maybe&lt;T&gt; some</code> <code>(T val)</code> Returns a new <code>Maybe&lt;T&gt;</code> with the content <code>val</code> regardless if <code>val</code> is <code>null</code> or not. <code>static &lt;T&gt; Maybe&lt;T&gt; none</code> <code>(T val)</code> Returns a the singleton <code>NONE</code> without any value inside. <code>&lt;U&gt; Maybe&lt;U&gt; map</code> <code>(Transformer&lt;? super T,</code> <code>? extends U&gt; func)</code> Transform <code>this.val</code> (if any) using <code>func</code> and return a new <code>Maybe&lt;U&gt;</code>.<ul><li>If there is no <code>this.val</code> returns the singleton <code>NONE</code> without any value inside.</li><li>Otherwise return a new instance of <code>Maybe&lt;U&gt;</code> with <code>this.val</code> transformed using <code>func</code>. <code>Maybe&lt;T&gt; filter</code> <code>(BooleanCondition&lt;? super T&gt; pred)</code> Transform <code>this.val</code> (if any) depending on the result of <code>pred</code>.<ul><li>If there is no <code>this.val</code> returns the singleton <code>NONE</code> without any value inside.</li><li>If <code>this.val == null</code> returns the singleton <code>NONE</code> without any value inside.</li><li>If <code>this.val</code> evaluates to <code>false</code> when passed into<code>pred</code> returns the singleton <code>NONE</code> without any value inside.</li><li>Otherwise the current instance.</li></ul> <code>&lt;U&gt; Maybe&lt;U&gt; flatMap</code> <code>(Transformer&lt;? super T,</code> <code>? extends Maybe&lt;? extends U&gt;&gt; func)</code> Transform <code>this.val</code> (if any) using <code>func</code> and return a new <code>Maybe&lt;U&gt;</code>.<ul><li>If there is no <code>this.val</code> returns the singleton <code>NONE</code> without any value inside.</li><li>Otherwise return a new instance of <code>Maybe&lt;U&gt;</code> with <code>this.val</code> transformed using <code>func</code> but without making a nested <code>Maybe</code>. <code>T orElse</code> <code>(Producer&lt;? extends T&gt; prod)</code> Returns <code>this.val</code> (if any).<ul><li>If there is no <code>this.val</code> produce a new value using <code>prod</code>.</li><li>Otherwise <code>this.val</code>. <code>void ifPresent</code> <code>(Consumer&lt;? super T&gt; cons)</code> Consumes <code>this.val</code> (if any).<ul><li>If there is no <code>this.val</code> do nothing.</li><li>Otherwise consume <code>this.val</code> using <code>cons</code>."},{"location":"prog-ex/6-lazy.html#being-lazy","title":"Being Lazy","text":"<p>Programming languages such as Scala support lazy values, where the expression that produces a lazy value is not evaluated until the value is needed. Lazy value is useful for cases where producing the value is expensive, but the value might not eventually be used. Java, however, does not provide a similar abstraction. So, you are going to build one.</p> <p>You are required to design a single <code>Lazy&lt;T&gt;</code> class as part of the <code>cs2030s.fp</code> package with two instance fields and no class fields. You are not allowed to add additional instance/class fields to <code>Lazy&lt;T&gt;</code>.</p> <pre><code>public class Lazy&lt;T&gt; {\n  private Producer&lt;T&gt; producer;\n  private Maybe&lt;T&gt; value;\n\n   :\n}\n</code></pre> <p>While you cannot add new fields, you should make the current field more flexible whenever possible. Furthermore, in all discussion below, the method signature given may not be the most flexible. Your task is to determine if they can be made more flexible. If they can, you should use the most flexible type while minimizing the number of type parameters by using wildcards.</p>"},{"location":"prog-ex/6-lazy.html#constraints","title":"Constraints","text":"<p>You should minimize the use of conditional statements and conditional expressions. In many cases, this can be done by using the appropriate methods from <code>Maybe&lt;T&gt;</code>. You are also not allowed to have nested class within <code>Lazy&lt;T&gt;</code> to avoid conditional statements/expressions by using polymorphism.</p> <p>If you have done the design correctly, you will have no conditional statements/expressions except for the <code>boolean equals(Object)</code> method.</p> <p>The basic idea is that we can match the concept of <code>None&lt;T&gt;</code> to a lazy value that is not yet computed and the concept of <code>Some&lt;T&gt;</code> to a lazy value that is already computed. The proper name for this is that they are isomorphic.</p>"},{"location":"prog-ex/6-lazy.html#tasks","title":"Tasks","text":""},{"location":"prog-ex/6-lazy.html#task-1-basic","title":"Task 1: Basic","text":"<p>Define a generic <code>Lazy</code> class to encapsulate a value with the following operations:</p> <ul> <li><code>static of(T v)</code> method that initializes the <code>Lazy</code> object with the given value.</li> <li><code>static of(Producer&lt;T&gt; s)</code> method that takes in a producer that produces the value when needed.</li> <li><code>get()</code> method that is called when the value is needed. If the value is already available, return that value; otherwise, compute the value and return it. The computation should only be done once for the same value.</li> <li><code>toString()</code>: returns <code>\"?\"</code> if the value is not yet available; returns the string representation of the value otherwise.<ul> <li>You are encouraged to use <code>String.valueOf(obj)</code> instead of <code>obj.toString()</code> to avoid runtime error when <code>obj</code> is <code>null</code>.</li> </ul> </li> </ul> <p>Immutable?</p> <p>For our <code>Lazy&lt;T&gt;</code> to be immutable and to make the memoization of the value transparent, <code>toString</code> should call <code>get()</code> and should never return <code>\"?\"</code>. We break the rules of immutability and encapsulation here, just so that it is easier to debug and test the laziness of your implementation.</p> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.Producer\njshell&gt; import cs2030s.fp.Lazy\n\njshell&gt; Lazy&lt;Integer&gt; eight = Lazy.of(8)\njshell&gt; eight\neight ==&gt; 8\njshell&gt; eight.get()\n$.. ==&gt; 8\n\njshell&gt; Producer&lt;String&gt; s = () -&gt; \"hello\"\njshell&gt; Lazy&lt;Object&gt; hello = Lazy.of(s)\njshell&gt; Lazy&lt;String&gt; hello = Lazy.of(s)\njshell&gt; hello\nhello ==&gt; ?\njshell&gt; hello.get()\n$.. ==&gt; \"hello\"\n\njshell&gt; s = () -&gt; { System.out.println(\"world!\"); return \"hello\"; }\njshell&gt; Lazy&lt;String&gt; hello = Lazy.of(s)\njshell&gt; hello\nhello ==&gt; ?\njshell&gt; hello.get()\nworld!\n$.. ==&gt; \"hello\"\n\njshell&gt; // check that \"world!\" should not be printed again.\njshell&gt; hello.get()\n$.. ==&gt; \"hello\"\n\njshell&gt; Random rng = new Random(1)\njshell&gt; Producer&lt;Integer&gt; r = () -&gt; rng.nextInt()\njshell&gt; Lazy&lt;Integer&gt; random = Lazy.of(r)\n\njshell&gt; // check that random value should not be available\njshell&gt; random\nrandom ==&gt; ?\n\njshell&gt; // check that random value is obtained only once\njshell&gt; random.get().equals(random.get())\n$.. ==&gt; true\n\njshell&gt; // should handle null\njshell&gt; Lazy&lt;Object&gt; n = Lazy.of((Object)null)\njshell&gt; n.toString()\n$.. ==&gt; \"null\"\njshell&gt; n.get()\n$.. ==&gt; null\n\njshell&gt; Lazy&lt;Integer&gt; n = Lazy.of((Producer&lt;Integer&gt;)() -&gt; null)\njshell&gt; n\nn ==&gt; ?\njshell&gt; n.get()\n$.. ==&gt; null\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test1.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test1.java\njava Test1\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex6_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/6-lazy.html#task-2-map-and-flatmap","title":"Task 2: Map and FlatMap","text":"<p>Now let's add the <code>map</code> and <code>flatMap</code> method. Remember that <code>Lazy</code> should not evaluate anything until <code>get()</code> is called, so the function <code>f</code> passed into <code>Lazy</code> through <code>map</code> and <code>flatMap</code> should not be evaluated until <code>get()</code> is called. Furthermore, they should be evaluated once. That result from <code>map</code> and <code>flatMap</code>, once evaluated, should be cached (also called memoized), so that function must not be called again.</p> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.Lazy\njshell&gt; import cs2030s.fp.Producer\njshell&gt; import cs2030s.fp.Transformer\n\njshell&gt; Producer&lt;String&gt; s = () -&gt; \"123456\"\njshell&gt; Lazy&lt;String&gt; lazy = Lazy.of(s)\njshell&gt; lazy.map(str -&gt; str.substring(0, 1))\n$.. ==&gt; ?\njshell&gt; lazy\n$.. ==&gt; ?\njshell&gt; lazy.map(str -&gt; str.substring(0, 1)).get()\n$.. ==&gt; \"1\"\njshell&gt; lazy.get()\n$.. ==&gt; \"123456\"\n\njshell&gt; Transformer&lt;String, String&gt; substr = str -&gt; {\n   ...&gt;   System.out.println(\"substring\");\n   ...&gt;   return str.substring(0, 1);\n   ...&gt; }\njshell&gt; lazy = lazy.map(substr)\njshell&gt; lazy.get()\nsubstring\n$.. ==&gt; \"1\"\njshell&gt; lazy.get()\n$.. ==&gt; \"1\"\n\njshell&gt; Lazy&lt;Integer&gt; lazy = Lazy.of(10)\njshell&gt; lazy = lazy.map(i -&gt; i + 1)\njshell&gt; lazy = lazy.flatMap(j -&gt; Lazy.of(j + 3))\njshell&gt; lazy\nlazy ==&gt; ?\njshell&gt; lazy.get()\n$.. ==&gt; 14\njshell&gt; lazy\nlazy ==&gt; 14\n\njshell&gt; Transformer&lt;Object, Integer&gt; hash = x -&gt; x.hashCode();\njshell&gt; Lazy&lt;Number&gt; lazy = Lazy.&lt;String&gt;of(\"sunday\").map(hash);\njshell&gt; Transformer&lt;Object, Lazy&lt;Integer&gt;&gt; hash = x -&gt; Lazy.&lt;Integer&gt;of(x.hashCode());\njshell&gt; Lazy&lt;Number&gt; lazy = Lazy.&lt;String&gt;of(\"sunday\").flatMap(hash);\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test2.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test2.java\njava Test2\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex6_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/6-lazy.html#task-3-filter-and-equality","title":"Task 3: Filter and Equality","text":"<p>Write a <code>filter</code> method, which takes in a <code>BooleanCondition</code> and lazily tests if the value passes the test or not. Returns a <code>Lazy&lt;Boolean&gt;</code> object. The <code>BooleanCondition</code> must be executed at most once.</p> <p>Then write an <code>equals</code>, which overrides the <code>equals</code> method in the <code>Object</code> class. <code>equals</code> is an eager operation that causes the values to be evaluated (if not already cached). <code>equals</code> should return <code>true</code> only if both objects being compared are <code>Lazy</code> and the value contains within are equals (according to their <code>equals()</code> methods).</p> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.Lazy\n\njshell&gt; Lazy&lt;Integer&gt; fifty = Lazy.of(50)\njshell&gt; Lazy&lt;Boolean&gt; even = fifty.filter(i -&gt; i % 2 == 0)\njshell&gt; even\neven ==&gt; ?\njshell&gt; even.get()\n$.. ==&gt; true\njshell&gt; even\neven ==&gt; true\n\njshell&gt; // equals\njshell&gt; fifty.equals(Lazy.of(5).map(i -&gt; i * 10))\n$.. ==&gt; true\njshell&gt; fifty.equals(50)\n$.. ==&gt; false\njshell&gt; fifty.equals(Lazy.of(\"50\"))\n$.. ==&gt; false\njshell&gt; even.equals(Lazy.of(true))\n$.. ==&gt; true\n\njshell&gt; BooleanCondition&lt;String&gt; isHello = s -&gt; {\n   ...&gt;   System.out.println(s);\n   ...&gt;   return s.equals(\"hello\");\n   ...&gt; }\njshell&gt; Lazy&lt;Boolean&gt; same = Lazy.of(\"hi\").filter(isHello)\njshell&gt; same\nsame ==&gt; ?\njshell&gt; same.get()\nhi\n$.. ==&gt; false\njshell&gt; same.get()\n$.. ==&gt; false\n\njshell&gt; BooleanCondition&lt;Object&gt; alwaysFalse = s -&gt; false\njshell&gt; Lazy&lt;Boolean&gt; same = Lazy.&lt;String&gt;of(\"hi\").filter(alwaysFalse)\n\njshell&gt; Producer&lt;String&gt; producer = () -&gt; \"123456\";\njshell&gt; Lazy&lt;String&gt; oneToSix = Lazy.of(producer);\njshell&gt; oneToSix.toString();\n$.. ==&gt; ?\njshell&gt; oneToSix == oneToSix\n$.. ==&gt; true\njshell&gt; oneToSix.toString();\n$.. ==&gt; ?\njshell&gt; oneToSix.equals(oneToSix)\n$.. ==&gt; true\njshell&gt; oneToSix.toString();\n$.. ==&gt; 123456\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test3.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test3.java\njava Test3\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex6_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/6-lazy.html#task-4-combine","title":"Task 4: Combine","text":"<p>We have provided an interface called <code>Combiner&lt;S, T, R&gt;</code> in <code>cs2030s.fp</code>, with a single <code>combine</code> method to combine two values, of type <code>S</code> and <code>T</code> respectively, into a result of type <code>R</code>.</p> <p>Add a method called <code>combine</code> into <code>Lazy</code>. The <code>combine</code> method takes in another <code>Lazy</code> object and a <code>Combiner</code> implementation to lazily combine the two Lazy objects (which may contain values of different types) and return a new <code>Lazy</code> object.</p> <pre><code>jshell&gt; import cs2030s.fp.Lazy\njshell&gt; Lazy&lt;Integer&gt; five, ten, fifty, hundred\njshell&gt; ten = Lazy.of(10)\njshell&gt; five = Lazy.of(5)\njshell&gt; // combine (same types)\njshell&gt; Combiner&lt;Integer, Integer, Integer&gt; add = (x, y) -&gt; {\n   ...&gt;   System.out.println(\"combine\");\n   ...&gt;   return x + y;\n   ...&gt; }\njshell&gt; fifty = five.combine(ten, (x, y) -&gt; x * y)\njshell&gt; fifty\nfifty ==&gt; ?\njshell&gt; hundred = fifty.combine(fifty, add)\njshell&gt; hundred\nhundred ==&gt; ?\njshell&gt; // combine (different types)\njshell&gt; Combiner&lt;Integer,Double,String&gt; f = (x, y) -&gt; Integer.toString(x) + \" \" + Double.toString(y)\njshell&gt; Lazy&lt;String&gt; s = Lazy.of(10).combine(Lazy.of(0.01), f)\njshell&gt; s\ns ==&gt; ?\njshell&gt; s.get()\n$.. ==&gt; \"10 0.01\"\n\njshell&gt; Combiner&lt;Object,Object,Integer&gt; f = (x, y) -&gt; x.hashCode() + y.hashCode()\njshell&gt; Lazy&lt;Number&gt; n = Lazy.&lt;String&gt;of(\"hello\").combine(Lazy.&lt;Integer&gt;of(123), f);\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test4.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test4.java\njava Test4\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex6_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/6-lazy.html#skeleton-for-programming-exercise-5","title":"Skeleton for Programming Exercise 5","text":"<p>We provide <code>.class</code> files for the functional interfaces as well as <code>Maybe&lt;T&gt;</code>. There are also template files for <code>Lazy.java</code> and <code>Combiner.java</code> in <code>cs2030s/fp</code> directory. Some files (e.g., <code>Test1.java</code>, <code>Test2.java</code>, <code>CS2030STest.java</code>, etc) are provided for testing. You may edit them to add your own test cases, but we will be using our own version for testing.</p> <p>While there is no given public test cases for it, we will test your code with hidden test cases that checks for flexible type. Additionally, minimize the number of type parameter by using wildcards. Lastly, ensure that you use <code>@SuppressWarnings</code> as needed.</p>"},{"location":"prog-ex/6-lazy.html#following-cs2030s-style-guide","title":"Following CS2030S Style Guide","text":"<p>You should make sure your code follows the given Java style guide.</p>"},{"location":"prog-ex/6-lazy.html#further-deductions","title":"Further Deductions","text":"<p>Additional deductions may be given for other issues or errors in your code.  These deductions may now be unbounded, up to 5 marks.  This include but not limited to</p> <ul> <li>run-time error.</li> <li>failure to follow instructions.</li> <li>improper designs (e.g., not following good OOP practice).</li> <li>not comenting <code>@SuppressWarnings</code>.</li> <li>misuse of <code>@SuppressWarnings</code> (e.g., not necessary, not in smallest scope, etc).</li> </ul>"},{"location":"prog-ex/6-lazy.html#documentation-optional","title":"Documentation (Optional)","text":"<p>Documenting your code with Javadoc is optional for Programming Exercise 6.  It is, however, always a good practice to include comments to help readers understand your code.</p>"},{"location":"prog-ex/7-infinity.html","title":"Ex 7: To Infinity and Beyond","text":"<p>Basic Information</p> <ul> <li>Deadline: 29 October 2024, Tuesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605\u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Caught up to Unit 33 of Lecture Notes.</li> <li>Familiar with CS2030S Java style guide.</li> </ul> <p>Class Files</p> <p>If you have not finished Programming Exercise 5 and 6, do not worry. We provide <code>.class</code> files for the functional interfaces as well as <code>Maybe&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code>. Note that the implementation for <code>Maybe&lt;T&gt;</code> is badly written not following OOP but it is the correct implementation.</p> <p>Additionally, the class files were compiled on PE node using Java 21 compiled. If you are not using Java 21 or if you are not working on PE node, you may get different result. It is unlikely, but the possibility is there. Please only do your work on the PE node.</p> <p>You are required to use the given <code>.class</code> files as we will be using our version during testing. In other words, you are not allowed to add methods not specified by Ex 5 and Ex 6.</p>"},{"location":"prog-ex/7-infinity.html#maybe-class","title":"Maybe Class","text":"<p>The class <code>Maybe&lt;T&gt;</code> has the following <code>public</code> methods.  You cannot use any methods that are not <code>public</code> from outside the package.</p> Method Description <code>static &lt;T&gt; Maybe&lt;T&gt; of(T val)</code> Creates a <code>Maybe&lt;T&gt;</code> with the given content <code>val</code> if <code>val</code> is not <code>null</code>.  Otherwise, returns the shared instance of <code>None&lt;?&gt;</code>. <code>static &lt;T&gt; Maybe&lt;T&gt; some(T val)</code> Creates a <code>Maybe&lt;T&gt;</code> with the given content <code>val</code> which may be <code>null</code>. <code>static &lt;T&gt; Maybe&lt;T&gt; none()</code> Creates a <code>Maybe&lt;T&gt;</code> without any content, this is guaranteed to return the shared instance of <code>None&lt;?&gt;</code>. <code>String toString()</code> Returns the string representation of <code>Maybe&lt;T&gt;</code>. <code>boolean equals(Object obj)</code> <ul><li><code>Maybe&lt;T&gt;</code>: Returns <code>true</code> if the content is equal to the content of <code>obj</code>.  Otherwise returns <code>false</code>.</li><li><code>None&lt;T&gt;</code>: Returns <code>true</code> if <code>obj</code> is also <code>None&lt;T&gt;</code>.  Otherwise returns <code>false</code>.</li></ul> <code>&lt;U&gt; Maybe&lt;U&gt; map</code><code>(Transformer&lt;? super T, ? extends U&gt; fn)</code> <ul><li><code>Maybe&lt;T&gt;</code>: Create a new instance of <code>Maybe&lt;T&gt;</code> by applying the transformer <code>fn</code> to the content and wrapping it in <code>Maybe&lt;T&gt;</code>. It will never return <code>None&lt;T&gt;</code> to allow for our <code>InfiniteList&lt;T&gt;</code> to contain <code>null</code>.</li><li><code>None&lt;T&gt;</code>: Returns <code>None&lt;T&gt;</code>.</li></ul> <code>Maybe&lt;T&gt; filter</code><code>(BooleanCondition&lt;? super T&gt; pred)</code> <ul><li><code>Maybe&lt;T&gt;</code>: If the content is not <code>null</code> and <code>pred.test(content)</code> returns <code>true</code>, we return the current instance.  Otherwise, returns <code>None&lt;T&gt;</code>.</li><li><code>None&lt;T&gt;</code>: Returns <code>None&lt;T&gt;</code>.</li></ul> <code>&lt;U&gt; Maybe&lt;U&gt; flatmap</code><code>(Transformer&lt;? super T, ? extends Maybe&lt;? extends U&gt;&gt; fn)</code> <ul><li><code>Maybe&lt;T&gt;</code>: Create a new instance of <code>Maybe&lt;T&gt;</code> by applying the transformer <code>fn</code> to the content without wrapping it in <code>Maybe&lt;T&gt;</code> as <code>fn</code> already returns <code>Maybe&lt;U&gt;</code>.</li><li><code>None&lt;T&gt;</code>: Returns <code>None&lt;T&gt;</code>.</li></ul> <code>T orElse(Producer&lt;? extends T&gt; prod)</code> <ul><li><code>Maybe&lt;T&gt;</code>: Returns the content (even if it is <code>null</code>).</li><li><code>None&lt;T&gt;</code>: Returns the value produced by the producer <code>prod</code>.</li></ul> <code>void ifPresent(Consumer&lt;? super T&gt; cons)</code> <ul><li><code>Maybe&lt;T&gt;</code>: Pass the content to the consumer <code>cons</code>.</li><li><code>None&lt;T&gt;</code>: Do nothing.</li></ul>"},{"location":"prog-ex/7-infinity.html#lazy-class","title":"Lazy Class","text":"<p>The class <code>Lazy&lt;T&gt;</code> has the following <code>public</code> methods.  You cannot use any methods that are not <code>public</code> from outside the package.</p> Method Description <code>static &lt;T&gt; Lazy&lt;T&gt; of(T val)</code> Creates a <code>Lazy&lt;T&gt;</code> with the given content <code>val</code> already evaluated. <code>static &lt;T&gt; Lazy&lt;T&gt; of(Producer&lt;? extends T&gt; prod)</code> Creates a <code>Lazy&lt;T&gt;</code> with the content not yet evaluated and will be evaluated using the given producer. <code>boolean equals(Object obj)</code> Returns <code>true</code> if the content is equal to the content of <code>obj</code>.  Otherwise returns <code>false</code>.  This forces evaluation of the content. <code>&lt;U&gt; Lazy&lt;U&gt; map</code><code>(Transformer&lt;? super T, ? extends U&gt; fn)</code> Lazily maps the content using the given transformer. <code>Lazy&lt;Boolean&gt; filter</code><code>(BooleanCondition&lt;? super T&gt; pred)</code> Lazily test if the value passes the test or not and returns a <code>Lazy&lt;Boolean&gt;</code> to indicate the result. <code>&lt;U&gt; Lazy&lt;U&gt; flatMap</code><code>(Transformer&lt;? super T, ? extends Lazy&lt;? extends U&gt;&gt; fn)</code> Lazily creates a new instance of <code>Lazy&lt;T&gt;</code> by applying the transformer <code>fn</code> to the content without wrapping it in another <code>Lazy&lt;..&gt;</code>. <code>&lt;U, V&gt; Lazy&lt;V&gt; combine</code><code>(Lazy&lt;? extends U&gt; lazy, Combiner&lt;? super T, ? super U, ? extends V&gt; fn)</code> Combine <code>this</code> with <code>lazy</code> using <code>Combiner</code> by invoking <code>fn.combine(this.get(), lazy.get())</code>.  Then we wrap the result back in <code>Lazy</code>. <code>T get()</code> Evaluates (if not yet evaluated, otherwise do not evaluate again) and returns the content."},{"location":"prog-ex/7-infinity.html#infinity","title":"Infinity","text":"<p>This is a follow-up from Ex 6. In Ex 6, we have constructed a generic class <code>Lazy&lt;T&gt;</code> using <code>Maybe&lt;T&gt;</code>. Now we are going to combine them into a <code>Lazy&lt;Maybe&lt;T&gt;&gt;</code> to build an infinite list. We need the <code>Lazy&lt;..&gt;</code> because we want our infinite list to be lazily evaluated. We need the <code>Maybe&lt;T&gt;</code> because the value may be present or may be missing due to <code>filter</code>. Recap that in the lecture notes we use the <code>null</code> value to indicate missing values because:</p> <ol> <li>We need a value that all possible generic type <code>T</code> has.</li> <li>We need a value that indicates a value should not be included.</li> </ol> <p>The only solution was to use <code>null</code> because there is no other value that satisfies these two conditions. Of course, it will be better if we have a second <code>null</code> value (maybe we call it <code>None</code> like in Python, heeeyyy wait a minute, that's our <code>None&lt;T&gt;</code>) to indicate this, but unfortunately we do not have such value. That is why we need to use <code>Maybe&lt;T&gt;</code>.</p> <p>Please make sure you are familiar with <code>Maybe&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code> before proceeding. You do not have to know the implementation but you should understand the expected behavior.</p>"},{"location":"prog-ex/7-infinity.html#constraints","title":"Constraints","text":"<p>We will recap some of the constraints for our labs so far.</p> <ul> <li>You are NOT allowed to use raw types.</li> <li><code>@SuppressWarnings</code> must be used responsibly, in the smallest scope, and commented.</li> </ul> <p>Additionally, you have the following constraints for this lab.</p> <ul> <li>You are NOT allowed to use <code>java.util.stream.Stream</code>.</li> <li>You are NOT allowed to add new classes (nested or otherwise).</li> <li>You are NOT allowed to add new methods in the <code>InfiniteList</code> (not even private methods).</li> <li>You are NOT allowed to use conditional statement (e.g., <code>if</code>-<code>else</code>) or conditional expression (e.g., <code>?:</code> operator).<ul> <li>Unless otherwise stated.</li> </ul> </li> <li>You are NOT allowed to use loops (e.g., <code>while</code>-loop or <code>for</code>-loop).<ul> <li>You may, however, use recursion (but possibly without conditionals).</li> </ul> </li> <li>There must only be a single instance of <code>Sentinel</code>.</li> </ul>"},{"location":"prog-ex/7-infinity.html#relaxation","title":"Relaxation","text":"<p>As a relaxtaion, the type signature in the templates are already the most flexible types. You have suffered enough thinking about more flexible type in the past two labs. The focus here is about laziness.</p>"},{"location":"prog-ex/7-infinity.html#basic","title":"Basic","text":"<p>You are already given most of the implementations including <code>head()</code>, <code>tail()</code>, <code>map(..)</code>, and <code>filter(..)</code>.  Please study them carefully.  Additionally, to help with debugging, a <code>toString()</code> has already been provided for you.  Lastly, there are three factory methods for <code>InfiniteList</code>, namely <code>generate(..)</code>, <code>iterate(..)</code>, and <code>sentinel()</code>.  The last one creates an empty list.</p> <p>As we also want to limit our infinite list to a potentially finite list, we have provided the <code>Sentinel</code> class.  This class is rather straightforward as it overrides all of the methods in <code>InfiniteList&lt;T&gt;</code>.  However, in most cases, it simply returns itself (through the use of <code>InfiniteList.&lt;Object&gt;sentinel()</code>) or throw an exception.</p> <p>You can test the initial implementation by running <code>Test0A.java</code> to <code>Test0C.java</code>.</p> <pre><code>$ javac -Xlint:rawtypes cs2030s/fp/*java\n$ javac -Xlint:rawtypes Test0A.java\n$ javac -Xlint:rawtypes Test0B.java\n$ javac -Xlint:rawtypes Test0C.java\n$ java Test0A\n$ java Test0B\n$ java Test0C\n</code></pre>"},{"location":"prog-ex/7-infinity.html#tasks","title":"Tasks","text":"<p>Time Complexity</p> <p>In all of the tasks below, you do not have to worry too much about time complexity especially if you are taking or have taken CS2040. There may not be an \\(O(n)\\) solution and you may have to find an \\(O(n^2)\\) solution instead.</p>"},{"location":"prog-ex/7-infinity.html#task-1-limit","title":"Task 1: Limit","text":"<p>The <code>Sentinel</code> class is not only an indication of an empty list but because our idea of an <code>InfiniteList</code> is the value (or value wrapped in <code>Lazy</code> and <code>Maybe</code>, i.e., the head) and the rest of the list (which is another <code>InfiniteList</code>), an empty list is also an indicator for the end of the list.  Given a <code>Sentinel</code>, we can now write two methods:</p> <ol> <li>Implement the method <code>InfiniteList&lt;T&gt; limit(long n)</code> in <code>InfiniteList</code>.<ul> <li>The method takes in a number <code>n</code>.</li> <li>The method returns a new <code>InfiniteList</code> that is lazily computed which is the truncation of the <code>InfiniteList</code> to a finite list with at most <code>n</code> elements.</li> <li>The method should not count the elements that are filtered out by <code>filter</code> (if any).</li> <li>The method is allowed to use conditional statement/expression.</li> </ul> </li> <li>Override the method <code>InfiniteList&lt;T&gt; limit(long n)</code> in <code>Sentinel</code>.<ul> <li>The method takes in a number <code>n</code>.</li> <li>Determine the appropriate behaviour for this.</li> </ul> </li> </ol> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.BooleanCondition\njshell&gt; import cs2030s.fp.InfiniteList\njshell&gt; import cs2030s.fp.Transformer\njshell&gt; import cs2030s.fp.Producer\n\njshell&gt; InfiniteList.sentinel().limit(4).isSentinel()\n$.. ==&gt; true\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(0).isSentinel()\n$.. ==&gt; true\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(1).isSentinel()\n$.. ==&gt; false\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(10).isSentinel()\n$.. ==&gt; false\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(-1).isSentinel()\n$.. ==&gt; true\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(0).isSentinel()\n$.. ==&gt; true\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(1).isSentinel()\n$.. ==&gt; false\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(10).isSentinel()\n$.. ==&gt; false\n\njshell&gt; InfiniteList.generate(() -&gt; 1).limit(4)\n$.. ==&gt; [? ?]\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(4)\n$.. ==&gt; [[1] ?]\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(1).head()\n$.. ==&gt; 1\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(4).head()\n$.. ==&gt; 1\n\njshell&gt; &lt;T&gt; T run(Producer&lt;T&gt; p) {\n   ...&gt;   try {\n   ...&gt;     return p.produce();\n   ...&gt;   } catch (Exception e) {\n   ...&gt;     System.out.println(e);\n   ...&gt;     return null;\n   ...&gt;   }\n   ...&gt; }\n\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(1).tail().head());\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(0).head()); \njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(4).tail().tail().head());\n$.. ==&gt; 3\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(4).limit(1).tail().head());\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(1).limit(4).tail().head());\njava.util.NoSuchElementException\n$.. ==&gt; null\n\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).filter(x -&gt; x % 2 == 0).limit(0).head());\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).filter(x -&gt; x % 2 == 0).limit(1).head());\n$.. ==&gt; 2\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(1).filter(x -&gt; x % 2 == 0).head());\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(2).filter(x -&gt; x % 2 == 0).head());\n$.. ==&gt; 2\n\njshell&gt; run(() -&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").limit(2).map(s -&gt; s.length()).head());\n$.. ==&gt; 1\njshell&gt; run(() -&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").limit(2).map(s -&gt; s.length()).tail().head());\n$.. ==&gt; 2\njshell&gt; run(() -&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").limit(2).map(s -&gt; s.length()).tail().tail().head());\njava.util.NoSuchElementException\n$.. ==&gt; null\n\njshell&gt; run(() -&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").map(s -&gt; s.length()).limit(2).head());\n$.. ==&gt; 1\njshell&gt; run(() -&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").map(s -&gt; s.length()).limit(2).tail().head());\n$.. ==&gt; 2\njshell&gt; run(() -&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").map(s -&gt; s.length()).limit(2).tail().tail().head());\njava.util.NoSuchElementException\n$.. ==&gt; null\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test1.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test1.java\njava Test1\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex7_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/7-infinity.html#task-2-to-list","title":"Task 2: To List","text":"<ol> <li>Implement the method <code>List&lt;T&gt; toList()</code> in <code>InfiniteList</code>.<ul> <li>The method takes in no parameter.</li> <li>The method returns a new <code>List&lt;T&gt;</code> (should really just be <code>ArrayList&lt;T&gt;</code>) which is a collection elements of the <code>InfiniteList</code> in the same order as they appear in the <code>InfiniteList</code>.</li> </ul> </li> <li>Override the method <code>InfiniteList&lt;T&gt; toList()</code> in <code>Sentinel</code>.<ul> <li>The method takes in no parameter.</li> <li>Determine the appropriate behaviour for this.</li> </ul> </li> </ol> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.BooleanCondition\njshell&gt; import cs2030s.fp.InfiniteList\njshell&gt; import cs2030s.fp.Transformer\njshell&gt; import cs2030s.fp.Producer\n\njshell&gt; &lt;T&gt; T run(Producer&lt;T&gt; p) {\n   ...&gt;   try {\n   ...&gt;     return p.produce();\n   ...&gt;   } catch (Exception e) {\n   ...&gt;     System.out.println(e);\n   ...&gt;     return null;\n   ...&gt;   }\n   ...&gt; }\n\njshell&gt; Transformer&lt;Integer, Integer&gt; incr = x -&gt; x + 1;\njshell&gt; BooleanCondition&lt;Integer&gt; isEven = x -&gt; (x % 2 == 0);\n\njshell&gt; InfiniteList.&lt;String&gt;sentinel().toList()\n$.. ==&gt; []\njshell&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").map(s -&gt; s.length()).limit(2).toList()\n$.. ==&gt; [1, 2]\njshell&gt; InfiniteList.iterate(\"A\", s -&gt; s + \"Z\").limit(2).map(s -&gt; s.length()).toList()\n$.. ==&gt; [1, 2]\njshell&gt; InfiniteList.iterate(1, incr).limit(2).filter(isEven).toList()\n$.. ==&gt; [2]\njshell&gt; InfiniteList.iterate(1, incr).filter(isEven).limit(2).toList()\n$.. ==&gt; [2, 4]\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(10).limit(3).toList()\n$.. ==&gt; [1, 2, 3]\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).limit(3).limit(10).toList()\n$.. ==&gt; [1, 2, 3]\njshell&gt; InfiniteList.generate(() -&gt; 4).limit(0).toList()\n$.. ==&gt; []\njshell&gt; InfiniteList.generate(() -&gt; 4).limit(2).toList()\n$.. ==&gt; [4, 4]\njshell&gt; InfiniteList.iterate(0, x -&gt; x + 1).filter(x -&gt; x &gt; 10).map(x -&gt; x.hashCode() % 30).filter(x -&gt; x &lt; 20).limit(5).toList()\n$.. ==&gt; [11, 12, 13, 14, 15]\n\njshell&gt; java.util.Random rng = new java.util.Random(1);\n\njshell&gt; InfiniteList.generate(() -&gt; rng.nextInt() % 100).filter(x -&gt; x &gt; 10).limit(4).toList()\n$.. ==&gt; [76, 95, 26, 69]\njshell&gt; InfiniteList.&lt;Object&gt;generate(() -&gt; null).limit(4).limit(1).toList()\n$.. ==&gt; [null]\njshell&gt; InfiniteList.&lt;Object&gt;generate(() -&gt; null).limit(1).limit(4).toList()\n$.. ==&gt; [null]\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test2.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test2.java\njava Test2\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex7_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/7-infinity.html#task-3-it-takes-a-while","title":"Task 3: It Takes a While","text":"<p>Now we want to implement the <code>takeWhile</code> method.</p> <ol> <li>Implement the method <code>InfiniteList&lt;T&gt; takeWhile(BooleanCondition&lt;? super T&gt; pred)</code> in <code>InfiniteList</code>.<ul> <li>The method takes in a <code>BooleanCondition</code>.</li> <li>The method returns an <code>InfiniteList</code> that is a truncated version of the initial <code>InfiniteList</code>.<ul> <li>The method truncates the infinite list as soon as it finds an element that evaluates the condition to <code>false</code>.</li> </ul> </li> <li>The method is allowed to use conditional statement/expression.</li> </ul> </li> <li>Override the method <code>InfiniteList&lt;T&gt; takeWhile(BooleanCondition&lt;? super T&gt; pred)</code> in <code>Sentinel</code>.<ul> <li>The method takes in a <code>BooleanCondition</code>.</li> <li>Determine the appropriate behaviour for this.</li> </ul> </li> </ol> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.InfiniteList;\njshell&gt; import cs2030s.fp.Transformer;\njshell&gt; import cs2030s.fp.Producer;\njshell&gt; import cs2030s.fp.BooleanCondition;\n\njshell&gt; Transformer&lt;Integer, Integer&gt; incr = x -&gt; { \n   ...&gt;   System.out.println(\"    iterate: \" + x);\n   ...&gt;   return x + 1;\n   ...&gt; };\njshell&gt; BooleanCondition&lt;Integer&gt; lessThan0 = x -&gt; { \n   ...&gt;   System.out.println(\"    takeWhile x &lt; 0: \" + x);\n   ...&gt;   return x &lt; 0;\n   ...&gt; };\njshell&gt; BooleanCondition&lt;Integer&gt; lessThan2 = x -&gt; { \n   ...&gt;   System.out.println(\"    takeWhile x &lt; 2: \" + x);\n   ...&gt;   return x &lt; 2;\n   ...&gt; };\njshell&gt; BooleanCondition&lt;Integer&gt; lessThan5 = x -&gt; { \n   ...&gt;   System.out.println(\"    takeWhile x &lt; 5: \" + x);\n   ...&gt;   return x &lt; 5;\n   ...&gt; };\njshell&gt; BooleanCondition&lt;Integer&gt; lessThan10 = x -&gt; { \n   ...&gt;   System.out.println(\"    takeWhile x &lt; 10: \" + x);\n   ...&gt;   return x &lt; 10;\n   ...&gt; };\njshell&gt; BooleanCondition&lt;Integer&gt; isEven = x -&gt; { \n   ...&gt;   System.out.println(\"    filter x % 2 == 0: \" + x);\n   ...&gt;   return x % 2 == 0;\n   ...&gt; };\n\njshell&gt; &lt;T&gt; T run(Producer&lt;T&gt; p) {\n   ...&gt;   try {\n   ...&gt;     return p.produce();\n   ...&gt;   } catch (Exception e) {\n   ...&gt;     System.out.println(e);\n   ...&gt;     return null;\n   ...&gt;   }\n   ...&gt; }\n\njshell&gt; InfiniteList.&lt;Integer&gt;sentinel().takeWhile(lessThan0).isSentinel()\n$.. ==&gt; true\njshell&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan0).isSentinel()\n$.. ==&gt; false\njshell&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan2).isSentinel()\n$.. ==&gt; false\njshell&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan5).takeWhile(lessThan2).toList()\n    takeWhile x &lt; 5: 1\n    takeWhile x &lt; 2: 1\n    iterate: 1\n    takeWhile x &lt; 5: 2\n    takeWhile x &lt; 2: 2\n$.. ==&gt; [1]\njshell&gt; InfiniteList.iterate(1, incr).filter(isEven).takeWhile(lessThan10).toList()\n    filter x % 2 == 0: 1\n    iterate: 1\n    filter x % 2 == 0: 2\n    takeWhile x &lt; 10: 2\n    iterate: 2\n    filter x % 2 == 0: 3\n    iterate: 3\n    filter x % 2 == 0: 4\n    takeWhile x &lt; 10: 4\n    iterate: 4\n    filter x % 2 == 0: 5\n    iterate: 5\n    filter x % 2 == 0: 6\n    takeWhile x &lt; 10: 6\n    iterate: 6\n    filter x % 2 == 0: 7\n    iterate: 7\n    filter x % 2 == 0: 8\n    takeWhile x &lt; 10: 8\n    iterate: 8\n    filter x % 2 == 0: 9\n    iterate: 9\n    filter x % 2 == 0: 10\n    takeWhile x &lt; 10: 10\n$.. ==&gt; [2, 4, 6, 8]\n\njshell&gt; run(() -&gt; InfiniteList.generate(() -&gt; 2).takeWhile(lessThan0));\n$.. ==&gt; [? ?]\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan0));\n$.. ==&gt; [? ?]\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan0).head());\n    takeWhile x &lt; 0: 1\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan2).head());\n    takeWhile x &lt; 2: 1\n$.. ==&gt; 1\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan2).tail().head());\n    takeWhile x &lt; 2: 1\n    iterate: 1\n    takeWhile x &lt; 2: 2\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan2).takeWhile(lessThan0).head());\n    takeWhile x &lt; 2: 1\n    takeWhile x &lt; 0: 1\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan0).takeWhile(lessThan2).head());\n    takeWhile x &lt; 0: 1\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).takeWhile(lessThan5).takeWhile(lessThan2).tail().head());\n    takeWhile x &lt; 5: 1\n    takeWhile x &lt; 2: 1\n    iterate: 1\n    takeWhile x &lt; 5: 2\n    takeWhile x &lt; 2: 2\njava.util.NoSuchElementException\n$.. ==&gt; null\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).filter(isEven).takeWhile(lessThan10).head());\n    filter x % 2 == 0: 1\n    iterate: 1\n    filter x % 2 == 0: 2\n    takeWhile x &lt; 10: 2\n$.. ==&gt; 2\njshell&gt; run(() -&gt; InfiniteList.iterate(1, incr).filter(isEven).takeWhile(lessThan10).tail().head());\n    filter x % 2 == 0: 1\n    iterate: 1\n    filter x % 2 == 0: 2\n    takeWhile x &lt; 10: 2\n    iterate: 2\n    filter x % 2 == 0: 3\n    iterate: 3\n    filter x % 2 == 0: 4\n    takeWhile x &lt; 10: 4\n$.. ==&gt; 4\n\njshell&gt; InfiniteList&lt;Integer&gt; list = InfiniteList.iterate(1, incr).takeWhile(lessThan10)\n\njshell&gt; list.tail().tail().head()\n    takeWhile x &lt; 10: 1\n    iterate: 1\n    takeWhile x &lt; 10: 2\n    iterate: 2\n    takeWhile x &lt; 10: 3\n$.. ==&gt; 3\njshell&gt; list.head()\n$.. ==&gt; 1\njshell&gt; list\nlist ==&gt; [[1] [[2] [[3] ?]]]\n\njshell&gt; list.tail().head()\n$.. ==&gt; 2\njshell&gt; list.tail().tail().tail().head()\n    iterate: 3\n    takeWhile x &lt; 10: 4\n$.. ==&gt; 4\njshell&gt; list\nlist ==&gt; [[1] [[2] [[3] [[4] ?]]]]\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test3.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test3.java\njava Test3\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex7_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/7-infinity.html#task-4-folding-it-right","title":"Task 4: Folding it Right","text":"<p>In the lecture, we discuss about the behaviour of <code>reduce</code> method of <code>Stream</code>.  <code>reduce</code> is actually equivalent to fold left.  In a fold left, given a list <code>[v1, v2, v3, v4]</code>, an initial value <code>e</code> and the operation <code>+</code>, the operation performed is as follows:</p> <p><code>(((e + v1) + v2) + v3) + v4</code></p> <p>What we want is the opposite.  We want to do a fold but from the right.  In a fold left, given a list <code>[v1, v2, v3, v4]</code>, an initial value <code>e</code> and the operation <code>+</code>, the operation performed is as follows:</p> <p><code>(v1 + (v2 + (v3 + (v4 + e))))</code></p> <p>Since the order of operations are different, the result may potentially be different.  For <code>+</code>, these two are going to produce the same result.  But for <code>-</code>, the result will be different.  Note that this is a terminal operation in Java stream.</p> <ol> <li>Implement the method <code>&lt;U&gt; U foldRight(U id, Combiner&lt;? super T, U, U&gt; acc)</code> in <code>InfiniteList</code>.<ul> <li>The method takes in the initial value <code>id</code> and an accumulator <code>acc</code>.<ul> <li>Note that <code>Combiner&lt;T, S, R&gt;</code> is a new interface with the implementation given in <code>cs2030s/fp/Combiner.java</code>.</li> <li>It has a single abstract method <code>R combine(T arg1, S arg2)</code>.</li> </ul> </li> <li>The method returns the result of fold right of type <code>U</code> performed on the <code>InfiniteList</code> with the given accumulator <code>acc</code> starting from the initial value <code>id</code>.<ul> <li>Note that the name <code>id</code> is used as typically the initial value is the identity operation of the accumulator.</li> </ul> </li> </ul> </li> <li>Override the method <code>&lt;U&gt; U foldRight(U id, Combiner&lt;? super T, U, U&gt; acc)</code> in <code>Sentinel</code>.<ul> <li>The method takes in the initial value <code>id</code> and an accumulator <code>acc</code>.</li> <li>Determine the appropriate behaviour for this.</li> </ul> </li> </ol> Sample Usage<pre><code>jshell&gt; import cs2030s.fp.InfiniteList;\n\njshell&gt; InfiniteList.&lt;Integer&gt;sentinel().foldRight(0, (x, y) -&gt; x + y)\n$.. ==&gt; 0\njshell&gt; InfiniteList.iterate(0, x -&gt; x + 1).limit(5).foldRight(0, (x, y) -&gt; x + y)\n$.. ==&gt; 10\njshell&gt; InfiniteList.iterate(0, x -&gt; x + 1).limit(0).foldRight(0, (x, y) -&gt; x + y)\n$.. ==&gt; 0\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).map(x -&gt; x * x).limit(5).foldRight(1, (x, y) -&gt; x * y)\n$.. ==&gt; 14400\njshell&gt; InfiniteList.iterate(1, x -&gt; x + 1).map(x -&gt; x * x).limit(5).foldRight(1, (x, y) -&gt; x - y)\n$.. ==&gt; 14\njshell&gt; // the above is equivalent to (1 - (4 - (9 - (16 - (25 - 1)))))\n</code></pre> <p>You can test this more comprehensively by running without compilation warning/error and all tests printing <code>ok</code>. Make sure your code follows the CS2030S Java style.</p> Test4.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Test4.java\njava Test4\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex7_style.xml cs2030s/fp/*.java\n</code></pre>"},{"location":"prog-ex/7-infinity.html#task-5-documenting-your-code","title":"Task 5: Documenting Your Code","text":"<p>Now that we are beginning to build our own package that others can use, we should start to produce documentation on our code.</p> <p>From Ex 7 onwards, you are required to document your classes and methods with Javadoc comments. You have seen examples from the skeleton code earlier exercises. For more details, see the JavaDoc guide. The checkstyle tool now checks for JavaDoc-related style as well.</p> <p>For Ex 7, you should write javadoc documentation for all methods in <code>InfiniteList.java</code>. Documenting the code your wrote previously for Ex 5 and Ex 6 are encouraged but optional. Your task is to document the remaining methods.  We have provided some documentations on some of the codes as example.  You should also double-check that the provided documentations satisfies the style guide.</p> JavaDoc<pre><code>$ javac cs2030s/fp/InfiniteList.java\n$ javadoc -quiet -private -d docs cs2030s/fp/InfiniteList.java\n</code></pre>"},{"location":"prog-ex/7-infinity.html#following-cs2030s-style-guide","title":"Following CS2030S Style Guide","text":"<p>You should make sure your code follows the given Java style guide.</p>"},{"location":"prog-ex/7-infinity.html#further-deductions","title":"Further Deductions","text":"<p>Additional deductions may be given for other issues or errors in your code.  These deductions may now be unbounded, up to 5 marks.  This include but not limited to</p> <ul> <li>run-time error.</li> <li>failure to follow instructions.</li> <li>improper designs (e.g., not following good OOP practice).</li> <li>not comenting <code>@SuppressWarnings</code>.</li> <li>misuse of <code>@SuppressWarnings</code> (e.g., not necessary, not in smallest scope, etc).</li> </ul>"},{"location":"prog-ex/8-future.html","title":"Ex 8: Welcome to the Future","text":"<p>Basic Information</p> <ul> <li>Deadline: 13 November 2024, Wednesday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Caught up to Unit 39 of Lecture Notes.</li> <li>Familiar with CS2030S Java style guide.</li> </ul> <p>Source</p> <p>You are given a <code>.class</code> file called <code>Source.class</code>. This is the source of data. It has a built-in busy-waiting operations that will purposefully delay computation of otherwise simple operations. Such busy-waiting operations simulate extensive computation.</p> <p>This <code>Source.class</code> file is compiled on PE node using Java 21. It may not work with other version of Java. In case you lost the <code>Source.class</code> file, we have created a directory called <code>Pristine</code> to store a copy of the <code>Source.class</code> file.</p> <p>To ensure fair comparison between parallel and sequential computation, we let the busy-waiting to be deterministic for each run. Do not rely on this as they are not deterministic across different runs.</p> <p>Wednesday</p> <p>As the deadline is Wednesday, you may not have received your feedback during your lab session.</p>"},{"location":"prog-ex/8-future.html#preliminary","title":"Preliminary","text":"<p>The rental data <code>Rent.csv</code> shows the state of housing rental in Singapore. The data is composed of 4 rows.</p> Town Block Type Rent The town name The block name Unit type Monthlu rental price <p>While we actually have the entire data from 2021, we restrict this to only January of 2023. Otherwise we will be dealing with millions of rows. In fact, two towns are simplified even further to only contain a small number of blocks.</p> <p>They are <code>\"BISHAN\"</code> and <code>\"QUEENSTOWN\"</code>. Most town have over 10000 rental units with over 100 blocks. As such, running them may take minutes if not hours. These two are simplified so that we can easily check for correctness.</p> <p>Restriction</p> <p>You are not allowed to modify the <code>import</code>. As such, you are only allowed to use <code>CompletableFuture</code> to solve this. You are also not allowed to use parallel stream.</p> <p>Additionally, you are not allowed to modify the following. We will use our version during testing.</p> <ul> <li><code>Rent.csv</code>: Some of our computation may be order specific.<ul> <li>If you wish to understand the data, we recommend making a copy and analyze the copied data.</li> </ul> </li> <li><code>RentData.java</code>: This file is given so you understand the details of the row.<ul> <li>The class file <code>Source.class</code> is compiled with the original <code>RentData.java</code>. Changes to the <code>RentData.java</code> may cause <code>Source</code>.class to throw unexpected error.</li> </ul> </li> <li><code>Sequential.java</code>: The class is given as a reference for a sequential computation.<ul> <li>The content is copied to <code>Parallel.java</code>.</li> <li>Your task is to modify <code>Parallel.java</code> to utilize asynchronous computation.</li> </ul> </li> <li><code>Computation.java</code>: This is simply an abstract class to make <code>Timing.java</code> simpler.</li> </ul> <p>Note, you may use loop.</p>"},{"location":"prog-ex/8-future.html#computation","title":"Computation","text":"<p>The computation to be performed is as follows:</p> <ol> <li>Get the name of the town.</li> <li>Given the name of the town, find all the blocks available within the town.<ul> <li>This is done by <code>this.source.findBlock(town)</code>.</li> <li>The available blocks within the town is returned as a <code>String[]</code>.</li> </ul> </li> <li>For each block, find all the unit type within the block and within the town. This is the <code>static</code> method called <code>processBlock</code>.<ul> <li>This is done by <code>this.source.findTypeInBlock(town, block)</code>.</li> <li>The available unit types is returned as a <code>String[]</code>.</li> </ul> </li> <li>For each type, find the minimum price.<ul> <li>This is done by <code>this.source.findMinPrice(town, block, type)</code>.</li> <li>The minimum price for the given unit type within the given block and within the given town is returned as an <code>int</code>.</li> </ul> </li> </ol>"},{"location":"prog-ex/8-future.html#tasks","title":"Tasks","text":"<p>Speedup</p> <p>While we do not worry about efficiency, we want to have a reasonable speedup. Testing on PE node, we manage to get at least 350% speedup. Try to get at least 350% speedup on PE node. Otherwise, penalty  may be given.</p>"},{"location":"prog-ex/8-future.html#task-1-asynchronous-computation","title":"Task 1: Asynchronous Computation","text":"<p>The following methods can be rather expensive to compute.</p> <ul> <li><code>String[] Source::findBlock(String town)</code></li> <li><code>String[] Source::findTypeInBlock(String town, String block)</code></li> <li><code>int Source::findMinPrice(String town, String block, String type)</code></li> </ul> <p>The given program runs the computation synchronously. Whenever possible they should be run asynchronously. Your task is to make both <code>processBlock</code> and run methods asynchronous. Note that <code>processBlock</code> is private so you are allowed to modify the return type as you deem fit.</p> <p>The general idea in making the program asynchronous is to utilize <code>CompletableFuture</code>. You are to make both methods above asynchronous using <code>CompletableFuture</code>. You may add some private method to simplify your work that returns a <code>CompletableFuture</code>. With <code>CompletableFuture</code>, you simply have to take care of the task dependency.</p> <p>However, note that the print order should remain the same regardless of how the concurrency is executed. You must ensure that in the end, the print order is the same as the original sequential computation.</p> <p>Some complication that you may encounter is that the number of blocks within the town as well as the number of unit types within the blocks cannot be known in advanced. So you cannot know how many <code>CompletableFuture</code> is needed. As such, you may need a collection of <code>CompletableFuture</code>.</p> <p>Then, in the case you need to wait for all of the <code>CompletableFuture</code> to finish, remember that the method signature is</p> <pre><code>static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs);\n</code></pre> <p>But if you do not know how many <code>CompletableFutures</code> are there, how can you write the code? What else can the method above accepts?</p> test.sh<pre><code>javac -Xlint:rawtypes -Xlint:unchecked *.java\nbash test.sh Parallel\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex8_style.xml Parallel.java\n</code></pre> Timing.java<pre><code>javac -Xlint:rawtypes -Xlint:unchecked Timing.java\njava Timing\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex8_style.xml Parallel.java\n</code></pre>"},{"location":"prog-ex/8-future.html#following-cs2030s-style-guide","title":"Following CS2030S Style Guide","text":"<p>You should make sure your code follows the given Java style guide.</p>"},{"location":"prog-ex/8-future.html#further-deductions","title":"Further Deductions","text":"<p>Additional deductions may be given for other issues or errors in your code.  These deductions may now be unbounded, up to 5 marks.  This include but not limited to</p> <ul> <li>run-time error.</li> <li>failure to follow instructions.</li> <li>improper designs (e.g., not following good OOP practice).</li> <li>not comenting <code>@SuppressWarnings</code>.</li> <li>misuse of <code>@SuppressWarnings</code> (e.g., not necessary, not in smallest scope, etc).</li> </ul>"},{"location":"prog-ex/9-parallel.html","title":"Ex 9: Parallel Universe","text":"<p>Basic Information</p> <ul> <li>Deadline: 21 November 2024, Thursday, 23:59 SGT</li> <li>Difficulty: \u2605\u2605\u2605\u2605\u2605\u2605</li> </ul> <p>Prerequisite</p> <ul> <li>Caught up to Unit 40 of Lecture Notes.</li> <li>Familiar with CS2030S Java style guide.</li> </ul>"},{"location":"prog-ex/9-parallel.html#tasks","title":"Tasks","text":"<p>Speedup</p> <p>While we do not worry about efficiency, we want to have a reasonable speedup. Testing on PE node, we manage to get at least 250% speedup. Try to get at least 250% speedup on PE node. Otherwise, penalty  may be given.</p>"},{"location":"prog-ex/9-parallel.html#task-1-matrix-multiplication","title":"Task 1: Matrix Multiplication","text":"<p>Matrix multiplication is a fundamental operation with many applications in physics, engineering, mathematics, and computer science. Given a matrix \\(A_{n \\times m}\\) of \\(n\\) rows and \\(m\\) columns together with a matrix \\(B_{m \\times p}\\) of \\(m\\) rows and \\(p\\) columns, the matrix product \\(C_{n \\times p}\\) is also written as \\(A \\times B\\) is a matrix such that each element \\(c_{i,j}\\) is given by the following formula:</p> <p>\\(c_{i,j} = \\displaystyle{\\sum^{m}_{k=1} (a_{i,k} \\cdot b_{k,j})}\\)</p> <p>Here we use the \\(\\cdot\\) in \\((a_{i,k} \\cdot b_{k,j})\\) to mean numerical multiplication and not matrix multiplication.</p> <p>Our interest is only square matrix. We also want to parallelize the multiplication. There is a famour divide-and-conquer algorithm for matrix multiplication. The way we can do this is by partitioning the matrix into 4 quadrants.</p> <p>For instance, we can partition a matrix \\(A\\) into 4 quadrants called \\(A_{1,1}\\), \\(A_{1,2}\\), \\(A_{2,1}\\), and \\(A_{2,2}\\). Each of these are quadrants can be thought of as a smaller matrix. We can do the same for matrix \\(B\\).</p> \\[A = \\begin{vmatrix} A_{1,1} &amp; A_{1,2} \\\\ A_{2,1} &amp; A_{2,2} \\end{vmatrix} \\ \\ \\ \\ \\ \\ B = \\begin{vmatrix} B_{1,1} &amp; B_{1,2} \\\\ B_{2,1} &amp; B_{2,2} \\end{vmatrix}\\] <p>We can now construct a matrix \\(C = A \\times B\\) that are also broken up into 4 quadrants as follows. </p> \\[C = \\begin{vmatrix} C_{1,1} &amp; C_{1,2} \\\\ C_{2,1} &amp; C_{2,2} \\end{vmatrix} = \\begin{vmatrix} A_{1,1} &amp; A_{1,2} \\\\ A_{2,1} &amp; A_{2,2} \\end{vmatrix} \\times \\begin{vmatrix} B_{1,1} &amp; B_{1,2} \\\\ B_{2,1} &amp; B_{2,2} \\end{vmatrix} = \\begin{vmatrix} (A_{1,1} \\times B_{1,1}) + (A_{1,2} \\times B_{2,1}) &amp; (A_{1,1} \\times B_{1,2}) + (A_{1,2} \\times B_{2,2}) \\\\ (A_{2,1} \\times B_{1,1}) + (A_{2,2} \\times B_{2,1}) &amp; (A_{2,1} \\times B_{1,2}) + (A_{2,2} \\times B_{2,2}) \\end{vmatrix}\\] <p>And here is the recursion, \\((A_{1,1} \\times B_{1,1})\\) is matrix multiplications. Similarly, the \\(+\\) in \\((A_{1,1} \\times B_{1,1}) + (A_{1,2} \\times B_{2,1})\\) is matrix addition. We have given you the code for recursive and non-recursive matrix multiplication. You may choose to study them to understand what they are doing, but you may choose to simply convert them by following the technique from the problem set. Additionally, we have provided a simple <code>Matrix</code> class. Just for this exercise, you do not have to worry about OOP design.</p> <p>What you need to do here is to implement the divide-and-conquer algorithm using <code>RecursiveTask&lt;Matrix&gt;</code>. For simplicity, we will be using only square matrix with size of \\(2^{n}\\) for \\(n\\) up to 11. You do not have to worry how we will run with such large numbers, just make sure you do not create unnecessary data.</p> <p>The method you need to modify is the <code>MatrixMultiplication::compute()</code> method. Currently, it is only doing recursive matrix multiplication. As a starting point, you should copy the implementation of recursive matrix multiplication into <code>MatrixMultiplication::compute()</code>. Change all recursive call into a call to <code>MatrixMultiplication::compute()</code> appropriately before converting them to <code>fork()</code> and <code>join()</code>.</p> <p>At some point, non-recursive multiplication will be faster. But you need to determine the threshold size for which non-recursive multiplication is better than even parallel multiplication. This is encoded in the static field <code>FORK_THRESHOLD</code>. As <code>FORK_THRESHOLD</code> depends on the operating system and processor architecture used, we will test the run on PE node. So ensure that you get a good parallelism on PE node.</p> test.sh<pre><code>javac -Xlint:rawtypes -Xlint:unchecked *.java\nbash test.sh Ex9a\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex9_style.xml Parallel.java\n</code></pre>"},{"location":"prog-ex/9-parallel.html#task-2-parallel-encode","title":"Task 2: Parallel Encode","text":"<p>Consider a sequence of element</p> <pre><code>[A A A B B A A A A C A A A A]\n</code></pre> <p>Here, <code>A</code>, <code>B</code>, and <code>C</code> can be any type. We can encode the sequence into something more compact by recording the number of consecutive equal element together with the element. We say that two elements <code>x</code> and <code>y</code> are equal if <code>x.equals(y)</code> returns <code>true</code>.</p> <p>Givne this, the sequence above can be split into several consecutive segment. The consecutive segment can then be encoded into encoded segment which is a pair.</p> Consecutive Segment Encoded Segment <code>A A A</code> <code>(A, 3)</code> <code>B B</code> <code>(B, 2)</code> <code>A A A A</code> <code>(A, 4)</code> <code>C</code> <code>(C, 1)</code> <code>A A A A</code> <code>(A, 4)</code> <p>Each element is now a pair. So the run-length encoding is</p> <pre><code>[(A, 3), (B, 2), (A, 4), (C, 1), (A, 4)]\n</code></pre> <p>What you need to do here is to use parallel stream to solve this problem using <code>reduce</code>. For simplicity, you need not write fully in functional-style. In particular, you may use blocks <code>() -&gt; { .. }</code> as your lambda expression. However, you must satisfy the following restrictions.</p> <p>Restrictions</p> <ul> <li>You must only have a single statement in <code>Streaming::reduce</code>.  This statement should be a <code>return stream.reduce(...)</code> statement.</li> <li>You are not allowed to add additional <code>import</code>.</li> <li>The <code>stream</code> must remain parallel at the end (i.e., you cannot invoke <code>sequential</code>).</li> </ul> test.sh<pre><code>javac -Xlint:rawtypes -Xlint:unchecked *.java\nbash test.sh Ex9b\n$ java -jar ~cs2030s/bin/checkstyle.jar -c ex9_style.xml Streaming.java\n</code></pre>"},{"location":"prog-ex/9-parallel.html#following-cs2030s-style-guide","title":"Following CS2030S Style Guide","text":"<p>You should make sure your code follows the given Java style guide.</p>"},{"location":"prog-ex/9-parallel.html#further-deductions","title":"Further Deductions","text":"<p>Additional deductions may be given for other issues or errors in your code.  These deductions may now be unbounded, up to 5 marks.  This include but not limited to</p> <ul> <li>run-time error.</li> <li>failure to follow instructions.</li> <li>improper designs (e.g., not following good OOP practice).</li> <li>not comenting <code>@SuppressWarnings</code>.</li> <li>misuse of <code>@SuppressWarnings</code> (e.g., not necessary, not in smallest scope, etc).</li> </ul>"},{"location":"unix/index.html","title":"Index","text":""},{"location":"unix/index.html#using-unix-cli","title":"Using Unix CLI","text":"<ul> <li>Background and Philosophy of Unix</li> <li>Essential Unix Commands</li> <li>Advanced Unix Commands</li> </ul>"},{"location":"unix/advanced.html","title":"Unix CLI: Advanced","text":"<p>This article is adapted from the notes of the Unix@Home Workshop  held in August 2020.  </p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>appreciate the philosophy of Unix where small utility programs can be composed together to perform a complex task using the pipe <code>|</code> operator.</li> <li>be aware of basic Unix utilities: <code>echo</code>, <code>sort</code>, <code>uniq</code>, <code>grep</code>, <code>head</code>, and <code>tail</code>.</li> <li>be able to use basic pattern matching <code>*</code> <code>?</code> <code>[]</code> and <code>{}</code> in <code>bash</code>.</li> <li>know how to use Tab, Ctrl+P, and Ctrl+N to work more efficiently in <code>bash</code>.</li> <li>know how to save time and effort by automating long complex commands using <code>bash</code> scripts.</li> </ul>"},{"location":"unix/advanced.html#composing-programs-with","title":"Composing Programs with <code>|</code>","text":"<p>Another key innovation of Unix that led to its success is the invention of the <code>|</code> operator.  </p> <p>Before Unix, operating systems tend to provide complex, monolithic, programs.  The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task.  These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs.</p> <p>The composition of these utility programs relies on two things.  First, plain text is often used as input and output of the programs.  These allow the programs to understand each other easily.  Second, they use <code>|</code> to communicate with each other.  The <code>|</code> operator takes the standard output from one program and redirects it as the standard input of another program.</p> <p>For instance, <pre><code>$ cat test.txt | wc\n       1      11      64\n</code></pre> compose <code>cat</code> and <code>wc</code> together.  Recall that <code>cat</code> reads the content of the file and prints it to standard output.  Here, we pipe the standard output from <code>cat</code> to <code>wc</code>.  So now, these printed texts are redirected as the standard input to <code>wc</code>.</p> <p>But this is just the same as <pre><code>$ wc &lt; test.txt\n</code></pre> that we have seen before.  What's the power in <code>|</code>?  </p> <p>Now, recall that we have made copies of <code>test.txt</code> earlier, into <code>foo.txt</code> and <code>bar.txt</code>.  If you have not done so or have removed them, you can quickly reproduce the files with: <pre><code>$ cp test.txt foo.txt\n$ cp test.txt bar.txt\n</code></pre></p> <p>Let's suppose now I want to count the total number of words for all three files.  Instead of calling <code>wc</code> on each file one by one, and sum them up myself.  I can just run:</p> <pre><code>$ cat test.txt foo.txt bar.txt | wc\n       3      33     192\n</code></pre> <p>Here, <code>cat</code> reads the three files, concatenates their content, and passes the output to <code>wc</code> for counting.</p>"},{"location":"unix/advanced.html#useful-utilities","title":"Useful Utilities","text":"<p>Before we see more interesting examples of using <code>|</code>, let's move beyond <code>cat</code> and <code>wc</code>, and see what other simple tools are there in Unix.</p>"},{"location":"unix/advanced.html#head-and-tail","title":"<code>head</code> and <code>tail</code>","text":"<p><code>head</code> and <code>tail</code> print out the first \\(k\\) lines and last \\(k\\) lines from a file (or standard input if the file name is not given).  By default, \\(k\\) is 10, but you can pass in an argument to specify \\(k\\).</p> <pre><code>$ cat test.txt foo.txt bar.txt\nThis is a test file for learning Unix file management commands.\nThis is a test file for learning Unix file management commands.\nThis is a test file for learning Unix file management commands.\n$ cat test.txt foo.txt bar.txt | tail -1\nThis is a test file for learning Unix file management commands.\n</code></pre>"},{"location":"unix/advanced.html#echo","title":"<code>echo</code>","text":"<p><code>echo</code> simply prints out the command-line argument to the standard output.</p> <pre><code>$ echo \"hello world!\"\nhello world!\n</code></pre>"},{"location":"unix/advanced.html#sort","title":"<code>sort</code>","text":"<p><code>sort</code> rearrange the input lines in alphabetical order. <pre><code>$ sort\njohn\njane\npeter\nmary^D\njane\njohn\nmary\npeter\n</code></pre></p> <p>In the example above, I entered <code>john</code>, <code>jane</code>, <code>peter</code>, <code>mary</code> followed by Ctrl+D to signify the end of input.  <code>sort</code> prints out <code>jane</code>, <code>john</code>, <code>mary</code>, <code>peter</code>, in that order.</p>"},{"location":"unix/advanced.html#uniq","title":"<code>uniq</code>","text":"<p><code>uniq</code> remove any two consecutive lines that are the same.</p> <pre><code>$ uniq\n1\n2\n2\n2\n1\n1^D\n1\n2\n1\n</code></pre> <p>For instance, in the above, there are three consecutive lines of <code>2</code>, so only one remained.  There are also two consecutive lines of <code>1</code>, so only one remained.`</p>"},{"location":"unix/advanced.html#grep","title":"<code>grep</code>","text":"<p><code>grep</code> returns the lines of text from the given file (or the standard input) that matches the given string.  For instance, run</p> <pre><code>$ grep abc\n</code></pre> <p>and start typing in some lines of text, some containing <code>abc</code>, some do not.  <code>grep</code> will spew out into the standard output all the lines that contain the text <code>abc</code> somewhere.  As usual, hit Ctrl+D when you are done.</p>"},{"location":"unix/advanced.html#pipe-example","title":"Pipe Example","text":"<p>To give you an example of how useful <code>|</code> is, here is a real example.  When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than once.  I need a quick way to count how many unique registrants are there. So I keep the student ID of all registrants in a file called <code>ID</code>.  For instance, the file <code>ID</code> contains (not real data, of course)</p> <pre><code>A1234567X,CS\nA1234559A,CEG\nA1239999J,CEG\nA1234580K,CEG\nA1233210O,CS\nA1234567X,CS\nA1234581Q,ISC\nA1233216T,ISC\nA1239999J,CEG\n</code></pre> <p>Now, to count how many unique registrants, I just need to run:</p> <pre><code>$ cat ID | sort | uniq | wc -l\n    7\n</code></pre> <p>To count how many uniq registrants are <code>CEG</code> students, I just change it to: <pre><code>$ cat ID | sort | uniq | grep CEG | wc -l\n    3\n</code></pre></p>"},{"location":"unix/advanced.html#pattern-matching-in-bash","title":"Pattern Matching in <code>bash</code>","text":"<p>We now show you another productivity shortcut.  In an example earlier, you have seen how we passed in more than one file name into <code>cat</code>.  Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way.</p> <p>Instead of <pre><code>$ cat test.txt foo.txt bar.txt | wc\n</code></pre></p> <p>We could just run <pre><code>$ cat *.txt | wc\n</code></pre></p> <p>The <code>*</code> is a special character in <code>bash</code> that represents 0 or more characters.  So, this command essentially says, <code>cat</code> any files that contain 0 or more characters, followed by <code>.txt</code>.</p> <p>The table below summarizes the useful patterns:</p> Pattern Matches <code>*</code> 0 or more characters <code>?</code> one character <code>[..]</code> one character, coming from the given set between <code>[</code> and <code>]</code>, <code>-</code> to indicate a range. <code>{.., ..}</code> Either one of the names, separated by <code>,</code>."},{"location":"unix/advanced.html#example-1","title":"Example 1:","text":"<pre><code>$ ls ???.txt\nbar.txt foo.txt\n</code></pre> <p>Since we use three <code>?</code>, it matches any file name with three characters followed by <code>.txt</code>.</p>"},{"location":"unix/advanced.html#example-2","title":"Example 2:","text":"<pre><code>$ ls [f-t]*t\nfoo.txt test.txt\n</code></pre> <p>The expression <code>[f-t]*t</code> matches all file names that start with the alphabet <code>f</code>, <code>g</code>, etc., until <code>t</code>, followed by zero or more characters, followed by <code>t</code>.</p>"},{"location":"unix/advanced.html#example-3","title":"Example 3:","text":"<pre><code>$ ls *.txt\nbar.txt foo.txt test.txt\n$ ls {fo,ba}??txt   \nbar.txt foo.txt\n</code></pre> <p>The expression <code>{fo,ba}??txt</code> matches any file names the start with either <code>fo</code> or <code>ba</code>, followed by two characters, followed by <code>txt</code>.</p>"},{"location":"unix/advanced.html#leveling-up-your-productivity-with-cli","title":"Leveling Up Your Productivity with CLI","text":""},{"location":"unix/advanced.html#minimizing-hand-movements","title":"Minimizing Hand Movements","text":"<p>You have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface.  No windows. No mouse.  Just you, the keyboard, and the terminal.  You do not even need to use any arrow keys or function keys.  </p> <p>Why is this a big deal?  Let's look at the image of the keyboard below:</p> <p></p> <p>We only need to use the keys colored in pink.  And since these keys are concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard<sup>1</sup>, we only need to move our fingers to type.  </p> <p></p>"},{"location":"unix/advanced.html#minimizing-typing","title":"Minimizing Typing","text":"<p>We can even minimize the movement of our fingers in several ways by typing less.  We have seen several ways where we have achieved these:</p> <ul> <li>Unix commands are named economically -- they are often only a few characters long.</li> <li>We can use Tab to auto-complete a command or a file name.</li> <li>We can use Ctrl+P or Ctrl+N to repeat a previous command.</li> </ul> <p>There are many more <code>bash</code> shortcuts for productivity, if you are keen, take a look at this cheat sheet.</p> <p>You have also seen that Unix has many small, simple, utilities that we can compose to solve a task.  But composing them requires much typing:</p> <pre><code>$ cat ID | sort | uniq | grep CEG | wc -l\n</code></pre> <p>If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name.  Such a file containing commands for the shell is called a shell script.</p> <p>For example, let's create a file named <code>hello.sh</code> containing the line <code>echo hello!</code> by: <pre><code>$ cat &gt; hello.sh\necho hello!^D\n</code></pre></p> <p>The extension <code>.sh</code> is not necessary, but it is just something I use so that I can tell that this file contains a shell script.  In the example above, <code>cat</code> will wait for me to enter something on the keyboard.  So I entered <code>echo hello!</code> followed by Ctrl+D to indicate the end of the input.</p> <p>Now, to execute this file, we run: <pre><code>$ bash hello.sh\nhello!\n</code></pre> or <pre><code>$ bash &lt; hello.sh\nhello!\n</code></pre></p> <p>Recall that we said Unix shells do not necessarily interact with the users.  This is an example.  We pass the file <code>hello.sh</code> to a new instance of <code>bash</code>, asking it to interpret the lines inside this file as commands to execute.  </p> <p>Remember that we want to minimize typing.  What if we can just pass the filename directly to <code>bash</code> to execute?</p> <pre><code>$ ./hello.sh\nbash: ./hello.sh: Permission denied\n</code></pre> <p>Here, we specify the relative path of the script <code>hello.sh</code>, including the prefix <code>./</code> (for reasons that we will explain later).  But we should get an error telling us <code>Permission defined</code>.  Recall from the <code>File Permissions</code> section that a file needs to have the executable <code>x</code> permission to be executed.  So we need to add this permission for ourselves: <pre><code>$ chmod u+x hello.sh\n$ ./hello.sh\nhello!\n</code></pre></p> <ol> <li> <p>The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F, and the right fingers are over J K L ;.\u00a0\u21a9</p> </li> </ol>"},{"location":"unix/background.html","title":"Unix CLI: Background","text":"<p>This article is a replication of the notes from the Unix@Home Workshop held in August 2020.</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the basic terms: CLI, terminal, shell, command prompt.</li> <li>appreciate why CLI is more efficient.</li> <li>aware of the commonly used terminal control sequences.</li> </ul>"},{"location":"unix/background.html#what-is-command-line-interfaces","title":"What is Command-Line Interfaces?","text":"<p>The command-line interface, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks.</p> <p>In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses a keyboard and text.  The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user.</p> <p>CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example).  Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper.  This is the era before monitors and mice.  Again, driven by constraints and necessity, CLI interfaces are designed to be simple and economical.  The commands are short and fast to type; the responses are succinct.</p> <p> Figure 2.1.: A teletype device (Model 33 ASR) to interact with a computer. </p>"},{"location":"unix/background.html#why-cli-over-gui","title":"Why CLI over GUI?","text":"<p>Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network.  Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data.</p> <p>Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all times and does not need to switch frequently between keyboard and mouse._  While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer.</p> <p>Further, CLI commands typically provide a host of options that is accessible directly (in contrast to clicking through preference dialogues) from the command line, making these commands flexible and customizable.</p> <p>Finally, since these commands are just text, we can put together a sequence of commands easily as a script, to automate highly repetitive tasks.</p>"},{"location":"unix/background.html#what-is-a-terminal","title":"What is a Terminal?","text":"<p>With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s.  Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green).</p> <p> Figure 2.2.: The VT100 Computer Terminal. </p> <p>In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print the output as text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal.  Examples include <code>Terminal</code> and <code>iTerm2</code> on macOS; <code>Windows Terminal</code> on Microsoft; <code>xterm</code> and <code>konsole</code> on Ubuntu, etc.  Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence.</p>"},{"location":"unix/background.html#what-is-a-shell","title":"What is a Shell?","text":"<p>The term CLI refers to a type of user interface.  To realize this interface, Unix computing environments rely on another type of program called shell.  </p> <p>A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output to the user through the terminal.</p> <p>Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance).</p> <p>There are many shells available, each with different bells and whistles to help improve our productivity.  </p> <p>The most popular shell that comes as default on many Unix systems is <code>bash</code> or Bourne Again Shell.  This is the shell that we will use in this workshop and as default in the SoC Unix computing environment.</p> <p>Other popular shells are <code>fish</code> and Oh-my-zsh (<code>zsh</code>).</p>"},{"location":"unix/background.html#command-prompt","title":"Command Prompt","text":"<p>A shell has a command prompt. It typically looks something like this, but will be different depending on the default configuration on your machine:</p> <pre><code>ooiwt@pe111:~$\n</code></pre> <p>The prompt is where you type in a command for the shell to interpret and execute.  </p> <p>In <code>bash</code>, the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc.  It is customary to use the <code>$</code> sign as the final character of the prompt.  In our examples, we will just show <code>$</code> to indicate the command prompt.</p> <p>Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\".  They all mean the same thing: type in the command at the command prompt of the shell.</p>"},{"location":"unix/background.html#terminal-control-sequence","title":"Terminal Control Sequence","text":"<p>On the old teletype machines, a user can send special commands to the teletype machines to control their operation.  Many of these special commands still exist today, and can be triggered by hitting a combination of Ctrl and another key (i.e., a control sequence).</p> <p>The following lists some of the most useful control sequences to know:</p> <ul> <li> <p>Ctrl+D :   signal the end of input to a program.  This is also used to exit from a shell (by telling the shell that you have no more input to send, and you are done with it).</p> </li> <li> <p>Ctrl+Z :   suspend the current running program.  This pauses the execution of the program (but not terminates it).  In the <code>bash</code> shell, the most recently suspended program can resume executing in the background with the command <code>bg</code> or be brought back to execution in the foreground again with the command <code>fg</code>.   </p> </li> <li> <p>Ctrl+C :   terminate the current running program.</p> </li> <li> <p>Ctrl+S :   freeze the terminal.  This is a legacy control command that pauses the output printing of a teletype machine.  You shouldn't need to use this control sequence.</p> </li> <li> <p>Ctrl+Q :   resume the terminal.  This is a legacy control command that resumes the printing of a teletype machine.  You shouldn't need to use this control sequence unless you accidentally hit Ctrl+S</p> </li> </ul> <p>Ctrl+Z vs. Ctrl+C</p> <p>A common mistake for new students is to hit Ctrl+Z frequently if something goes wrong with their program -- this behavior could lead to multiple suspended programs (which still occupy resources such as memory on the computer).  The right sequence to use is Ctrl+C -- which terminates the program (and frees up the resources).</p> <p>Ctrl+S accidents</p> <p>Since Ctrl+S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this control sequence, causing their terminal to freeze.  Don't panic if this happens.  Just hit Ctrl+Q and things will be back to normal.</p>"},{"location":"unix/background.html#references","title":"References","text":"<ul> <li>The Art of Unix Usability: Command Line Interfaces, by Eric Steven Raymond</li> </ul>"},{"location":"unix/essentials.html","title":"Unix CLI: The Essentials","text":"<p>This article is adapted from the notes of the Unix@Home Workshop held in August 2020.  It contains the essential knowledge that a CS2030S students need to survive using the PE nodes to do the labs (and to use a Unix CLI in general).</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to navigate comfortably in a Unix file system using shell commands <code>cd</code>, <code>pwd</code>, and <code>ls</code>.</li> <li>be able to use <code>.</code>, <code>..</code>, <code>~</code> or <code>/</code> to form a relative or absolute path name to a file.</li> <li>be able to organize files in a Unix file system using shell commands <code>mkdir</code>, <code>rmdir</code>, <code>mv</code>, <code>rm</code>, and <code>cp</code>.</li> <li>be able to view the content of the file using <code>cat</code>, <code>more</code> or <code>less</code>.</li> <li>be able to manage the permission of a file using <code>chmod</code>.</li> <li>be able to perform standard input/output redirection with <code>&lt;</code> and <code>&gt;</code>.</li> </ul>"},{"location":"unix/essentials.html#unix-directory","title":"Unix Directory","text":"<p>Unix organizes files according to a directory structure.  The following shows an example.</p> <p></p> <p>This structure is also known as a directory tree.  There are two important directories that you need to know.</p>"},{"location":"unix/essentials.html#root-directory","title":"Root Directory","text":"<p>The root directory is the directory at the top of the directory tree<sup>1</sup>. It is simply referred to as <code>/</code>, without any name.  Under the root directory are many other system directory, which a casual user does not normally need to (and have no permission to) modify.</p>"},{"location":"unix/essentials.html#home-directory","title":"Home Directory","text":"<p>Each user has his/her own home directory.  The above figure shows where the home directory of the user <code>ooiwt</code> resides in the directory tree. The user <code>ooiwt</code> may create files or directories in his/her home directory, but not elsewhere unless permission is given.</p> <p>The home directory is referred to with the symbol <code>~</code> in <code>bash</code>.  Sometimes we add the username behind <code>~</code> to indicate the home directory of the other user. E.g., <code>~bob</code> means the home directory of a user named <code>bob</code>.</p>"},{"location":"unix/essentials.html#current-working-directory","title":"Current Working Directory","text":"<p>A user can navigate around the directory tree.  The current working directory is the directory that the user is currently in.  In contrast to the root and home directory, which are fixed<sup>2</sup>, the current working directory changes as the user moves around.  Knowing the current working directory is important since this is the default location in the directory tree a command executes.  As such, many systems by default display the current working directory as part of the <code>bash</code> command prompt.</p> <p>The current working directory is referred to with the symbol <code>.</code> in <code>bash</code>.</p>"},{"location":"unix/essentials.html#parent-directory","title":"Parent Directory","text":"<p>The parent directory is directory one layer up from the current directory.</p> <p>The parent directory is referred to with the symbol <code>..</code> in <code>bash</code>.</p> <p>To summarize, here are the short form representations:</p> Symbol Meaning <code>/</code> the root directory <code>~</code> the home directory <code>.</code> the current working directory <code>..</code> the parent directory"},{"location":"unix/essentials.html#specifying-a-path","title":"Specifying a Path","text":"<p>To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path.</p>"},{"location":"unix/essentials.html#absolute-path","title":"Absolute path","text":"<p>The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash <code>/</code>.  This is a similar notation used for Website URLs, so you should already be familiar with it.  For instance, the path <code>/home/o/ooiwt</code> is the absolute path of the directory named <code>ooiwt</code> in the figure above.</p> <p>An absolute path is independent of the current working directory and always start with <code>/</code> or <code>~</code></p>"},{"location":"unix/essentials.html#relative-path","title":"Relative path","text":"<p>The relative path is dependent on the current working directory.  To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to.  When we go up a tree, we use <code>..</code> to represent the directory.</p> <p>For example, referring to the figure above, if we are in the directory <code>/home/b</code>, and we wish to refer to <code>/home/o/ooiwt</code>, we can use the relative path <code>../o/ooiwt</code>.  If we wish to refer to <code>/home/b/bob</code>, we can use the relative path <code>bob</code>.</p> <p>A relative path never starts with <code>/</code>.</p>"},{"location":"unix/essentials.html#directory-related-commands","title":"Directory-related Commands","text":"<p>Now, let's take a look at some basic commands available in <code>bash</code> that deals with navigation and directories.</p>"},{"location":"unix/essentials.html#pwd-print-current-working-directory","title":"<code>pwd</code>: Print Current Working directory","text":"<p><code>pwd</code> shows you which directory you are currently in.  Type <code>pwd</code> into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in <code>/home/o/ooiwt</code>, entering</p> <pre><code>pwd\n</code></pre> <p>will give the output</p> <pre><code>/home/o/ooiwt\n</code></pre>"},{"location":"unix/essentials.html#ls-list-content-of-a-directory","title":"<code>ls</code>: LiSt content of a directory","text":"<p>The <code>ls</code> list the content in the current working directory.</p> <p>Rule of Silence</p> <p>Unix follows the economical rule of silence: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if <code>ls</code> has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")</p> <p>In Unix, a file or directory with a name that starts with <code>.</code> is hidden from <code>ls</code>.  Common hidden files are <code>.vimrc</code>, the configuration file for <code>vim</code>, and <code>.ssh</code>, the directory to store your SSH keys and configuration.  To view all the files, including hidden files, run <code>ls</code> with the <code>-a</code> flag (<code>a</code> stands for all).</p>"},{"location":"unix/essentials.html#mkdir-make-a-subdirectory","title":"<code>mkdir</code>: MaKe a subDIRectory","text":"<p>The <code>mkdir</code> command creates a subdirectory with the given name in the current directory.</p> <p>In the example below, we assume that we start with an empty directory.  </p> <pre><code>$ ls\n$ mkdir workshop\n$ ls\nworkshop\n$ ls -F\nworkshop/\n</code></pre> <p>Here, we create a directory called <code>workshop</code>.  Now, when we <code>ls</code>, you can see the directory listed.  </p> <p>You may also use <code>ls -F</code> for more information (<code>-F</code> is one of the many _options/flags available for the <code>ls</code> command. To see a complete list of the options, refer to the man pages, i.e., <code>man ls</code>_).</p> <p>The slash <code>/</code> beside the filename tells you that the file is a directory.  A normal file does not have a slash beside its name when \"ls -F\" is used.</p> <p>You may also use the <code>ls -l</code> command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.</p> <p>Use Up Arrow for Command History</p> <p><code>bash</code> maintains a history of your previously executed commands, and you may use the Ctrl+P (previous) and Ctrl+N (next) to go through it. Press the Ctrl+P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long <code>bash</code> command.</p>"},{"location":"unix/essentials.html#cd-change-directory","title":"<code>cd</code>: Change Directory","text":"<p>To navigate in the directory tree, changing the current working directory from one to another, we use the <code>cd</code> command.</p> <pre><code>$ pwd\n/home/o/ooiwt\n$ cd workshop\n$ pwd\n/home/o/ooiwt/workshop\n</code></pre> <p>Suppose our starting working directory is <code>/home/o/ooiwt</code>, after we <code>cd</code> into <code>workshop</code>, the current working directory becomes <code>/home/o/ooiwt/workshop</code>.  Note that <code>cd</code> can take in either an absolute path or a relative path.  The example above takes in a relative path as the argument.</p> <p>As mentioned in \"Unix CLI: Background\", it is common to include the current working directory into the shell's prompt.  So, you may see your command prompt updated to include the new working directory.</p> <p>Entering <code>cd</code> alone (without argument) brings you back to your home directory.  </p>"},{"location":"unix/essentials.html#rmdir-remove-a-subdirectory","title":"<code>rmdir</code>: ReMove a subDIRectory","text":"<p><code>rmdir</code> removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed.</p> <p>The command</p> <pre><code>$ rmdir workshop\n</code></pre> <p>will remove the directory that you just created.</p>"},{"location":"unix/essentials.html#file-management","title":"File Management","text":"<p>This note assumes that you are familiar with navigation with the Unix directory structure.</p> <p>We will now learn some commands to help us deal with files.</p> <p>Let's recreate the <code>workshop</code> directory in case you have already deleted it with the <code>rmdir</code> at the end of the last unit.</p> <pre><code>$ mkdir -p workshop\n$ cd workshop\n$ ls\n</code></pre> <p>All the above commands should complete successfully and silently.  Let's populate the directory with a new file.  Cut-and-paste the command below into the command prompt:</p> <pre><code>wget https://www.comp.nus.edu.sg/~ooiwt/unix-workshop/test.txt\n</code></pre> <p>You should see a file being downloaded and saved with an output similar to below:</p> <pre><code>--2020-07-27 15:26:49--  https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 64 [text/plain]\nSaving to: \u2018test.txt\u2019\n\ntest.txt              100%[======================&gt;]      64  --.-KB/s    in 0s\n\n2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64]\n</code></pre> <p>Now run <code>ls</code>, and you should see that <code>ls</code> returns <code>test.txt</code> as the content of the current working directory.</p> <pre><code>$ ls\ntest.txt\n</code></pre>"},{"location":"unix/essentials.html#cp-copy-files","title":"<code>cp</code>: CoPy files","text":"<p>Now let's try to copy this file to another name.</p> <pre><code>$ cp test.txt foo.txt\n$ ls\ntest.txt foo.txt\n</code></pre> <p>The command above copies the file <code>test.txt</code> into <code>foo.txt</code>.</p> <p>If you want to copy the whole directory, use <code>-r</code> flag, where <code>r</code> stands for copying recursively.</p> <p>Now let's create another directory called <code>copy</code>.</p> <pre><code>$ cd ..\n$ mkdir copy\n$ cd copy\n$ ls\n</code></pre> <p>Run <code>pwd</code> to double-check that you are in the directory called <code>copy</code> that is at the same level as <code>workshop</code>.</p> <p>Now, we are going to use <code>cp</code> with the <code>-r</code> flag, to copy recursively the whole of <code>workshop</code> directory over.</p> <pre><code>$ cp -r ../workshop .\n</code></pre> <p>The command <code>cp</code> takes in two arguments, the first is the source, and the second is the destination.</p> <p>Note that we use <code>.</code> above to indicate that we wish to copy the whole subtree of <code>workshop</code> over the current directory.  The command should complete without any message.  Upon completion, you can run <code>ls</code> to double-check that the workshop directory exists under <code>workshop</code>.</p> <p><code>cp</code> Overwrites</p> <p>If there is an existing file with the same name, <code>cp</code> will overwrite the existing file without warning.</p>"},{"location":"unix/essentials.html#mv-move-or-rename-files","title":"<code>mv</code>: MoVe or rename files","text":"<p>Now, let's change directory back to <code>workshop</code>.</p> <pre><code>$ cd ../workshop\n</code></pre> <p>and use the <code>mv</code> command to rename <code>foo.txt</code> into <code>bar.txt</code>.</p> <pre><code>$ ls\nfoo.txt test.txt\n$ mv foo.txt bar.txt\n$ ls\nbar.txt test.txt\n</code></pre> <p>As you can see above, just like <code>cp</code>, <code>mv</code> takes in two arguments, the first is the source and the second is the destination.</p> <p>If the destination of <code>mv</code> is a directory, however, instead of renaming, the <code>mv</code> commands move the source to the destination directory.</p> <pre><code>$ ls\nbar.txt test.txt\n$ mv ../copy/workshop/foo.txt .\n$ ls\nbar.txt foo.txt test.txt\n</code></pre> <p>Here, you can see that we have moved <code>foo.txt</code> over to the current directory.</p> <p><code>mv</code> Overwrites</p> <p>If there is an existing file with the same name, <code>mv</code> will overwrite the existing file without warning. <code>mv</code> comes with a <code>-i</code> flag that interactively asks you if you are sure if you want to overwrite a file.  It is a good idea to always run <code>mv -i</code>. Hit Y to continue overwriting the existing file.  You can look up on the Internet on how to make <code>-i</code> the default using <code>alias</code> command in <code>.bashrc</code>.</p> <p>Use Tab for Name Completion</p> <p>If you have a very long file name, you may use the <code>bash</code> auto-completion feature to reduce typing. For instance, you may type:</p> <pre><code>$ mv t\n</code></pre> <p>and press the Tab key, <code>bash</code> will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.</p>"},{"location":"unix/essentials.html#rm-remove-files","title":"<code>rm</code>: ReMove files","text":"<p>We can use <code>rm</code> to remove files.  Be careful with this command -- files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.</p> <pre><code>$ ls\nbar.txt foo.txt test.txt\n$ rm foo.txt\n$ ls\nbar.txt test.txt\n</code></pre> <p><code>rm -rf</code></p> <p>While the Unix command line provides lots of flexibility and power, with great power comes great responsibility.  Some commands are extremely dangerous.  <code>rm -rf *</code> is the most famous one.  The notation <code>*</code> refers to all files, and the flag <code>-f</code> means forceful deletion (no question asked!), and <code>-r</code> means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many lives.  Read more here</p> <p><code>rm</code> comes with a <code>-i</code> flag that interactively asks you if you are sure if you want to delete a file.  It is a good idea to always run <code>rm -i</code>.</p> <pre><code>$ rm -i bar.txt\nrm: remove regular file 'bar.txt'?\n</code></pre> <p>Type <code>y</code> or <code>n</code> to answer yes or no respectively.</p>"},{"location":"unix/essentials.html#cat-catenate-file-content-to-screen","title":"<code>cat</code>: CATenate file content to screen","text":"<p>To quickly take a look at the content of the file, use the <code>cat</code> command.</p> <pre><code>$ cat test.txt\nThis is a test file for learning Unix file management commands.\n</code></pre> <p><code>less</code> is a variant of <code>cat</code> that includes features to read each page leisurely and is useful for long files.</p> <pre><code>$ less test.txt\n</code></pre> <p>In <code>less</code>, use <code>&lt;space&gt;</code> to move down one page, <code>b</code> to move Back up one page, and <code>q</code> to Quit.</p>"},{"location":"unix/essentials.html#man-online-manual","title":"<code>man</code>: Online MANual","text":"<p>An online help facility is available in Unix via the <code>man</code> command (<code>man</code> stands for MANual). To look for more information about any Unix command, for example, <code>ls</code>, type <code>man ls</code>. Type <code>man man</code> and refer to Man Pages to find out more about the facility. To exit <code>man</code>, press <code>q</code>.</p>"},{"location":"unix/essentials.html#file-permission-management","title":"File Permission Management","text":"<p>File permissions determine who can do what to a file.  Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason, and it is critical to do it right.</p>"},{"location":"unix/essentials.html#the-what-of-file-permissions","title":"The What of File Permissions","text":"<p>Let's look at what you can do to a file first.  Unix file permissions allow control of three actions: <code>r</code> (read), <code>w</code> (write) and <code>x</code> (execute).  These permission settings allow the following different actions to be done for regular files and directories.</p> permission effect on file effect on directory <code>r</code> reading the content of a file read the names of the files in the directory <code>w</code> writing into a file create/delete/rename files in the directory <code>x</code> executing a file access contents and meta-info (size, creation time) of files in the directory <p>These three actions can be controlled independently.  </p> <p>The permissions on a file can be expressed in two ways:</p> <ul> <li> <p>using symbolic notation.  For instance,  <code>rwx</code>, <code>r-x</code>, <code>-wx</code>, where a <code>-</code> means that the corresponding permission is not given (in the order of <code>r</code>, <code>w</code>, <code>x</code>).</p> </li> <li> <p>using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: <code>r</code> is represented with 4, <code>w</code> is represented with 2, and <code>x</code> is represented with 1. For instance, <code>r-x</code> has a numerical representation of 5, and <code>-wx</code> has a numerical representation of 3.</p> </li> </ul>"},{"location":"unix/essentials.html#the-who-of-file-permissions","title":"The Who of File Permissions","text":"<p>Unix divides the users into three classes: <code>u</code> is the user who owns the file; <code>g</code> refers to the users in the same group as the user; and <code>o</code> are all the other users.</p> <p>The permissions can be controlled separately for these classes of users.  The permission notation simply concatenates the file permissions of each class of users together, in the order of <code>u</code>, <code>g</code>, and <code>o</code>.</p> <p>For instance, the permission of 644, or <code>rw-r--r--</code>, on a file means that:</p> <ul> <li>the owner can read and write</li> <li>the group users can only read</li> <li>all the other users can only read</li> </ul>"},{"location":"unix/essentials.html#checking-file-permission","title":"Checking file permission","text":"<p>You can view the permission of a file by using the <code>ls -l</code> command (<code>l</code> for long format):</p> <pre><code>$ ls -l test.txt\n-rw-r--r--@ 1 ooiwt  staff  64 Jul 28 09:52 test.txt\n</code></pre> <p>Ignoring the first <code>-</code> and the last <code>@</code>, you can see that the permission of <code>test.txt</code> is 644.</p>"},{"location":"unix/essentials.html#the-chmod-command","title":"The <code>chmod</code> command","text":"<p>You can use <code>chmod</code> command to change the permissions of a file or a directory.</p> <p>For instance,</p> <pre><code>$ chmod 666 test.txt\n$ ls -l test.txt\n-rw-rw-rw-@ 1 ooiwt  staff  64 Jul 28 09:52 test.txt\n</code></pre> <p>would change add the permission <code>w</code> to both group and other users<sup>1</sup>.</p> <p>An alternative way is to just specify the changes.  To remove the permission to write from others, you can run:</p> <pre><code>$ chmod o-w test.txt\n$ ls -l test.txt\n-rw-rw-r--@ 1 ooiwt  staff  64 Jul 28 09:52 test.txt\n</code></pre>"},{"location":"unix/essentials.html#common-scenarios-for-chmod","title":"Common Scenarios for <code>chmod</code>","text":"<p>Here are some scenarios where you might need to use the <code>chmod</code> command:</p> <ul> <li> <p>If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users.  Make sure that your homework directory as the permission of <code>700</code>.</p> </li> <li> <p>If you download a file from the Internet and you do not have the permission to read it, you should do a <code>u+r</code> to give yourself the read permission.</p> </li> <li> <p>A program should have execution permission to run.  If you have a script or an executable file that you can't run, give yourself the execution permission <code>u+x</code>.</p> </li> </ul>"},{"location":"unix/essentials.html#standard-inputoutput","title":"Standard Input/Output","text":""},{"location":"unix/essentials.html#history","title":"History","text":"<p>Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default.  Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs.   With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output.</p> <p>The two abstract devices that Unix provides are called standard input and standard output.  By default, the standard input refers to the keyboard and the standard output is the terminal.</p>"},{"location":"unix/essentials.html#examples-using-cat-and-wc","title":"Examples using <code>cat</code> and <code>wc</code>","text":"<p>Let's look at these concepts closer, by examining some examples.</p> <p>Remember <code>cat</code>?  The <code>cat</code> command takes in a filename and it prints the content of the file to the standard output.</p> <pre><code>$ cat test.txt\nThis is a test file for learning Unix file management commands.\n</code></pre> <p>If no filename is given, <code>cat</code> by default try to read from the standard input.  Try running:</p> <pre><code>$ cat\n</code></pre> <p>You will see that the command is waiting for you to type in something.  Type in anything, as soon as you press Enter, <code>cat</code> is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output.  You can keep typing, supplying text to <code>cat</code>, or you can type Ctrl+D to send the end-of-input command to <code>cat</code>.</p> <p>Let's look at another command, <code>wc</code>.  <code>wc</code> is a utility that counts the number of lines, words, characters.  If we call <code>wc</code> and supply it a file name, it will count the number of lines, words, and characters in that given file.</p> <pre><code>$ wc test.txt\n       1      11      64 test.txt\n</code></pre> <p>The output means that there is 1 line, 11 words, and 64 characters in the file <code>test.txt</code>.</p> <p>But if you do not pass in any file name, <code>wc</code> is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output.  Go ahead and try:</p> <pre><code>$ wc\n</code></pre> <p>You will see that the <code>wc</code> command is waiting for you to type in something.  Type in a few sentences, you can hit Enter for a new line.  When you are done, type Ctrl+D.  <code>wc</code> will count the number of lines, words, and characters for the text that you just entered.</p>"},{"location":"unix/essentials.html#output-redirection","title":"Output Redirection","text":"<p>By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to.  Most of the time, we can write the output of the program to the standard output.  In instances where we need to write the output to another location, we can just redirect the output.</p> <p>The operators <code>&gt;</code> and <code>&gt;&gt;</code> are used to redirect the standard output to a file.  The difference is that <code>&gt;</code> will overwrite the given file, while <code>&gt;&gt;</code> will concatenate into the given file.</p> <p>For example:</p> <pre><code>$ wc test.txt &gt; test.count\n$ cat test.count\n       1      11      64 test.txt\n</code></pre> <p>The first command redirects the output from <code>wc</code> to a file named <code>test.count</code>, so you do not see anything printed to the output anymore.  We can check by running <code>cat</code> on the new file <code>test.count</code> -- indeed the original output from <code>wc</code> is now stored in the file <code>test.count</code>.</p> <p>If we repeat the command <code>wc test.txt &gt; test.count</code> again, you can see that the file has been overwritten with the output from <code>wc</code> again.  But if we replace <code>&gt;</code> with <code>&gt;&gt;</code>, a new line is concatenated into <code>test.count</code>.   So the file now has two lines.</p> <pre><code>$ wc test.txt &gt; test.count\n$ cat test.count\n       1      11      64 test.txt\n$ wc test.txt &gt;&gt; test.count\n$ cat test.count\n       1      11      64 test.txt\n       1      11      64 test.txt\n</code></pre>"},{"location":"unix/essentials.html#input-redirection","title":"Input Redirection","text":"<p>The operator <code>&lt;</code> is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file.  Commands such as <code>cat</code> and <code>wc</code> already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the <code>&lt;</code> operator.</p> <pre><code>$ wc test.txt\n       1      11      64 test.txt\n$ wc &lt; test.txt\n       1      11      64\n$ cat test.txt\nThis is a test file for learning Unix file management commands.\n$ cat &lt; test.txt\nThis is a test file for learning Unix file management commands.\n</code></pre> <p>Note the slight difference in the output format of the second <code>wc</code> above -- it no longer prints the file name since from <code>wc</code> points of view, it is read from the standard input and not from a file, so it is not aware of the file named <code>test.txt</code></p> <p>In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the <code>&lt;</code> is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard.  You can just save the input data in a file, then redirect it to standard input with the <code>&lt;</code> operator.</p>"},{"location":"unix/essentials.html#other-useful-online-tools","title":"Other Useful Online Tools","text":"<ul> <li>explainshell explain each shell command for you</li> </ul> <ol> <li> <p>Giving write permission to other users is a security risk.  You should not do this unless you know what you are doing.\u00a0\u21a9\u21a9</p> </li> <li> <p>Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed!  But let's not worry about that for now since there is no good reason to do that as a beginner.\u00a0\u21a9</p> </li> </ol>"},{"location":"vim/index.html","title":"Index","text":""},{"location":"vim/index.html#vim","title":"Vim","text":"<ul> <li>The Philosophy of Vim</li> <li>Setting up Vim for CS2030S</li> <li>Quick Lessons</li> <li>Vim Tips</li> <li>Color Scheme and Plugins</li> </ul>"},{"location":"vim/cheatsheet.html","title":"VIM Cheat Sheets","text":""},{"location":"vim/cheatsheet.html#cursor-movement","title":"Cursor Movement","text":"<p>In <code>NORMAL</code> mode.</p> Keys Description H \u00a0\u00a0 (or Left) Move cursor to the left (you may use arrow keys if <code>.vimrc</code> is set correctly) J \u00a0\u00a0 (or Down) Move cursor down (you may use arrow keys if <code>.vimrc</code> is set correctly) K \u00a0\u00a0 (or Up) Move cursor up (you may use arrow keys if <code>.vimrc</code> is set correctly) L \u00a0\u00a0 (or Right) Move cursor to the right (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> H \u00a0\u00a0 (or <code>n</code> Left) Move cursor <code>n</code> steps to the left (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> J \u00a0\u00a0 (or <code>n</code> Down) Move cursor <code>n</code> steps down (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> K \u00a0\u00a0 (or <code>n</code> Up) Move cursor <code>n</code> steps up (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> L \u00a0\u00a0 (or <code>n</code> Right) Move cursor <code>n</code> steps to the right (you may use arrow keys if <code>.vimrc</code> is set correctly) G G Go to the first line Shift + G Go to the last line } Jump to next paragraph { Jump to previous paragraph : <code>n</code> Go to line number <code>n</code>"},{"location":"vim/cheatsheet.html#edit","title":"Edit","text":"<p>In <code>NORMAL</code> mode.</p> Commands Description <code>:e</code> Edit file (i.e., open) <code>:w</code> Write file (i.e., save) <code>:q</code> Quit file (only works if file is unchanged) <code>:q!</code> Force quit (even if file is changed) <code>:wq</code> Write file and quit Keys Description Y Y Yank (i.e., copy) a line D D Delete (i.e., copy) a line P Paste after cursor Shift + P Paste before cursor U Undo Ctrl + R Redo = Auto-indent current line <code>n</code> Y Y Yank (i.e., copy) <code>n</code> lines <code>n</code> D D Delete (i.e., copy) <code>n</code> lines <code>n</code> = = Auto-indent <code>n</code> lines G G = Shift + G Auto-indent all lines <p>The last keys can be split into 3 components:</p> <ol> <li>G G: Go to the first line</li> <li>=: Auto-indent</li> <li>Shift + G: Go to the last line</li> </ol> <p>This reads as (1.) go to the first line, then (2.) auto-indent (3.) until the last line.</p>"},{"location":"vim/cheatsheet.html#search-and-replace","title":"Search and Replace","text":"<p>In <code>NORMAL</code> mode.</p> Commands Description <code>/&lt;pattern&gt;</code> Search for <code>&lt;pattern&gt;</code> <code>?&lt;pattern&gt;</code> Search backward for <code>&lt;pattern&gt;</code> <code>:%s/&lt;old&gt;/&lt;new&gt;/gc</code> Replace all <code>&lt;old&gt;</code> with <code>&lt;new&gt;</code> (this will prompt options) <code>:&lt;sn&gt;,&lt;en&gt;s/&lt;old&gt;/&lt;new&gt;/gc</code> Replace all <code>&lt;old&gt;</code> with <code>&lt;new&gt;</code> in the given line range from <code>&lt;sn&gt;</code> to <code>&lt;en&gt;</code> (this will prompt options) <p>Once a search is being performed.</p> Keys Description N Continue search forward Shift + N Continue search backward <p>Options for replace</p> Option Description <code>y</code> Yes, replace the current one <code>n</code> No, skip this one <code>a</code> Yes to all <code>l</code> Yes to just this one <code>q</code> Quit"},{"location":"vim/cheatsheet.html#comment-and-uncomment","title":"Comment and Uncomment","text":"<p>We can quickly comment a specific range of lines using the replace functionality.  The idea is to replace the beginning of a line with <code>//</code> (i.e., start of single line comment).  We need to \"escape\" the <code>/</code> character by writing it as <code>\\/\\/</code>To match the beginning of the line, the character is <code>^</code>.</p> <p>Comment line 4 to 17.</p> <pre><code>:4,17s/^/\\/\\//gc\n</code></pre> <p>We can also quickly uncomment specific range of lines by replacing <code>//</code> with nothing.</p> <p>Uncomment line 4 to 17.</p> <pre><code>:4,17s/\\/\\///gc\n</code></pre> <p>Simply replace <code>4</code> and <code>17</code> with the range that you need.</p>"},{"location":"vim/cheatsheet.html#split-screen","title":"Split Screen","text":""},{"location":"vim/cheatsheet.html#commands","title":"Commands","text":"Keys Description <code>:sp &lt;filename&gt;</code> Open file name <code>&lt;filename&gt;</code> in horizontal split screen <code>:vsp &lt;filename&gt;</code> Open file name <code>&lt;filename&gt;</code> in vertical split screen <code>:e &lt;filename&gt;</code> Open the file name <code>&lt;filename&gt;</code> in the current screen"},{"location":"vim/cheatsheet.html#navigation","title":"Navigation","text":"Keys Description Ctrl + W Ctrl + W Change screen Ctrl + W H Change to the right screen Ctrl + W J Change to the down screen Ctrl + W K Change to the up screen Ctrl + W L Change to the left screen"},{"location":"vim/cheatsheet.html#java","title":"Java","text":"Keys Description <code>:!javac &lt;filename&gt;.java</code> Compile the java file <code>&lt;filename&gt;.java</code> <code>:!java &lt;classname&gt;</code> Run the class <code>&lt;classname&gt;</code> <code>:!jshell &lt;filename&gt; &lt;filename&gt; ...</code> Start JShell with the given <code>&lt;filename&gt;</code>s"},{"location":"vim/philosophy.html","title":"The Philosophy of <code>vim</code>","text":"<p>This article is adapted from the notes of the Unix@Home Workshop  held in August 2020.</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>appreciate the usefulness of learning <code>vim</code> and using it as the main source code editor.</li> <li>appreciate the efficiency and philosophy of using <code>vim</code>.</li> <li>have experience navigating around a text buffer and manipulating text in <code>vim</code></li> <li>be aware of how to learn more about using <code>vim</code>.</li> </ul>"},{"location":"vim/philosophy.html#background","title":"Background","text":"<p>To edit our code, we need a proper editor.  Remember that, ideally, we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys.</p> <p>There are only two respectable, widely available text editors in Unix -- <code>vim</code> and <code>emacs</code>.  Which one is better has been an ongoing religious war, but for us in SoC, we use <code>vim</code>.</p> <p>Reading Keyboard Keys</p> <p>Keyboard keys are enclosed in a box like the following letter A.  All keyboard keys are written in uppercase.  You are to press exactly that key without any other key.  So the letter A should give you the lowercase \"a\" character.</p> <p>If a sequence of keys are to be pressed, you will see the keys in successions.  For instance, if you see G G, it means you should press G twice.</p> <p>On the other hand, if multiple keys are to be pressed at the same time, you will see a plus sign (i.e., +) written in between the keys.  For instance, if you see Shift+Z+Z, it means you should press Shift key and Z at the same time.  Since we cannot press two different Z at the same time, the second Z is pressed after your finger has been moved from the first Z.  However, you should still be pressing the Shift key.</p> <p>If the intention is for the Shift key to not be pressed for the second Z, it will be written as Shift+Z Z.</p>"},{"location":"vim/philosophy.html#basic-of-vim","title":"Basic of <code>vim</code>","text":""},{"location":"vim/philosophy.html#minimizing-hand-movements","title":"Minimizing Hand Movements","text":"<p><code>vim</code>, like the shell, aims to minimize hand movements.  Frequently used commands are positioned in convenient places on the keyboard.  Let me give you a few examples.</p> <ul> <li> <p>To exit vim, type Shift+Z+Z.  Notice that this is located in the bottom left corner of your keyboard.  For normal typing, your left hand is supposed to be placed over the keys A S D F, so you just need to move slightly your left pinky to Shift and left ring finger to Z and hit them.</p> </li> <li> <p>To move the cursor, instead of using the arrow keys, <code>vim</code> uses H to move left, L to move right, J to move down, and K to move up.  For normal typing, your right hand is supposed to be placed on J K L ;, so these arrow keys alternatives are located very near to where your right hand should be!</p> </li> </ul> <p>I have a few more things to say about using H J K L to replace the arrow keys:</p> <ul> <li> <p>It is not uncommon for applications to re-map other keys for movement.  Many first-person shooting games use W A S D for movement, for the same reason as <code>vim</code> -- it is close to the resting position of the left hand on the keyboard.</p> </li> <li> <p>The use of H J K L for movement is more ubiquitous than you think.  In the Web-version of Gmail, Facebook, and Reddit, for instance, you could use J and K to move up and down across posts.</p> </li> </ul>"},{"location":"vim/philosophy.html#multi-modal-editor","title":"Multi-modal Editor","text":"<p><code>vim</code> is a multi-modal editor.  While most other editors make no distinction between reading and editing, <code>vim</code> makes an explicit distinction between the two.  <code>vim</code> has two basic modes:</p> <ul> <li><code>NORMAL</code> mode: where you read, navigate and manipulate the text.</li> <li><code>INSERT</code> mode: where you insert the text</li> </ul> <p>As a programmer, having a separate <code>NORMAL</code> mode makes sense since we spend much time reading and navigating around source code.  Thus, allowing the editing commands to be optimized.</p> <p>In the <code>NORMAL</code> mode, you can use any of these keys I S A O (with or without Shift) to switch to <code>INSERT</code> mode.  To go back to <code>NORMAL</code> mode, press Esc.  The keys I S A O have different meanings, which you will learn later.</p> <p>Note that most of the time you will be in <code>NORMAL</code> mode.  So a habitual <code>vim</code> user would insert some text and immediately switch back to normal mode by hitting Esc.</p>"},{"location":"vim/philosophy.html#tell-vim-what-you-want-to-do-dont-do-it-yourself","title":"Tell <code>vim</code> What You Want To Do; Don't Do It Yourself","text":"<p>In <code>NORMAL</code> mode, you can manipulate text in <code>vim</code> by issuing commands to <code>vim</code>.  These commands are like a programming language.  It is also not unlike the Unix commands, in that each command does a small thing but can be composed together to perform complex text manipulation.</p> <p>Let me give an example here.  Suppose you have a sentence:</p> <pre><code>Wherever there is light, there is also a shadow.\n</code></pre> <p>You want to remove <code>also a</code> from the sentence.</p> <p>What would you do in a typical text editor?  You can use move your hand away from the keyboard, find your mouse, move your mouse cursor to highlight the text, and then hit Del.  Or you could move the cursor (by mouse or by repeatedly hitting the keyboard) to place the cursor after <code>a</code>, and then press Del six times.</p> <p>In addition to being tedious, this is error-prone.  You might highlight one additional or one less space, or hit Del one too many times.</p> <p>What we are used to doing is performing the action of deleting the words ourselves.  For <code>vim</code>, we do it differently.  We need to look for the word <code>also</code> and delete two words.  This translates to the command / A L S O Enter D 2 W.</p> <ul> <li>/ triggers a search.  This is an almost universal command -- try / on Facebook (web) or on this page.</li> <li>A L S O Enter tells <code>vim</code> what you want to search. After pressing Enter, your cursor should be placed at the beginning of <code>also</code>.</li> <li>D 2 W tell <code>vim</code> to \"delete two words\".</li> </ul> <p>Instead of worrying about the actual actions to perform the deletion, we issue higher-level commands to describe what we want to do.  This is powerful since this is how our brain thinks -- \"I need to insert this here, change this word to that, remove two lines, etc.\"  All these maps into commands in <code>vim</code>.  As a result, once you master <code>vim</code> basics, you can type as fast as you think<sup>1</sup>!</p> <p>A common pattern for <code>vim</code> command consists of three parts:</p> <ol> <li>Place the cursor.</li> <li>Perform an action.</li> <li>Move to the new placement of the cursor.</li> </ol> <p>In the example above, / A L S O Enter places the cursor, D is the action (delete), and 2 W is the movement (move the cursor forward by two words).</p> <p>Another common command that students used is G G = Shift+G.  This command is used to indent the source code in the current file.  G G is the command to place the cursor at the top of the file.  = is the action (indent), and Shift+G is the command to place the cursor on the last line of the file.</p>"},{"location":"vim/philosophy.html#be-a-good-unix-citizen","title":"Be A Good Unix Citizen","text":"<p>Not only do the basic commands <code>vim</code> adhere to the Unix principles of composability, <code>vim</code> plays well with Unix shells, which adds additional power to <code>vim</code>.  For instance, if you want to have the standard output from a command paste into the file you are editing, you can run:</p> <pre><code>:r! &lt;command&gt;\n</code></pre> <p>: triggers the <code>vim</code> command line.  R ask <code>vim</code> to read something and paste it into the current cursor location.  At this point, you can pass in, for instance, another file name.  But here, we enter !, which tells <code>vim</code> to run a shell.  We then pass the <code>command</code> to the shell.  Whatever the command writes to the standard output, will be read and inserted into <code>vim</code>.</p> <p>Want to insert today's date?</p> <pre><code>:r! date\n</code></pre> <p>Want to insert a mini calendar?</p> <pre><code>:r! cal\n</code></pre> <p>Want to insert the list of all JPG pictures?</p> <pre><code>:r! ls *jpg\n</code></pre> <p>You can even pass a chunk of text from <code>vim</code> to the standard input of another program, and replace it with what is printed to the standard output by that program.</p>"},{"location":"vim/philosophy.html#other-reasons-to-learn-vim","title":"Other Reasons To Learn <code>vim</code>","text":"<p>Besides enabling you to type as fast as you think with as few hand movements as possible, there are other reasons to use <code>vim</code>:</p> <ul> <li> <p><code>vim</code> is installed by default in almost any Unix environment.  Imagine if you get called to a client-side to debug a Linux server, and you need to edit something -- you can rest assured that <code>vim</code> is there.</p> </li> <li> <p><code>vim</code> is the only source code editor you need to learn and master.  It works for almost any programming language.  If you use IDE, you have to learn IntelliJ for Java, IDLE for Python, Visual Studio C++ for C++, etc.  This reason is also why VS Code has gained significant popularity in recent years.</p> </li> <li> <p><code>vim</code> is extensible and programmable.  It has been around for almost 30 years, and tons of plugins have been written.  Whatever feature you need, there is likely a native <code>vim</code> command or a <code>vim</code> plugin for that.</p> </li> </ul> <p>The only downside to using <code>vim</code> is that it is terminal-based (some consider it ugly) and it has a steep learning curve.  But, in our experience, students will build up their muscle memory and are comfortable with <code>vim</code> after 2-3 weeks of usage.</p> <p>For CS1010, there is another practical reason to learn and gain familiarity with <code>vim</code>.  The practical exams are conducted in a sandboxed environment, which you can only access through <code>ssh</code> via a terminal.  You only have a few choices (<code>emacs</code>, <code>nano</code>, <code>vim</code>) and <code>vim</code> is the only reasonable choice. </p> <ol> <li> <p>The book Practical Vim by Drew Neil has the subtitle \"Edit text at the speed of thought\".\u00a0\u21a9</p> </li> </ol>"},{"location":"vim/plugins.html","title":"Vim Extensions on PE Hosts","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand plugins and color schemes.</li> </ul>"},{"location":"vim/plugins.html#background","title":"Background","text":"<p>CS2030S provides a minimal set of vim extensions (i.e., plugins and color schemes) officially.  At the beginning of the semester, students can install the same set of extensions following the vim setup procedure.  The same set of official extensions will be made available during the practical exams.</p> <p>Students are free to install any additional color schemes or plugins if they wish.  These additional extensions, however, are not allowed and will not be available during the practical exams.</p> <p>The following are the officially supported vim extensions in CS2030S.</p>"},{"location":"vim/plugins.html#color-schemes","title":"Color Schemes","text":"<p>We installed three color schemes <code>~cs2030s/.vim/colors</code>.  You may copy them over to your own home directory, by running</p> <pre><code>mkdir -p ~/.vim\ncp -r ~cs2030s/.vim/colors ~/.vim\n</code></pre> <p>The three color schemes are:</p> <ul> <li>gruvbox</li> <li>molokai</li> <li>onedark</li> </ul> <p>You can change your vim color scheme using the <code>:color</code> command.  For instance,</p> <pre><code>:color gruvbox\n</code></pre> <p>You can add the line <code>color gruvbox</code> (without <code>:</code>) to your <code>~/.vimrc</code> so that the color scheme is loaded at the start of every vim session.</p> <p>Some color schemes display differently depending on whether the background is set to <code>dark</code> or <code>light</code></p> <p>Some examples, with <code>set background=dark</code> in <code>~/.vimrc</code>:</p> <p>The Vim default color scheme:</p> <p></p> <p>The molokai (CS2030S's default) color scheme:</p> <p></p> <p>The gruvbox color scheme </p> <p></p>"},{"location":"vim/quick-lessons.html","title":"Quick <code>vim</code> Lessons","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>have a basic familiarity with <code>vim</code>.</li> </ul> <p>Here is a quick walkthrough to get a taste of <code>vim</code>.</p>"},{"location":"vim/quick-lessons.html#lesson-1-preparation","title":"Lesson 1: Preparation","text":""},{"location":"vim/quick-lessons.html#step-1-download","title":"Step 1: Download","text":"<p>Download the following file for practice using <code>vim</code> in this session.</p> <pre><code>$ wget https://www.comp.nus.edu.sg/~ooiwt/unix-workshop/jfk.txt\n</code></pre> <p>You should see the following on your terminal.</p> <p></p> <p>The file named <code>jfk.txt</code> should be downloaded.  You can check by typing the following</p> <pre><code>$ ls\n</code></pre>"},{"location":"vim/quick-lessons.html#step-2-open","title":"Step 2: Open","text":"<p>Now let's start your first <code>vim</code> session.  Open <code>vim</code> and load the downloaded <code>jfk.txt</code> using the following command</p> <pre><code>$ vim jfk.txt\n</code></pre> <p></p>"},{"location":"vim/quick-lessons.html#lesson-2-navigation","title":"Lesson 2: Navigation","text":""},{"location":"vim/quick-lessons.html#step-1-moving","title":"Step 1: Moving","text":"<p>When you start, you will be in <code>NORMAL</code> mode.  Do not go into the <code>INSERT</code> mode yet.  Try the following exercise to get comfortable with the keys.</p> <ul> <li>Move the cursor around step-by-step backward (H), down (J), forward (K), and up (L).</li> <li>Move the cursor sentence-by-sentence forward ()) and backward (().</li> <li>Move the cursor paragraph-by-paragraph forward (}) and backward ({).</li> <li>Move the cursor page-by-page forward (Ctrl+F) and backward (Ctrl+B).</li> <li>Move the cursor to the beginning of the line with 0.</li> <li>Move the cursor to the end of the line with Shift+4 (i.e., <code>$</code>).</li> <li>Move the cursor to the beginning of the file with G G.</li> <li>Move the cursor to the end of the file with Shift+G (i.e., <code>G</code>).</li> </ul>"},{"location":"vim/quick-lessons.html#step-2-searching","title":"Step 2: Searching","text":"<p>Now try the following steps in <code>NORMAL</code> mode:</p> <ol> <li>Press /.</li> <li>Type in any word (or prefix of a word), we recomment the word <code>the</code>.</li> <li>Press Enter.</li> </ol> <p>After step 2, you should see the following with your command highlighted in red box.</p> <p></p> <p>This should move the cursor to the beginning of the word.  You can use N and Shift+N to move to the next match and the previous match.</p> <p>When you are comfortable moving around, you can type Shift+Z+Z to exit.</p> <p>Congratulations, you have just completed your first session in <code>vim</code>!</p>"},{"location":"vim/quick-lessons.html#lesson-3-manipulating-text","title":"Lesson 3: Manipulating Text","text":"<p>Now, we are going to open up the same file again and try to manipulate the text.  We are going to stay in the <code>NORMAL</code> mode still.</p> <pre><code>$ vim jfk.txt\n</code></pre>"},{"location":"vim/quick-lessons.html#step-1-deletion","title":"Step 1: Deletion","text":"<p>Deletion is actually closer to cut.  The deleted characters are stored in buffer.  Try the following:</p> <ul> <li>Press 0 D 3 W to move the cursor to the beginning of the line and delete three words.</li> <li>Press U to undo.  This is another lifesaver that you should remember.</li> </ul> <p>In <code>vim</code>, repeating the same command twice usually means applying it to the whole line.  Pairing a command with Shift (or the capital letter version) usually means applying the action until the end of the line.  </p> <ul> <li>Press D D to delete the current line.</li> <li>Press Shift+D to delete from the current cursor until the end of the line.</li> </ul>"},{"location":"vim/quick-lessons.html#step-2-copy-pasting","title":"Step 2: Copy-Pasting","text":"<p>Pasting recovers what are available in the buffer.  Try the following:</p> <ul> <li>Press P to paste back what you just deleted.</li> <li>Move the cursor to somewhere else.</li> <li>Press P to paste again.</li> </ul> <p>We can also copy instead of cut (or delete and put into buffer).</p> <ul> <li>Press Y Y to copy (or yank) the current line.</li> <li>Move the cursor to somewhere else.</li> <li>Press P to paste the copied line.</li> </ul> <p>Remember that all these commands can be composed using the movement-action-movement pattern.</p> <ul> <li>Press Shift+9 Y Shift+0 to<ul> <li>move to the beginning of the sentence: Shift+9 (i.e., {) </li> <li>copy (i.e., yank): Y</li> <li>until the end of the sentence: Shift+0 (i.e., })</li> </ul> </li> </ul> <p>As you have seen in the D 2 W example, you can precede an action with a number to repeat an action multiple times.</p> <ul> <li>Press Y Y 9 P.<ul> <li>You should be able to understand what just happened!</li> </ul> </li> </ul>"},{"location":"vim/quick-lessons.html#step-3-deleting-a-character","title":"Step 3: Deleting a Character","text":"<p>The X command deletes the current character.</p> <p>Try this exercise: At the end of the file <code>jfk.txt</code>, there are some typos:</p> <pre><code>libertyi. liberty.\n</code></pre> <p>Change <code>libertyi. liberty.</code> to <code>liberty.</code> by positioning the cursor on the second <code>i</code> and deleting it.  Then use Shift+D to delete the extra <code>liberty.</code> at the end of the sentence.</p>"},{"location":"vim/quick-lessons.html#step-4-visual-mode","title":"Step 4: Visual Mode","text":"<p>In addition to the <code>INSERT</code> and <code>NORMAL</code> modes, <code>vim</code> has the third mode, the <code>VISUAL</code> mode.  You can enter the <code>VISUAL</code> mode by hitting V.  Once in visual mode, you can move your cursor to select the text and perform some actions on it (e.g., D or X to delete, Y to yank).</p> <p>Hitting Shift+V will allow you to select line-by-line.</p> <p>The <code>VISUAL</code> mode allows us to pipe the selected text to another Unix command, and replace it with the result of that command.</p> <p>Go ahead and try the following:</p> <ol> <li>Select a paragraph in <code>jfk.txt</code>.</li> <li>Press :.</li> </ol> <p>You will see that</p> <pre><code>:'&lt;,'&gt;\n</code></pre> <p>appears in the last line of the terminal.  At this point, you can type in actions that you want to perform on the selected text.  For instance,</p> <pre><code>:'&lt;,'&gt;w john.txt\n</code></pre> <p>will write it to a file named <code>john.txt</code>.</p> <p>But, let's try the following:</p> <pre><code>:'&lt;,'&gt;!fmt\n</code></pre> <p><code>!fmt</code> tells <code>vim</code> to invoke the shell and run <code>fmt</code>.  <code>fmt</code> is another simple small Unix utility that takes in a text (from standard input) and spews out formatted text in the standard output.  You will see that the width of the text has changed to the default of 65.</p> <p>You can try something that we have seen before.  Select the text again, and hit</p> <pre><code>:'&lt;,'&gt;!wc\n</code></pre> <p>The selected text will be replaced with the output from <code>wc</code>.</p>"},{"location":"vim/quick-lessons.html#step-5-the-command","title":"Step 5: The <code>:</code> command","text":"<p>You have seen examples of <code>:</code> commands for writing to a file or piping selected text to an external command.</p> <p>The <code>:</code> command also enables many actions that you can do in <code>vim</code>.  Here are a few essential yet simple commands.</p> <ul> <li>To jump to a line, hit : followed by the line number.</li> <li>To open another file, hit : and then type in <code>e &lt;filename&gt;</code></li> <li>To find help on a topic, hit : and then type in <code>help &lt;keyword&gt;</code></li> </ul> <p>Other advanced features such as search-and-replace, changing preferences, splitting windows, and opening new tabs, are also accessible from the <code>:</code> command.</p> <p>The <code>:</code> command prompt supports Ctrl+P and Ctrl+N for navigating back and forth your command history, just like <code>bash</code>.  It also supports Tab for auto-completion.</p>"},{"location":"vim/quick-lessons.html#lesson-3-insert-mode","title":"Lesson 3: Insert mode!","text":"<p>Finally, we are going to try inserting some text.  Remember, to use <code>INSERT</code> mode, we always start with a command I A O or S (may pair with Shift) followed by the text that you want to insert, followed by Esc.</p>"},{"location":"vim/quick-lessons.html#step-1-insert","title":"Step 1: Insert","text":"<p>Let's try I (insert).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press I to go into <code>INSERT</code> mode</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>You just added some text to the file.</p>"},{"location":"vim/quick-lessons.html#step-2-append","title":"Step 2: Append","text":"<p>Now let's try A (append).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press A.</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>A appends the text to the end of the current line.</p>"},{"location":"vim/quick-lessons.html#step-3-open","title":"Step 3: Open","text":"<p>Now let's try O (open).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press O.</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>O opens up a new line for your text.</p>"},{"location":"vim/quick-lessons.html#step-4-substitute","title":"Step 4: Substitute","text":"<p>Now let's try S (substitute).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press S.</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>S substitute the current character with your text.</p>"},{"location":"vim/quick-lessons.html#step-5-shift","title":"Step 5: Shift","text":"<p>Now try it with Shift and see the difference in behavior.</p>"},{"location":"vim/quick-lessons.html#learning-more","title":"Learning More","text":"<p>You can run <code>vimtutor</code> to learn more about <code>vim</code>.</p> <p>You can also check out the tips that we have collected for CS1010 or watch the various tutorials online.  </p> <p>Here are some useful resources on <code>vim</code>:</p> <ul> <li>Learn vim Progressively.</li> <li>Vim: Precision Editing at the Speed of Thought: A talk by Drew Neil</li> <li>Vim Adventure: An adventure game for learning <code>vim</code></li> <li>Vim Casts: Videos and articles for teaching <code>vim</code></li> <li>Vim Video Tutorials by Derek Wyatt</li> <li>Vim Awesome: Directory of plugins.</li> </ul>"},{"location":"vim/setup.html","title":"Setting Up <code>vim</code> on PE Hosts","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>have <code>vim</code> installed on their account on PE nodes.</li> </ul>"},{"location":"vim/setup.html#vim-configuration","title":"<code>vim</code> Configuration","text":"<p>Like many other Unix programs, you can configure your preferences by creating an <code>rc</code> (run commands) file in your home directory.  These <code>rc</code> files will be read by the corresponding programs and executed line-by-line as if the text is entered into the program through a keyboard.  You can view an <code>rc</code> file as a script that will be executed automatically whenever a program starts.</p> <p>For <code>vim</code>, the <code>rc</code> file is called <code>.vimrc</code>.  The dot (i.e., <code>.</code>) in the front of the file name carries a special meaning in Unix.  It means that this file is hidden -- you won't see it when you <code>ls</code>.  Hiding the run command files prevent your home directory from being cluttered.  To tell <code>ls</code> to show the hidden files, use the <code>-a</code> flag</p> <pre><code>$ ls -a\n</code></pre> <p>We have created a <code>.vimrc</code> file, with CS2030S defaults, for your use.  This is the basis upon which you can build your own configuration. </p> <p>To copy this file to your home directory on the PE nodes,</p> <pre><code>$ cp ~cs2030s/.vimrc ~\n</code></pre> <p>You can ask <code>vim</code> to automatically back up the files that you edit.  This has been a lifesaver for me on multiple occasions.</p> <p>The default <code>.vimrc</code> contains the following two lines:</p> <pre><code>set backup\nset backupdir=~/.backup\n</code></pre> <p>This causes <code>vim</code> to save the previous version of every file you edited in a backup directory at location <code>~/.backup</code>.  You need to create this directory, however, by</p> <pre><code>$ mkdir -p ~/.backup\n</code></pre> <p>Now, if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under <code>~/.backup</code> to see if the backup can save you.</p>"},{"location":"vim/setup.html#recovering-from-backup","title":"Recovering from Backup","text":"<p>To recover the file from the backup folder, you can copy the file using</p> <pre><code>$ cp ~/.backup/&lt;filename&gt; &lt;destination&gt;/&lt;filename&gt;\n</code></pre>"},{"location":"vim/setup.html#vim-plugins","title":"<code>vim</code> Plugins","text":"<p>CS2030S provides a minimal set of <code>vim</code> extensions by default for your labs and practical exams.  See the article on <code>vim</code> plugins for details.  </p> <p>Additional <code>vim</code> extensions are installed under <code>~/.vim</code>.  To install these \"official\" CS2030S <code>vim</code> extensions, you can copy the <code>.vim</code> from cs2030s's home directory to your home directory.  On the PE host, run:</p> <pre><code>mkdir -p ~/.vim\ncp -r ~cs2030s/.vim/* ~/.vim\n</code></pre> <p>You can test out the different color schemes according to the instructions to check if you have set up the plugins correctly.  The default CS2030S <code>.vimrc</code> uses the <code>molokai</code> color schemes.</p>"},{"location":"vim/tips.html","title":"Vim Tips","text":"<p>I collected some tips on <code>vim</code> that I find helpful for students. </p> <p>Prerequisite</p> <p>You have gone through the basic quick lessons and have set up your vim in your PE account.</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to compare files (e.g., input/output matching for correctness).</li> <li>be able to recover from <code>.swp</code> file in <code>vim</code>.</li> </ul>"},{"location":"vim/tips.html#1-useful-configuration","title":"1. Useful Configuration","text":""},{"location":"vim/tips.html#showing-line-numbers","title":"Showing Line Numbers","text":"<p>If you prefer to show the line number on every line in <code>vim</code>, add</p> <pre><code>set number\n</code></pre> <p>to your <code>~/.vimrc</code>.</p>"},{"location":"vim/tips.html#2-navigation","title":"2. Navigation","text":""},{"location":"vim/tips.html#faster-navigation","title":"Faster Navigation","text":"<p>If you find yourselves typing too many HJKL to navigate around your code, check out the following shortcuts to navigate around:</p> <p>To move word-by-word:</p> <ul> <li>W jump to the beginning of the next word</li> <li>B ump to the beginning of the previous word (reverse of <code>w</code>)</li> <li>E jump to the end of the word (or next word when pressed again)</li> </ul> <p>To search:</p> <ul> <li>F char: search forward in the line and sit on the next matching char</li> <li>T char:  search forward in the line and sit on one space before the matching char</li> </ul> <p>0 would move you to the beginning of the line, but when coding, it is sometimes useful to jump to the first non-blank character instead.  To do so, use Shift+6 (i.e., <code>^</code>).</p> <p>In coding, we have many pairs of <code>[]</code>, <code>{}</code>, <code>()</code> and <code>&lt;&gt;</code>.  You can use Shift+5 (i.e., <code>%</code>) jump between matching parentheses.</p>"},{"location":"vim/tips.html#jump-to-a-line","title":"Jump to a Line","text":"<p>If the compiler tells you there is an error on Line \\(x\\), you can issue <code>:&lt;x&gt;</code> to jump to Line \\(x\\).  For instance, <code>:40</code> will go to Line 40.</p>"},{"location":"vim/tips.html#3-editing-operations","title":"3. Editing Operations","text":""},{"location":"vim/tips.html#undo-and-redo","title":"Undo and Redo","text":"<p>Since we are on the topic of correcting mistakes, U in command mode undo your changes.  Prefix it with a number \\(n\\) to undo \\(n\\) times.  If you want to undo your undo, Ctrl+R will redo.</p>"},{"location":"vim/tips.html#navigation-editing","title":"Navigation + Editing","text":"<p><code>vim</code> is powerful because you can combine operations with navigation.  For instance C to change, D to delete, Y to yank (copy).  Since W is the navigation command to move over the current word, combining them we get:</p> <ul> <li>CW change the current word (delete the current word and enter insert mode)</li> <li>DW delete the current word</li> <li>YW yank the current word (copy word into buffer)</li> </ul> <p>Can you guess what each of these does:</p> <ul> <li>DFShift+0 </li> <li>DFShift+0 </li> <li>CShift+4</li> <li>Y0</li> </ul> <p>If you repeat the operation C, D, and Y, it applies to the whole line, so:</p> <ul> <li>CC change the whole line</li> <li>DD delete the whole line</li> <li>YY yank the whole line</li> </ul> <p>You can add a number before an operation to specify how many times you want to repeat an operation.  So 5DD  deletes 5 lines, 5DW deletes 5 words, etc.</p> <p>See the article Operator, the True Power of <code>Vim</code> for more details.</p>"},{"location":"vim/tips.html#swapping-lines","title":"Swapping Lines","text":"<p>Sometimes you want to swap the order of two lines of code, in command mode, DDP will do the trick.  DD deletes the current line, P paste it after the current line, in effect swapping the order of the two lines.</p>"},{"location":"vim/tips.html#commenting-blocks-of-code","title":"Commenting blocks of code","text":"<p>Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in <code>vim</code>:</p> <ul> <li>Place the cursor on the first line of the block of code you want to comment on.</li> <li>0 to jump to the beginning of the line</li> <li>Shift+V enter visual mode</li> <li>Use the arrow key to select the block of code you want to comment on.</li> <li>Shift+I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)</li> <li>// to insert the C comment character (you will see it inserted in the current line, but don't worry)</li> <li>Esc to escape from the visual code.</li> </ul> <p>To uncomment,</p> <ul> <li>Place the cursor on the first line of the block of code you want to comment.</li> <li>0 to jump to the beginning of the line</li> <li>Ctrl+V enter block visual mode</li> <li>Use the arrow key to select the columns of text containing <code>//</code></li> <li>X to delete them</li> </ul>"},{"location":"vim/tips.html#4-other-useful-commands","title":"4. Other Useful Commands","text":""},{"location":"vim/tips.html#search-and-replace-in-vim","title":"Search and Replace in <code>vim</code>","text":"<pre><code>:%s/oldWord/newWord/gc\n</code></pre> <p><code>:</code> enters the command mode.  <code>%</code> means apply to the whole document, <code>s</code> means substitute, <code>g</code> means global (otherwise, only the first occurrence of each line is replaced). <code>c</code> is optional -- adding it cause <code>vim</code> to confirm with you before each replacement  </p>"},{"location":"vim/tips.html#shell-command","title":"Shell Command","text":"<p>If you need to issue a shell command quickly, you don't have to exit <code>vim</code>, run the command, and launch <code>vim</code> again.  You can use <code>!</code>,</p> <pre><code>:!&lt;command&gt;\n</code></pre> <p>will issue the command to shell.  E.g.,</p> <pre><code>:!ls\n</code></pre> <p>You can use this to compile your current file, without exiting <code>vim</code>.</p> <pre><code>:!make\n</code></pre> <p><code>make</code> is a builtin command for <code>vim</code>, so you can also simply run</p> <pre><code>:make\n</code></pre>"},{"location":"vim/tips.html#terminal","title":"Terminal","text":"<p>You can open an interactive shell from within <code>vim</code> with:</p> <pre><code>:terminal\n</code></pre> <p>This command splits the window and add a terminal, within which you can compile or run your code.  </p>"},{"location":"vim/tips.html#abbreviation","title":"Abbreviation","text":"<p>You can use the command <code>ab</code> to abbreviate frequently typed commands.  E.g., in your <code>~/.vimrc</code>,</p> <pre><code>ab pl cs1010_print_long(\n</code></pre> <p>Now, when you type <code>pl</code>, it will be expanded into <code>cs1010_print_long(</code></p>"},{"location":"vim/tips.html#auto-completion","title":"Auto-Completion","text":"<p>You can use Ctrl+P or Ctrl+N to auto-complete.  By default, the autocomplete dictionary is based on the text in your current editing buffers.  This is a very useful keystroke saver for long function names and variable names.</p>"},{"location":"vim/tips.html#auto-indent-the-whole-file","title":"Auto-Indent the Whole File","text":"<p>You can GG=Shift+G in command mode (i.e., type out <code>gg=G</code>) to auto-indent the whole file.  GG is the command to go to the beginning of the file.  = is the command to indent.  Shift+G is the command to go to the end of the file.</p>"},{"location":"vim/tips.html#split-vims-viewport","title":"Split <code>vim</code>'s Viewport","text":"<ul> <li><code>:sp file.c</code> splits the <code>vim</code> window horizontally</li> <li><code>:vsp file.c</code> splits the <code>vim</code> window vertically</li> <li>Ctrl+WCtrl+W moves between the different <code>vim</code> viewports</li> </ul> <p>Alternatively, run <code>vim -O file1 file2</code> to immediately open both files in two different viewpoints.</p>"},{"location":"vim/tips.html#compare-two-files","title":"Compare two files","text":"<p>You can compare two files with <code>vim</code>, using the <code>-d</code> flag.  For instance,</p> <p><code>vim -d file1 file2</code></p> <p>would open up two files for line-by-line comparison.  This is most useful if you want to compare the output of your program with the expected output.</p>"},{"location":"vim/tips.html#5-recovery-files","title":"5. Recovery Files","text":"<p>Vim automatically saves the files you are editing into temporary swap files, with the extension <code>.swp</code>.  These files are hidden, so you don't normally see them when you run <code>ls</code>.  (You need to run <code>ls -a</code> to view the hidden files)</p> <p>The swap files are useful if your editing session is disrupted before you save (e.g., the network is disconnected, you accidentally close the terminal, your OS crashes, etc).</p> <p>When you launch <code>vim</code> to edit a file, say, <code>foo.c</code>.  <code>vim</code> will check if a swap file <code>.foo.c.swp</code> exist.  If it does, <code>vim</code> with display the following</p> <pre><code>Found a swap file by the name \".foo.c.swp\"\n          owned by: elsa   dated: Sat Aug 21 15:01:04 2021\n         file name: ~elsa/foo.c\n          modified: no\n         user name: elsa   host name: pe116\n        process ID: 7863 (STILL RUNNING)\nWhile opening file \"foo.c\"\n             dated: Mon Jul 12 18:38:37 2021\n\n(1) Another program may be editing the same file.  If this is the case,\n    be careful not to end up with two different instances of the same\n    file when making changes.  Quit, or continue with caution.\n(2) An edit session for this file crashed.\n    If this is the case, use \":recover\" or \"vim -r a.c\"\n    to recover the changes (see \":help recovery\").\n    If you did this already, delete the swap file \".a.c.swp\"\n    to avoid this message.\n\nSwap file \".a.c.swp\" already exists!\n[O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort:\n</code></pre> <p>The messages above are self-explanatory.  Read it carefully.  Most of the time, you want to choose \"R\" to recover your edits, so that you can continue editing.  Remember to remove the file <code>.foo.c.swp</code> after you have recovered.  Otherwise, <code>vim</code> will prompt you the above messages every time you edit <code>foo.c</code>.</p> <p>Warning</p> <p>If <code>foo.c</code> is newer than the state saved in <code>.foo.c.swp</code>, and you recover from <code>.foo.c.swp</code>, you will revert to the state of the file as saved in the swap file.  This can happen if (i) you edit the file without recovery, or (ii) you recover the file, continue editing, but did not remove the <code>.foo.c.swp</code> file after.</p>"}]}